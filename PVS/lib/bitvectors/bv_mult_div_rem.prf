(BitvectorUtil (bvec_induction 0 (bvec_induction-1 nil 3249114866 3249231170 ("" (skolem!) (("" (flatten) (("" (case "FORALL(n:nat) : FORALL (bv: bvec[N]): bv2nat(bv) = n IMPLIES p!1(bv)") (("1" (skosimp*) (("1" (inst - "bv2nat(bv!1)") (("1" (inst - "bv!1") nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (skosimp*) (("1" (rewrite "bv2nat_eq0") nil nil)) nil) ("2" (skosimp*) (("2" (lemma "bv_minus1[N]") (("2" (inst - "bv!1") (("2" (assert) (("2" (replace -3) (("2" (assert) (("2" (inst - "bv!1 - 1") (("2" (assert) (("2" (inst - "bv!1 - 1") (("2" (assert) (("2" (lemma "bv_add_2_consts[N]") (("2" (inst - "bv!1" "-1" "1") (("2" (expand "-" -6) (("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (lemma "bv_plus0[N]") (("2" (inst - "bv!1" "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((- const-decl "bvec[N]" bv_arith_nat nil) (bv_add_2_consts formula-decl nil bv_arith_nat nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv_minus1 formula-decl nil bv_arith_nat nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (PRED type-eq-decl nil defined_types nil)) 1761 990 nil nil)) (plus_min_zero_TCC1 0 (plus_min_zero_TCC1-1 nil 3249114866 3249231170 ("" (use "N_size") (("" (assert) nil nil)) nil) proved ((N_size formula-decl nil BitvectorUtil nil)) 17 10 nil nil)) (plus_min_zero 0 (plus_min_zero-1 nil 3249114866 3249231171 ("" (use "N_size") (("" (skosimp*) (("" (case "bv2nat[N](bv!1 + (-bv!1)) = 0") (("1" (lemma "bv2nat_eq0[N]") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "bv_add[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (reduce) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) proved ((bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (bv_add formula-decl nil bv_arith_nat nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (N_size formula-decl nil BitvectorUtil nil)) 1580 710 nil nil)) (min_fill_F 0 (min_fill_F-1 nil 3249114866 3249231172 ("" (use "N_size") (("" (lemma "bv_sub_identity_L") (("" (inst - "N" "fill[N](FALSE)") (("1" (rewrite "bv_add_fill_F[N]") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) proved ((bv_sub_identity_L formula-decl nil bv_arith_minus_rules nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) 833 380 nil nil)) (inc_zero_TCC1 0 (inc_zero_TCC1-1 nil 3249114866 3249231172 ("" (use "N_size") (("" (assert) nil nil)) nil) proved ((N_size formula-decl nil BitvectorUtil nil)) 15 10 nil nil)) (inc_zero 0 (inc_zero-1 nil 3249114866 3249231179 ("" (use "N_size") (("" (skosimp*) (("" (prop) (("1" (lemma "bv_plus1[N]") (("1" (inst - "bv!1") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (lemma "bv2nat_eq0[N]") (("1" (inst - "bv!1+1") (("1" (assert) (("1" (replace -1) (("1" (expand "fill") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (case-replace "N=1") (("1" (grind) nil nil) ("2" (lemma "bv2nat_lem") (("2" (inst-cp - "N" "bv!1") (("1" (inst - "N" "bv!1+1") (("1" (assert) (("1" (replace*) (("1" (hide -1 -2) (("1" (expand "^" -1 1) (("1" (expand "b2n") (("1" (expand "^" -1 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2nat[N](bv!1 + 1) = bv2nat[N](LAMBDA (i: below(N)): (i = 0) OR bv!1(i))") (("1" (use "bv2nat_inj[N]") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case-replace "bv2nat[N](bv!1 + 1) = bv2nat[N](bv!1) + 1") (("1" (hide -1) (("1" (expand "bv2nat") (("1" (case "FORALL(n:below(N+1)) : n > 0 IMPLIES 1 + bv2nat_rec(n, bv!1) =
                                                              bv2nat_rec(n, LAMBDA (i: below(N)): (i = 0) OR bv!1(i))") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (case-replace "jb!1=0") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "bv2nat_rec" +) (("2" (replace -2) (("2" (hide -2) (("2" (assert) (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "bv!1+1") (("2" (typepred "mod(1 + bv2nat(bv!1), exp2(N))") (("2" (expand "abs") (("2" (assert) (("2" (case "bv2nat(bv!1) < exp2(N)-1") (("1" (assert) (("1" (expand "mod") (("1" (assert) (("1" (case-replace "floor((1 + bv2nat(bv!1)) / exp2(N)) = 0") (("1" (assert) nil nil) ("2" (hide -2 -3 -4 2) (("2" (case "floor((1 + bv2nat(bv!1)) / exp2(N)) < 1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "(1 + bv2nat(bv!1)) / exp2(N) < 1") (("1" (typepred "floor((1 + bv2nat(bv!1)) / exp2(N))") (("1" (assert) (("1" (name-replace "tmp" "floor((1 + bv2nat(bv!1)) / exp2(N))") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "div_mult_pos_lt1") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (typepred "bv2nat(bv!1)") (("2" (case "bv2nat(bv!1) = exp2(N) - 1") (("1" (hide -2 1) (("1" (rewrite "bv2nat_eq_max") (("1" (expand "fill") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((OR const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_inj formula-decl nil bv_nat nil) (bv2nat_eq_max formula-decl nil bv_nat nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (below_induction formula-decl nil bounded_nat_inductions nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv_plus1 formula-decl nil bv_arith_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (above nonempty-type-eq-decl nil integers nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat nil) (fill const-decl "bit" bv nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N_size formula-decl nil BitvectorUtil nil)) 7000 3150 nil nil)) (sum_upper_n 0 (sum_upper_n-1 nil 3249114866 3249231181 ("" (skosimp*) (("" (lemma "sigma_split") (("" (inst?) (("" (inst - "n!1") (("" (split) (("1" (replace -1) (("1" (expand "sigma" 1 1) (("1" (reduce) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (case-replace "high!1 = n!1") (("1" (expand "sigma") (("1" (reduce) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((sigma_split formula-decl nil sums nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "nat" sums nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 1389 650 nil nil)) (bv2nat_upper_n 0 (bv2nat_upper_n-1 nil 3249114866 3249231182 ("" (skosimp*) (("" (rewrite "bv2nat_as_sum[N]") (("" (lemma "sum_upper_n") (("" (inst?) (("" (inst -1 "n!1") (("" (assert) (("" (expand "extend" -1 2) (("" (expand "b2n" -1 2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2nat_as_sum formula-decl nil bv_sum nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (extend const-decl "[nat -> nat]" bv_sum nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sum_upper_n formula-decl nil BitvectorUtil nil)) 814 300 nil nil)) (bv2nat_upperbound 0 (bv2nat_upperbound-1 nil 3249114866 3249231192 ("" (skosimp*) (("" (prop) (("1" (skosimp*) (("1" (lemma "bv2nat_upper_n") (("1" (inst - "bv!1" "k!1") (("1" (assert) (("1" (case "k!1 = n!1") (("1" (assert) nil nil) ("2" (lemma "exp2_lt") (("2" (inst - "k!1" "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "n!1=0") (("1" (case-replace "bv!1 = fill[N](FALSE)") (("1" (rewrite "bv2nat_fill_F") (("1" (expand "exp2") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "bv2nat(bv!1) = bv2nat(bv!1^(n!1-1,0))") (("1" (typepred "bv2nat(bv!1 ^ (n!1 - 1, 0))") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (hide 3) (("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[n!1]") (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N-1" "0" "n!1-1") (("2" (assert) (("2" (case-replace "sigma(n!1, N - 1,
                      extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))) = 0") (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n:nat):
                        0 *
                         extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N-1" "n!1") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil) proved ((bv2nat_upper_n formula-decl nil BitvectorUtil nil) (exp2_lt formula-decl nil exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma def-decl "nat" sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (x!1 skolem-const-decl "nat" BitvectorUtil nil) (sigma_split formula-decl nil sums nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil)) 10364 2890 nil nil)) (bv2nat_upperbound_caret_TCC1 0 (bv2nat_upperbound_caret_TCC1-1 nil 3249114866 3249231192 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 301 150 nil nil)) (bv2nat_upperbound_caret_TCC2 0 (bv2nat_upperbound_caret_TCC2-1 nil 3249114866 3249231193 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 290 130 nil nil)) (bv2nat_upperbound_caret 0 (bv2nat_upperbound_caret-1 nil 3249114866 3249231201 ("" (use "N_size") (("" (skosimp*) (("" (use "bv2nat_upperbound") (("" (assert) (("" (hide -3) (("" (case-replace "n!1=0") (("1" (case-replace "bv!1 = fill[N](FALSE)") (("1" (rewrite "bv2nat_fill_F") nil nil) ("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_split") (("2" (inst?) (("2" (inst - "n!1-1") (("2" (assert) (("2" (case-replace "sigma(n!1, N - 1,
                        extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))) = 0") (("1" (replace -2) (("1" (hide -) (("1" (assert) (("1" (rewrite "bv2nat_as_sum[n!1]") (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "extend(LAMBDA (ii: below(n!1)):
                            exp2(ii) * b2n((bv!1 ^ (n!1 - 1, 0))(ii)))" "n!1-1" "0") (("1" (assert) (("1" (hide 3) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "LAMBDA (n:nat):
                    0 *
                     extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "N-1" "n!1") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (bv2nat_rec def-decl "nat" bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (extend const-decl "[nat -> nat]" bv_sum nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nbit type-eq-decl nil bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "nat" BitvectorUtil nil) (sigma_mult formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sigma def-decl "nat" sums nil) (sigma_split formula-decl nil sums nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) 8778 3070 nil nil)) (widen_TCC1 0 (widen_TCC1-1 nil 3249114866 3249231202 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil)) 475 170 nil nil)) (widen_TCC2 0 (widen_TCC2-1 nil 3249114866 3249231202 ("" (subtype-tcc) nil nil) proved nil 22 20 nil nil)) (bv2int_widen_TCC1 0 (bv2int_widen_TCC1-1 nil 3249114866 3249231202 ("" (use "N_size") (("" (assert) nil nil)) nil) proved ((N_size formula-decl nil BitvectorUtil nil)) 409 110 nil nil)) (bv2int_widen 0 (bv2int_widen-1 nil 3249114866 3249231224 ("" (skosimp*) (("" (use "N_size") (("" (rewrite "bv2int_lem") (("" (rewrite "bv2int_lem") (("" (expand "^") (("" (expand "b2n") (("" (expand "widen" 1 2) (("" (assert) (("" (rewrite "bv2nat_as_sum[N]") (("" (rewrite "bv2nat_as_sum[2*N]") (("" (case "bv!1(N - 1)") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst -1 "extend(LAMBDA (ii: below(2 * N)):
                                 exp2(ii) * b2n(widen(bv!1)(ii)))" "2*N-1" "0" "N-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)):
                                 exp2(ii) * b2n(widen(bv!1)(ii)))" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N-1" "0") (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(N, 2 * N - 1,
                                              extend(LAMBDA (ii: below(2 * N)):
                                                       exp2(ii) * b2n(widen(bv!1)(ii))))
                                        = exp2(2 * N) - exp2(N)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "sigma(N, 2 * N - 1,
                                                   extend(LAMBDA (ii: below(2 * N)):
                                                            exp2(ii) * b2n(widen(bv!1)(ii))))
                                              = sigma(N, 2*N-1, LAMBDA(n:nat) : exp2(n))") (("1" (replace -1) (("1" (hide -1 -2) (("1" (case "FORALL(N:posnat) : sigma(N, 2 * N - 1, LAMBDA (n: nat): exp2(n)) = exp2(2 * N) - exp2(N)") (("1" (inst?) nil nil) ("2" (hide 2) (("2" (induct "N") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (case "j!1=0") (("1" (grind) nil nil) ("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (n: nat): exp2(n)" "2*j!1-1" "j!1" "j!1") (("2" (assert) (("2" (case "j!1=1") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "sigma" -1 3) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (n: nat): exp2(n)" "2*j!1+1" "j!1+1" "2*j!1-1") (("2" (assert) (("2" (expand "sigma" -1 3) (("2" (expand "sigma" -1 3) (("2" (replace -1) (("2" (hide -1) (("2" (case " sigma(1 + j!1, 2 * j!1 - 1, LAMBDA (n: nat): exp2(n)) =
                                                                            exp2(2 * j!1) - 2 * exp2(j!1)") (("1" (replace -1) (("1" (hide -1 -2) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "extend(LAMBDA (ii: below(2 * N)):
                                                   exp2(ii) * b2n(widen(bv!1)(ii)))" "LAMBDA (n: nat): exp2(n)" "2*N-1" "N") (("2" (assert) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sigma_split") (("2" (inst -1 "extend(LAMBDA (ii: below(2 * N)):
                                 exp2(ii) * b2n(widen(bv!1)(ii)))" "2*N-1" "0" "N-1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_mult") (("2" (inst -1 "extend(LAMBDA (ii: below(2 * N)):
                                 exp2(ii) * b2n(widen(bv!1)(ii)))" "2*N-1" "N" "0") (("2" (rewrite "zero_times1") (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA(n:nat) :0" "extend(LAMBDA (ii: below(2 * N)):
                                  exp2(ii) * b2n(widen(bv!1)(ii)))" "2*N-1" "N") (("2" (split -) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)):
                                       exp2(ii) * b2n(widen(bv!1)(ii)))" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N-1" "0") (("1" (assert) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((N_size formula-decl nil BitvectorUtil nil) (b2n const-decl "nbit" bit nil) (sigma_mult formula-decl nil sums nil) (zero_times1 formula-decl nil real_props nil) (extend const-decl "[nat -> nat]" bv_sum nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma def-decl "nat" sums nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma_split formula-decl nil sums nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (^ const-decl "bit" bv nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (bv2int_lem formula-decl nil bv_int nil) (> const-decl "bool" reals nil)) 21407 7140 nil nil)) (widen_inj 0 (widen_inj-1 nil 3249114866 3249231226 ("" (skosimp*) (("" (iff) (("" (prop) (("1" (expand "widen") (("1" (decompose-equality) (("1" (decompose-equality) (("1" (reduce) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) proved ((widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) 1841 590 nil nil)) (bv2int_plus_widens 0 (bv2int_plus_widens-1 nil 3249114866 3249231230 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "bv2int_add_combined_rule") (("" (expand "in_rng_2s_comp") (("" (rewrite "bv2int_widen") (("" (rewrite "bv2int_widen") (("" (typepred "bv2int[N](bv1!1)") (("1" (typepred "bv2int[N](bv2!1)") (("1" (expand "minint") (("1" (expand "maxint") (("1" (lemma "exp2_lt") (("1" (inst - "2*N-1" "N") (("1" (assert) (("1" (expand "exp2" -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((in_rng_2s_comp const-decl "bool" bv_int nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (exp2_lt formula-decl nil exp2 nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bv2int_widen formula-decl nil BitvectorUtil nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2int_add_combined_rule formula-decl nil bv_arith_int_rules nil) (N_size formula-decl nil BitvectorUtil nil)) 3576 1270 nil nil)) (bv2int_min_widen 0 (bv2int_min_widen-1 nil 3249114866 3249231231 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "bv2int_neg") (("" (rewrite "bv2int_widen") (("" (typepred "bv2int[N](bv!1)") (("1" (expand "minint") (("1" (expand "maxint") (("1" (lemma "exp2_lt") (("1" (inst - "2*N-1" "N-1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int_widen formula-decl nil BitvectorUtil nil) (exp2_lt formula-decl nil exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (> const-decl "bool" reals nil) (N_size formula-decl nil BitvectorUtil nil)) 1400 480 nil nil)) (bv2nat_widen_TCC1 0 (bv2nat_widen_TCC1-1 nil 3249114866 3249231231 ("" (use "N_size") (("" (assert) nil nil)) nil) proved ((N_size formula-decl nil BitvectorUtil nil)) 28 20 nil nil)) (bv2nat_widen 0 (bv2nat_widen-1 nil 3249114866 3249231240 ("" (use "N_size") (("" (skosimp*) (("" (lift-if +) (("" (split +) (("1" (flatten) (("1" (case-replace "(widen(bv!1)) = (fill[N](FALSE) o bv!1)") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst?) (("1" (assert) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "(widen(bv!1)) = (fill[N](TRUE) o bv!1)") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_T") (("1" (assert) (("1" (lemma "exp2_sum") (("1" (inst - "N" "N") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst?) (("1" (assert) (("1" (hide 3) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (x!1 skolem-const-decl "below(2 * N)" BitvectorUtil nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (TRUE const-decl "bool" booleans nil) (bv2nat_fill_T formula-decl nil bv_nat_rules nil) (exp2_sum formula-decl nil exp2 nil) (NOT const-decl "[bool -> bool]" booleans nil) (N_size formula-decl nil BitvectorUtil nil)) 8679 2920 nil nil)) (bv2nat_widen_null 0 (bv2nat_widen_null-1 nil 3249114866 3249231241 ("" (use "N_size") (("" (skosimp*) (("" (iff) (("" (prop) (("1" (lemma "bv2nat_eq0[2*N]") (("1" (inst?) (("1" (assert) (("1" (case "bv!1 = fill[N](FALSE)") (("1" (replace -1 1) (("1" (rewrite "bv2nat_fill_F") nil nil)) nil) ("2" (hide -2 2) (("2" (decompose-equality) (("2" (decompose-equality) (("2" (expand "fill") (("2" (expand "widen") (("2" (use "N_size") (("2" (inst-cp - "N") (("2" (assert) (("2" (inst - "x!1") (("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "bv2nat_eq0[N]") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (hide -1 -2) (("2" (case-replace "(widen(fill[N](FALSE))) = fill[2*N](FALSE)") (("1" (rewrite "bv2nat_fill_F") nil nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) 1421 510 nil nil)) (narrow_TCC1 0 (narrow_TCC1-1 nil 3249114866 3249231241 ("" (use "N_size") (("" (assert) nil nil)) nil) proved ((N_size formula-decl nil BitvectorUtil nil)) 34 30 nil nil)) (narrow_TCC2 0 (narrow_TCC2-1 nil 3249114866 3249231242 ("" (use "N_size") (("" (assert) nil nil)) nil) proved ((N_size formula-decl nil BitvectorUtil nil)) 382 20 nil nil)) (bv2int_narrow 0 (bv2int_narrow-1 nil 3249114866 3249231244 ("" (use "N_size") (("" (skosimp*) (("" (expand "narrow") (("" (use "bv2int_of_sign_extension") (("1" (assert) (("1" (hide 2) (("1" (expand "in_rng_2s_comp") (("1" (expand "minint") (("1" (expand "maxint") (("1" (auto-rewrite "exp2") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) proved ((bv2int_of_sign_extension formula-decl nil bv_arith_int_caret nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (minint const-decl "int" bv_int nil) (exp2 def-decl "posnat" exp2 nil) (maxint const-decl "int" bv_int nil) (in_rng_2s_comp const-decl "bool" bv_int nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) 1828 610 nil nil)) (narrow_int2bv_TCC1 0 (narrow_int2bv_TCC1-1 nil 3249114866 3249231244 ("" (use "N_size") (("" (skosimp*) (("" (expand "minint") (("" (expand "maxint") (("" (lemma "exp2_lt") (("" (inst - "2*N-1" "N-1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((maxint const-decl "int" bv_int nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (exp2_lt formula-decl nil exp2 nil) (minint const-decl "int" bv_int nil) (N_size formula-decl nil BitvectorUtil nil)) 551 240 nil nil)) (narrow_int2bv_TCC2 0 (narrow_int2bv_TCC2-1 nil 3249114866 3249231245 ("" (skosimp*) (("" (expand "minint") (("" (expand "maxint") (("" (auto-rewrite "exp2") (("" (reduce) nil nil)) nil)) nil)) nil)) nil) proved ((minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil)) 408 90 nil nil)) (narrow_int2bv 0 (narrow_int2bv-1 nil 3249114866 3249231247 ("" (use "N_size") (("" (skosimp*) (("" (case "bv2int[N](narrow(int2bv[2 * N](k!1))) = bv2int(int2bv[N](k!1))") (("1" (rewrite "bv2int_inj[N]") nil nil) ("2" (hide 2) (("2" (rewrite "bv2int_narrow") (("2" (rewrite "bv2int_inv[2*N]") (("2" (rewrite "bv2int_inv[N]") nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "minint") (("3" (expand "maxint") (("3" (auto-rewrite "exp2") (("3" (reduce) nil nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (hide 2) (("6" (expand "minint") (("6" (expand "maxint") (("6" (lemma "exp2_lt") (("6" (inst - "2*N-1" "N-1") (("1" (case "k!1 <= exp2(N-1)-1") (("1" (assert) nil nil) ("2" (hide -1 -3 2) (("2" (auto-rewrite "exp2") (("2" (reduce) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (exp2_lt formula-decl nil exp2 nil) (exp2 def-decl "posnat" exp2 nil) (bv2int_inv formula-decl nil bv_int nil) (bv2int_narrow formula-decl nil BitvectorUtil nil) (bv2int_inj formula-decl nil bv_int nil) (> const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (int2bv const-decl "{bv | bv2int(bv) = iv}" bv_int nil) (N_size formula-decl nil BitvectorUtil nil)) 2627 920 nil nil)) (narrow_widen 0 (narrow_widen-1 nil 3249114866 3249231248 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (expand "narrow") (("" (expand "^") (("" (expand "widen") (("" (assert) (("" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil)) 700 190 nil nil)) (narrow_plus 0 (narrow_plus-1 nil 3249114866 3249231251 ("" (use "N_size") (("" (skosimp*) (("" (expand "narrow") (("" (rewrite "bv_add_caret") nil nil)) nil)) nil)) nil) proved ((bv_add_caret formula-decl nil bv_arith_caret_rules nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) 2724 890 nil nil)) (narrow_min 0 (narrow_min-1 nil 3249114866 3249231253 ("" (use "N_size") (("" (skosimp*) (("" (expand "narrow") (("" (rewrite "bv_caret_negate") nil nil)) nil)) nil)) nil) proved ((AND const-decl "[bool, bool -> bool]" booleans nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) 1333 450 nil nil)) (narrow_minus 0 (narrow_minus-1 nil 3249114866 3249231254 ("" (use "N_size") (("" (skosimp*) (("" (expand "-") (("" (rewrite "narrow_plus") (("" (rewrite "narrow_min") nil nil)) nil)) nil)) nil)) nil) proved ((> const-decl "bool" reals nil) (narrow_plus formula-decl nil BitvectorUtil nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (narrow_min formula-decl nil BitvectorUtil nil) (- const-decl "bvec[N]" bv_arithmetic nil) (N_size formula-decl nil BitvectorUtil nil)) 1426 560 nil nil)) (narrow_concat 0 (narrow_concat-1 nil 3249114866 3249231255 ("" (use "N_size") (("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil)) nil) proved ((^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorUtil nil)) 887 550 nil nil)) (leftshift_zero 0 (leftshift_zero-1 nil 3249114866 3249231255 ("" (grind) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil)) 231 180 nil nil)) (leftshift_inc 0 (leftshift_inc-1 nil 3249114866 3249231257 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) proved ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (fill const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil)) 2025 1230 nil nil)) (bv2nat_leftshift_TCC1 0 (bv2nat_leftshift_TCC1-1 nil 3249114866 3249231257 ("" (subtype-tcc) nil nil) proved nil 33 30 nil nil)) (bv2nat_leftshift 0 (bv2nat_leftshift-1 nil 3249114866 3249231266 ("" (skosimp*) (("" (case-replace "n!1=0") (("1" (grind) nil nil) ("2" (use "bv2nat_upperbound") (("1" (assert) (("1" (hide -2) (("1" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (lemma "sigma_mult") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N-1" "0" "exp2(n!1)") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                           exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N-1" "0" "n!1") (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                     extend(LAMBDA (ii: below(N)):
                              exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))
                           (n + n!1)" "LAMBDA (n:nat):
                     exp2(n!1) *
                      extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "N-1" "0") (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst-cp - "extend(LAMBDA (ii: below(N)):
                             exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N-1" "0" "n!1-1") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "sigma(0, n!1 - 1,
                    extend(LAMBDA (ii: below(N)):
                             exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))) = 0") (("1" (hide -1) (("1" (assert) (("1" (case "sigma(N, N - 1 + n!1,
                             extend(LAMBDA (ii: below(N)):
                                      exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))) = 0") (("1" (case-replace "n!1=N-1") (("1" (assert) (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                     exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "2*N-2" "N-1" "N-1") (("1" (assert) nil nil)) nil)) nil) ("2" (inst - "extend(LAMBDA (ii: below(N)):
                                     exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N-1+n!1" "n!1" "N-1") (("2" (assert) nil nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                 exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N-1+n!1" "N" "0") (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat):
                          0 *
                           extend(LAMBDA (ii: below(N)):
                                    exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))
                                 (n)" "extend(LAMBDA (ii: below(N)):
                                 exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N-1+n!1" "N") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (expand "restrict") (("2" (lift-if) (("2" (prop) (("2" (expand "extend") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 3) (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                               exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "n!1-1" "0" "0") (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat):
                        0 *
                         extend(LAMBDA (ii: below(N)):
                                  exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))
                               (n)" "extend(LAMBDA (ii: below(N)):
                               exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "n!1-1" "0") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (apply-extensionality :hide? t) (("2" (expand "restrict") (("2" (lift-if) (("2" (prop) (("2" (expand "extend") (("2" (expand "b2n") (("2" (expand "left_shift") (("2" (expand "^") (("2" (expand "o ") (("2" (assert) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (rewrite "exp2_sum") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst - "x!1") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) proved ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (left_shift const-decl "bvec[N]" bv_shift nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (sigma_mult formula-decl nil sums nil) (sigma_shift formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_split formula-decl nil sums nil) (fill const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma def-decl "nat" sums nil) (exp2_sum formula-decl nil exp2 nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nbit type-eq-decl nil bit nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (n!1 skolem-const-decl "below(N)" BitvectorUtil nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil)) 8526 5060 nil nil)) (bv2nat_rightshift_upperbound 0 (bv2nat_rightshift_upperbound-1 nil 3249114866 3249231274 ("" (skosimp*) (("" (case-replace "n!1=0") (("1" (grind) nil nil) ("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                              exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))" "N-1" "0" "exp2(n!1)") (("2" (replace -1 * rl) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (case "N - 1 - n!1 >= 0") (("1" (inst - "LAMBDA (n:nat):
                          exp2(n!1) *
                           extend(LAMBDA (ii: below(N)):
                                    exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))
                                 (n)" "N-1" "0" "N-n!1-1") (("1" (assert) (("1" (case-replace "sigma(N - n!1, N - 1,
                          LAMBDA (n: nat):
                            exp2(n!1) *
                             extend(LAMBDA (ii: below(N)):
                                      exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))
                                   (n)) = 0") (("1" (assert) (("1" (hide -1) (("1" (replace -2) (("1" (hide -2) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N-1-n!1" "0" "n!1") (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                               extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))
                                     (n + n!1)" "LAMBDA (n: nat):
                              exp2(n!1) *
                               extend(LAMBDA (ii: below(N)):
                                        exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))
                                     (n)" "N-1-n!1" "0") (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N-1" "0" "n!1-1") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (apply-extensionality :hide? t) (("2" (grind) (("2" (rewrite "exp2_sum") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3) (("2" (lemma "sigma_mult") (("2" (inst - "LAMBDA (n: nat):
                              exp2(n!1) *
                               extend(LAMBDA (ii: below(N)):
                                        exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))
                                     (n)" "N-1" "N-n!1" "0") (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (m: nat):
                              0 *
                               (exp2(n!1) *
                                 extend(LAMBDA (ii: below(N)):
                                          exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))
                                       (m))" "LAMBDA (n: nat):
                              exp2(n!1) *
                               extend(LAMBDA (ii: below(N)):
                                        exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))
                                     (n)" "N-1" "N-n!1") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (right_shift const-decl "bvec[N]" bv_shift nil) (exp2 def-decl "posnat" exp2 nil) (extend const-decl "[nat -> nat]" bv_sum nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nbit type-eq-decl nil bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_shift formula-decl nil sums nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (fill const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (exp2_sum formula-decl nil exp2 nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma_split formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (bv2nat_as_sum formula-decl nil bv_sum nil)) 7930 5050 nil nil)) (bv2int_rightshift_upperbound 0 (bv2int_rightshift_upperbound-1 nil 3249114866 3249231276 ("" (skosimp*) (("" (expand "bv2int") (("" (lift-if -) (("" (split -) (("1" (flatten) (("1" (assert) (("1" (use "bv2nat_rightshift_upperbound") (("1" (assert) (("1" (reduce) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int const-decl "rng_2s_comp" bv_int nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_rightshift_upperbound formula-decl nil BitvectorUtil nil)) 2327 650 nil nil)) (rightshift_zero 0 (rightshift_zero-1 nil 3249114866 3249231276 ("" (grind) nil nil) proved ((right_shift const-decl "bvec[N]" bv_shift nil)) 182 180 nil nil)) (rightshift_inc 0 (rightshift_inc-1 nil 3249114866 3249231278 ("" (skosimp*) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil) proved ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (right_shift const-decl "bvec[N]" bv_shift nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil)) 2034 1340 nil nil)) (bv2int_rightshift_pos 0 (bv2int_rightshift_pos-1 nil 3249114866 3249231282 ("" (skosimp*) (("" (expand "bv2int") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (lemma "bv2nat_upperbound") (("2" (inst?) (("1" (assert) (("1" (hide 2 3) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (use "N_size") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int const-decl "rng_2s_comp" bv_int nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (right_shift const-decl "bvec[N]" bv_shift nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil)) 3200 1050 nil nil)) (leftshift1_add_aux_TCC1 0 (leftshift1_add_aux_TCC1-1 nil 3249114866 3249231282 ("" (subtype-tcc) nil nil) proved nil 19 20 nil nil)) (leftshift1_add_aux_TCC2 0 (leftshift1_add_aux_TCC2-1 nil 3249114866 3249231282 ("" (subtype-tcc) nil nil) proved nil 17 20 nil nil)) (leftshift1_add_aux 0 (leftshift1_add_aux-1 nil 3249114866 3249231284 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "n_cout_rec" 1 1) (("2" (inst?) (("2" (replace -2) (("2" (hide -2) (("2" (expand "n_cout_rec" 1 2) (("2" (expand "left_shift") (("2" (expand "^") (("2" (expand "o ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) proved ((oba_cout const-decl "bit" bv_adder nil) (fill const-decl "bit" bv nil) (^ const-decl "bit" bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (FALSE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (n_cout_rec def-decl "bit" bv_adder nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil)) 2004 990 nil nil)) (leftshift1_add 0 (leftshift1_add-1 nil 3249114866 3249231286 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "adder_is_add[N]" :dir rl) (("" (rewrite "adder_is_add[N]" :dir rl) (("" (apply-extensionality :hide? t) (("" (expand "left_shift" 1 1) (("" (expand "fill") (("" (expand "^") (("" (expand "o ") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (case-replace "x!1=0") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "bv_adder") (("2" (case-replace "x!1=1") (("1" (grind) nil nil) ("2" (assert) (("2" (lemma "leftshift1_add_aux") (("2" (inst - "bv1!1" "bv2!1" "x!1-2") (("2" (replace -1) (("2" (hide -1) (("2" (expand "left_shift") (("2" (expand "o ") (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (oba_cout const-decl "bit" bv_adder nil) (n_cout_rec def-decl "bit" bv_adder nil) (/= const-decl "boolean" notequal nil) (leftshift1_add_aux formula-decl nil BitvectorUtil nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (oba_sum const-decl "bit" bv_adder nil) (XOR const-decl "bool" xor_def nil) (^ const-decl "bit" bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (bv_adder const-decl "bvec[N]" bv_adder nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (adder_is_add formula-decl nil bv_adder nil) (> const-decl "bool" reals nil) (N_size formula-decl nil BitvectorUtil nil)) 2404 1440 nil nil)) (narrow_rightshift 0 (narrow_rightshift-1 nil 3249114866 3249231290 ("" (use "N_size") (("" (skosimp*) (("" (case "FORALL(n:nat) : n >= N AND n < 2*N IMPLIES NOT BV!1(n)") (("1" (apply-extensionality :hide? t) (("1" (expand "narrow") (("1" (expand "right_shift") (("1" (expand "o ") (("1" (expand "^") (("1" (lift-if) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (split +) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "fill") (("2" (inst - "n!1 + x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (expand "fill") (("1" (inst - "n!1 + x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "fill") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "fill") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "bv2int") (("2" (lift-if) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (rewrite "bv2nat_as_sum") (("1" (assert) (("1" (skosimp*) (("1" (lemma "sum_upper_n") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(BV!1(ii)))" "2*N-1" "0" "n!2") (("1" (assert) (("1" (split -) (("1" (assert) (("1" (expand "extend" -1 2) (("1" (expand "b2n" -1 2) (("1" (lemma "exp2_lt") (("1" (inst -1 "n!2" "N") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL(n:nat, m:posnat) : n<m IMPLIES n <= m-1") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2nat_as_sum formula-decl nil bv_sum nil) (extend const-decl "[nat -> nat]" bv_sum nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2_lt formula-decl nil exp2 nil) (sum_upper_n formula-decl nil BitvectorUtil nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (right_shift const-decl "bvec[N]" bv_shift nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (fill const-decl "bit" bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (N_size formula-decl nil BitvectorUtil nil)) 3682 2070 nil nil)))(BitvectorMultiplication (IMP_BitvectorUtil_TCC1 0 (IMP_BitvectorUtil_TCC1-1 nil 3249114872 3249231290 ("" (use "N_size") nil nil) proved ((N_size formula-decl nil BitvectorMultiplication nil)) 6 0 nil nil)) (times_rec_TCC1 0 (times_rec_TCC1-1 nil 3249114872 3249231290 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 43 30 nil nil)) (times_rec_TCC2 0 (times_rec_TCC2-1 nil 3249114872 3249231290 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 73 70 nil nil)) (times_rec_TCC3 0 (times_rec_TCC3-1 nil 3249114872 3249231290 ("" (termination-tcc) nil nil) proved nil 16 20 nil nil)) (times_rec_TCC4 0 (times_rec_TCC4-1 nil 3249114872 3249231290 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 67 70 nil nil)) (times_rec_TCC5 0 (times_rec_TCC5-1 nil 3249114872 3249231290 ("" (termination-tcc) nil nil) proved nil 16 20 nil nil)) (times_rec_zero_right 0 (times_rec_zero_right-1 nil 3249114872 3249231292 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "times_rec" +) (("2" (inst?) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "bv_add_fill_F[N]") (("2" (inst - "left_shift(1, fill[N](FALSE))") (("2" (rewrite "bv_add_comm[N]") (("2" (replace -1) (("2" (hide -1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((right_shift const-decl "bvec[N]" bv_shift nil) (left_shift const-decl "bvec[N]" bv_shift nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (bv_add_comm formula-decl nil bv_arith_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 1580 1180 nil nil)) (times_rec_zero_left 0 (times_rec_zero_left-1 nil 3249114872 3249231294 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "times_rec" +) (("2" (expand "fill" 1 1) (("2" (case-replace "right_shift(1, fill[N](FALSE)) = fill[N](FALSE)") (("1" (hide -1) (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (right_shift const-decl "bvec[N]" bv_shift nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 2627 1170 nil nil)) (times_rec_repeat 0 (times_rec_repeat-1 nil 3249114872 3249231296 ("" (induct "n") (("1" (skosimp*) (("1" (expand "exp2") (("1" (use "bv2nat_eq0[N]") (("1" (assert) (("1" (replace -1) (("1" (rewrite "times_rec_zero_left") (("1" (rewrite "times_rec_zero_left") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "times_rec" +) (("2" (inst - "right_shift(1, bv1!1)" "bv2!1" "m!1") (("2" (use "bv2nat_rightshift_upperbound") (("1" (expand "exp2" -1) (("1" (expand "exp2" -1) (("1" (expand "exp2" -3) (("1" (assert) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "N=1") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((right_shift const-decl "bvec[N]" bv_shift nil) (fill const-decl "bit" bv nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (bv2nat_rec def-decl "nat" bv_nat nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat_rightshift_upperbound formula-decl nil BitvectorUtil nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (times_rec_zero_left formula-decl nil BitvectorMultiplication nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 1660 1270 nil nil)) (times_zero_first 0 (times_zero_first-1 nil 3249114872 3249231296 ("" (skosimp*) (("" (expand "*") (("" (rewrite "times_rec_zero_left") nil nil)) nil)) nil) proved ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_zero_left formula-decl nil BitvectorMultiplication nil)) 18 20 nil nil)) (times_zero_second 0 (times_zero_second-1 nil 3249114872 3249231296 ("" (skosimp*) (("" (expand "*") (("" (rewrite "times_rec_zero_right") nil nil)) nil)) nil) proved ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_zero_right formula-decl nil BitvectorMultiplication nil)) 52 20 nil nil)) (times_rec_inc_right_TCC1 0 (times_rec_inc_right_TCC1-1 nil 3249114872 3249231296 ("" (subtype-tcc) nil nil) proved nil 38 40 nil nil)) (times_rec_inc_right_TCC2 0 (times_rec_inc_right_TCC2-1 nil 3249114872 3249231296 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil)) 133 130 nil nil)) (times_rec_inc_right_TCC3 0 (times_rec_inc_right_TCC3-1 nil 3249114872 3249231297 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil)) 136 130 nil nil)) (times_rec_inc_right 0 (times_rec_inc_right-1 nil 3249114872 3249231313 ("" (use "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (lemma "bv_add_fill_F[N]") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "times_rec" +) (("2" (inst - "right_shift(1, bv1!1)" "bv2!1") (("2" (assert) (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (lemma "bv_add_fill_F[N]") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (replace -2) (("1" (hide -2) (("1" (lift-if +) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (replace*) (("1" (name-replace "tmp" "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, 0))") (("1" (lemma "bv_add_two_consts[N]") (("1" (inst -1 "bv2!1" "tmp" "1" "0") (("1" (lemma "bv_plus0[N]") (("1" (inst - "tmp" "0") (("1" (replace -1) (("1" (assert) (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "bv2nat_elim[N]") (("1" (expand "o ") (("1" (expand "^") (("1" (expand "fill") (("1" (assert) (("1" (inst -1 "bv2!1 + tmp" "(LAMBDA (nm: below(N - 1 - jb!1 + (1 + jb!1))):
                                   IF nm < 1 + jb!1 THEN TRUE ELSE FALSE ENDIF)") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (case-replace "bv2nat((LAMBDA (nm: below(N - 1 - jb!1 + (1 + jb!1))):
                                           IF nm < 1 + jb!1 THEN TRUE ELSE FALSE ENDIF)) = 1") (("1" (hide 2) (("1" (lemma "bv2nat_lem_rule") (("1" (inst?) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (expand "b2n") (("1" (expand "^") (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (expand "o ") (("2" (expand "^") (("2" (expand "fill") (("2" (lemma "bv_add_fill_F[N]") (("2" (inst - "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, 0))") (("2" (expand "fill") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (rewrite "leftshift1_add") (("1" (lemma "bv_add_two_consts[N]") (("1" (inst - "bv2!1" "(left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, jb!1)) +
                                 left_shift(1,
                                            (fill[N - jb!1](FALSE) o
                                              right_shift(1, bv1!1) ^ (jb!1 - 1, 0))))" "1" "0") (("1" (assert) (("1" (lemma "bv_plus0[N]") (("1" (inst - "(left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, jb!1)) +
                                        left_shift(1,
                                                   (fill[N - jb!1](FALSE) o
                                                     right_shift(1, bv1!1) ^ (jb!1 - 1, 0))))" "0") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "bv_add_assoc") (("1" (rewrite "bv_add_const_assoc" :dir rl) (("1" (case-replace "left_shift(1,
                                                (fill[N - jb!1](FALSE) o
                                                  right_shift(1, bv1!1) ^ (jb!1 - 1, 0)))
                                     + 1 = (fill[N - 1 - jb!1](FALSE) o bv1!1 ^ (jb!1, 0))") (("1" (hide 2) (("1" (case "FORALL(b:bvec[N]) : NOT b(0) IMPLIES b + 1 =
                                                             (LAMBDA(i:below(N)) : (i=0) OR b(i))") (("1" (inst?) (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (case "bv2nat[N](b!1 + 1) = bv2nat[N](LAMBDA (i: below(N)): (i = 0) OR b!1(i))") (("1" (use "bv2nat_inj[N]") (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (case-replace "bv2nat[N](b!1 + 1) = bv2nat[N](b!1) + 1") (("1" (hide -1) (("1" (expand "bv2nat") (("1" (case "FORALL(n:below(N+1)) : n > 0 IMPLIES 1 + bv2nat_rec(n, b!1) =
                                                                      bv2nat_rec(n, LAMBDA (i: below(N)): (i = 0) OR b!1(i))") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (case-replace "jb!2=0") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "bv2nat_rec" +) (("2" (replace -2) (("2" (hide -2) (("2" (assert) (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "b!1+1") (("2" (typepred "mod(1 + bv2nat(b!1), exp2(N))") (("2" (expand "abs") (("2" (assert) (("2" (case "bv2nat(b!1) < exp2(N)-1") (("1" (assert) (("1" (expand "mod") (("1" (assert) (("1" (case-replace "floor((1 + bv2nat(b!1)) / exp2(N)) = 0") (("1" (assert) nil nil) ("2" (hide -2 -3 -4 2) (("2" (case "floor((1 + bv2nat(b!1)) / exp2(N)) < 1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "(1 + bv2nat(b!1)) / exp2(N) < 1") (("1" (typepred "floor((1 + bv2nat(b!1)) / exp2(N))") (("1" (assert) (("1" (name-replace "tmp" "floor((1 + bv2nat(b!1)) / exp2(N))") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "div_mult_pos_lt1") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (typepred "bv2nat(b!1)") (("2" (case "bv2nat(b!1) = exp2(N) - 1") (("1" (hide -2 1) (("1" (rewrite "bv2nat_eq_max") (("1" (expand "fill") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "leftshift1_add") (("2" (case-replace "left_shift(1,
                                          (fill[N - jb!1](FALSE) o
                                            right_shift(1, bv1!1) ^ (jb!1 - 1, 0))) =
                                      (fill[N - 1 - jb!1](FALSE) o bv1!1 ^ (jb!1, 0))") (("1" (hide 3) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) proved ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (right_shift const-decl "bvec[N]" bv_shift nil) (leftshift1_add formula-decl nil BitvectorUtil nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorMultiplication nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bv_add_assoc formula-decl nil bv_arith_nat nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_eq_max formula-decl nil bv_nat nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (integer nonempty-type-from-decl nil integers nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (bv2nat_rec def-decl "nat" bv_nat nil) (bv2nat_inj formula-decl nil bv_nat nil) (bv_add_const_assoc formula-decl nil bv_arith_nat nil) (left_shift const-decl "bvec[N]" bv_shift nil) (TRUE const-decl "bool" booleans nil) (above nonempty-type-eq-decl nil integers nil) (^ const-decl "bit" bv nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (b2n const-decl "nbit" bit nil) (bv2nat_lem_rule formula-decl nil bv_arith_nat_caret_rules nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (bv_add_two_consts formula-decl nil bv_arith_nat nil) (N_size formula-decl nil BitvectorMultiplication nil)) 16570 9340 nil nil)) (times_rec_max_inc_right 0 (times_rec_max_inc_right-1 nil 3249114872 3249231315 ("" (use "N_size") (("" (skosimp*) (("" (lemma "times_rec_inc_right") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (expand "o ") (("" (assert) (("" (case-replace "(LAMBDA (nm: below(0 + N)): (bv1!1 ^ (N - 1, 0))(nm)) = bv1!1") (("" (hide 2) (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (times_rec_inc_right formula-decl nil BitvectorMultiplication nil) (N_size formula-decl nil BitvectorMultiplication nil)) 1440 820 nil nil)) (times_rec_max_inc_n_right 0 (times_rec_max_inc_n_right-1 nil 3249114872 3249231316 ("" (induct "n") (("1" (skosimp*) (("1" (lemma "bv_plus0[N]") (("1" (inst -1 "bv2!1" "0") (("1" (replace -1) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" 1) (("2" (lemma "times_rec_max_inc_right") (("2" (inst - "bv1!1" "bv2!1+j!1") (("2" (rewrite "bv_add_2_consts") (("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (inst?) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((times_rec_max_inc_right formula-decl nil BitvectorMultiplication nil) (bv_add_2_consts formula-decl nil bv_arith_nat nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (iterate def-decl "T" function_iterate nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 1257 880 nil nil)) (times_rec_iterate 0 (times_rec_iterate-1 nil 3249114872 3249231320 ("" (skosimp*) (("" (lemma "bv2nat_elim[N]") (("" (inst - "fill[N](FALSE)" "bv2!1") (("" (lemma "bv_add_fill_F[N]") (("" (inst - "bv2!1") (("" (rewrite "bv_add_comm" -1) (("" (replace -1) (("" (hide -1) (("" (replace -1 * rl) (("" (hide -1) (("" (use "times_rec_max_inc_n_right") (("" (replace -1) (("" (hide -1) (("" (rewrite "times_rec_zero_right") (("" (case-replace "bv2nat(fill[N](FALSE) + bv2nat(bv2!1)) = bv2nat(bv2!1)") (("" (hide 2) (("" (lemma " bv_fill_F_plus[N]") (("" (inst?) (("" (expand "mod") (("" (case-replace "floor(bv2nat(bv2!1) / exp2(N)) = 0") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (typepred "floor(bv2nat(bv2!1) / exp2(N))") (("2" (name-replace "tmp" "floor(bv2nat(bv2!1) / exp2(N))") (("2" (typepred "bv2nat(bv2!1)") (("2" (assert) (("2" (case "bv2nat(bv2!1) / exp2(N) < 1") (("1" (assert) nil nil) ("2" (hide -2 -3 -4 2) (("2" (lemma "div_mult_pos_lt1") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (bv_add_comm formula-decl nil bv_arith_nat nil) (times_rec_zero_right formula-decl nil BitvectorMultiplication nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (bv_fill_F_plus formula-decl nil bv_arith_nat nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (times_rec_max_inc_n_right formula-decl nil BitvectorMultiplication nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 3857 1070 nil nil)) (bv2nat_iterate 0 (bv2nat_iterate-1 nil 3249114872 3249231323 ("" (induct "n") (("1" (skosimp*) (("1" (expand "iterate") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (assert) (("2" (rewrite "bv_add[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv_add formula-decl nil bv_arith_nat nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 2836 950 nil nil)) (bv2int_iterate_TCC1 0 (bv2int_iterate_TCC1-1 nil 3249114872 3249231323 ("" (subtype-tcc) nil nil) proved nil 232 30 nil nil)) (bv2int_iterate 0 (bv2int_iterate-1 nil 3249114872 3249231327 ("" (induct "n") (("1" (skosimp*) (("1" (expand "iterate") (("1" (rewrite "bv2int_fill_F[N]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (assert) (("2" (split -) (("1" (rewrite "bv2int_add[N]") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (expand "in_rng_2s_comp") (("2" (expand "minint") (("2" (expand "maxint") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(bv1!1) >= 0") (("1" (assert) (("1" (use "pos_times_ge") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "bv2int(bv1!1) >= 0") (("1" (assert) nil nil) ("2" (assert) (("2" (use "neg_times_ge") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (case "FORALL(k:posnat) : k-1>=0") (("1" (inst?) nil nil) ("2" (assert) nil nil)) nil)) nil) ("4" (case "FORALL(k:posnat) : k-1>=0") (("1" (inst?) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) proved ((in_rng_2s_comp const-decl "bool" bv_int nil) (bv2int_add formula-decl nil bv_arithmetic nil) (pos_times_ge formula-decl nil real_props nil) (neg_times_ge formula-decl nil real_props nil) (bv2int_fill_F formula-decl nil bv_int nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil)) 3749 1800 nil nil)) (iterate_inc 0 (iterate_inc-1 nil 3249114872 3249231330 ("" (induct "n") (("1" (skosimp*) (("1" (expand "iterate") (("1" (rewrite "bv_plus0[N]") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (replace -1) (("2" (hide -1) (("2" (name-replace "c" "iterate[bvec[N]](LAMBDA (b: bvec[N]): b + bv1!1, j!1)(fill[N](FALSE))") (("2" (use "bv_add_two_consts[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv_add_two_consts formula-decl nil bv_arith_nat nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 2758 1300 nil nil)) (iterate_inc_m 0 (iterate_inc_m-1 nil 3249114872 3249231336 ("" (induct "m") (("1" (assert) (("1" (skosimp*) (("1" (lemma "bv_plus0[N]") (("1" (inst-cp - "iterate[bvec[N]]
               (LAMBDA (b: bvec[N]): b + bv1!1, n!1)(fill[N](FALSE))" "0") (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "(LAMBDA (b: bvec[N]): b + (bv1!1 + 0)) = (LAMBDA (b: bvec[N]): b + bv1!1)") (("1" (hide 2) (("1" (decompose-equality 1) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (inst - "bv1!1 + 1" "n!1") (("2" (case-replace "(LAMBDA (b: bvec[N]): b + (bv1!1 + 1 + j!1)) =
     (LAMBDA (b: bvec[N]): b + (bv1!1 + (1 + j!1)))") (("1" (replace -2) (("1" (hide -1 -2) (("1" (rewrite "iterate_inc") (("1" (assert) (("1" (rewrite "bv_add_2_consts[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (rewrite "bv_add_2_consts[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((iterate_inc formula-decl nil BitvectorMultiplication nil) (bv_add_2_consts formula-decl nil bv_arith_nat nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (bv1!1 skolem-const-decl "bvec[N]" BitvectorMultiplication nil) (nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 5457 2550 nil nil)) (iterate_modulo 0 (iterate_modulo-1 nil 3249114872 3249231339 ("" (skosimp*) (("" (lemma "iterate_inc_m") (("" (inst - "bv2!1" "i!1 * exp2(N)" "bv2nat(-bv2!1)") (("" (lemma "bv_plus_wrap[N]") (("" (inst -1 "iterate[bvec[N]]
                       (LAMBDA (b: bvec[N]): b + bv2!1, i!1 * exp2(N))(fill[N](FALSE))" " i!1 * bv2nat(-bv2!1)") (("" (replace -1) (("" (replace -2 1 rl) (("" (hide -1 -2) (("" (rewrite "bv2nat_elim[N]") (("" (rewrite "plus_min_zero") (("" (case "FORALL(n:nat) : fill[N](FALSE) =
                                  iterate[bvec[N]]
                                      (LAMBDA (b: bvec[N]): b + fill[N](FALSE), n)
                                      (fill[N](FALSE))") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "iterate" 1) (("2" (rewrite "bv_add_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((iterate_inc_m formula-decl nil BitvectorMultiplication nil) (bv_plus_wrap formula-decl nil bv_arith_nat nil) (plus_min_zero formula-decl nil BitvectorUtil nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (iterate def-decl "T" function_iterate nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 3239 1460 nil nil)) (iterate_comm 0 (iterate_comm-1 nil 3249114872 3249231345 ("" (lemma "bvec_induction") (("" (inst -1 "LAMBDA(bv2:bvec[N]) : FORALL (bv1: bvec[N]):
              iterate[bvec[N]]
                  (LAMBDA (b: bvec[N]): b + bv1, bv2nat(bv2))(fill[N](FALSE))
               =
               iterate[bvec[N]]
                   (LAMBDA (b: bvec[N]): b + bv2, bv2nat(bv1))(fill[N](FALSE))") (("" (split -) (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (hide 2) (("2" (lemma "bvec_induction") (("2" (inst -1 "LAMBDA(bv1: bvec[N]):
                    iterate[bvec[N]]
                        (LAMBDA (b: bvec[N]): b + bv1, bv2nat(fill[N](FALSE)))
                        (fill[N](FALSE))
                     =
                     iterate[bvec[N]]
                         (LAMBDA (b: bvec[N]): b + fill[N](FALSE), bv2nat(bv1))
                         (fill[N](FALSE))") (("2" (split -) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (rewrite "bv2nat_fill_F[N]") (("2" (expand "iterate" 1 1) (("2" (expand "iterate" -1 1) (("2" (rewrite "bv_plus1[N]") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "iterate" +) (("2" (replace -1 * rl) (("2" (rewrite "bv_add_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (rewrite "bv_plus1[N]") (("3" (lift-if) (("3" (split) (("1" (flatten) (("1" (expand "iterate" 1 1) (("1" (replace -1) (("1" (lemma "iterate_inc") (("1" (inst - "bv!1" "bv2nat(bv1!1)") (("1" (replace -1) (("1" (hide -1) (("1" (inst - "bv1!1") (("1" (replace -2 * rl) (("1" (hide -2) (("1" (case-replace "iterate[bvec[N]]
                             (LAMBDA (b: bvec[N]): b + bv1!1, (exp2(N) - 1))(fill[N](FALSE))
                          + bv2nat(bv1!1) = iterate[bvec[N]]
                             (LAMBDA (b: bvec[N]): b + bv1!1, exp2(N))(fill[N](FALSE))") (("1" (hide -1 -2) (("1" (lemma "iterate_modulo") (("1" (inst -1 "bv1!1" "1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "iterate" 1 2) (("2" (rewrite "bv2nat_elim[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "iterate" 2 1) (("2" (inst -1 "bv1!1") (("2" (replace -1) (("2" (hide -1) (("2" (lemma "iterate_inc") (("2" (inst - "bv!1" "bv2nat(bv1!1)") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "bv2nat_elim[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (iterate def-decl "T" function_iterate nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (iterate_inc formula-decl nil BitvectorMultiplication nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (iterate_modulo formula-decl nil BitvectorMultiplication nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (bv_plus1 formula-decl nil bv_arith_nat nil) (bvec_induction formula-decl nil BitvectorUtil nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil)) 5537 2470 nil nil)) (times_rec_comm 0 (times_rec_comm-1 nil 3249114872 3249231345 ("" (skosimp*) (("" (rewrite "times_rec_iterate") (("" (rewrite "times_rec_iterate") (("" (rewrite "iterate_comm") nil nil)) nil)) nil)) nil) proved ((times_rec_iterate formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (iterate_comm formula-decl nil BitvectorMultiplication nil)) 463 160 nil nil)) (times_comm 0 (times_comm-1 nil 3249114872 3249231346 ("" (skosimp*) (("" (expand "*") (("" (reduce) (("" (rewrite "times_rec_comm") nil nil)) nil)) nil)) nil) proved ((* const-decl "bvec[N]" BitvectorMultiplication nil) (times_rec_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil)) 37 40 nil nil)) (iterate_min_second 0 (iterate_min_second-1 nil 3249114872 3249231348 ("" (induct "n") (("1" (skosimp*) (("1" (expand "iterate") (("1" (rewrite "min_fill_F") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "bv_neg_distribution") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv_neg_distribution formula-decl nil bv_arith_minus_rules nil) (min_fill_F formula-decl nil BitvectorUtil nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 1931 960 nil nil)) (times_rec_min_first 0 (times_rec_min_first-1 nil 3249114872 3249231348 ("" (skosimp*) (("" (rewrite "times_rec_iterate") (("" (rewrite "times_rec_iterate") (("" (use "iterate_min_second") nil nil)) nil)) nil)) nil) proved ((times_rec_iterate formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate_min_second formula-decl nil BitvectorMultiplication nil)) 384 190 nil nil)) (times_rec_min_second 0 (times_rec_min_second-1 nil 3249114872 3249231349 ("" (skosimp*) (("" (rewrite "times_rec_comm") (("" (rewrite "times_rec_min_first") (("" (rewrite "times_rec_comm") nil nil)) nil)) nil)) nil) proved ((times_rec_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (times_rec_min_first formula-decl nil BitvectorMultiplication nil)) 222 60 nil nil)) (times_min_first 0 (times_min_first-1 nil 3249114872 3249231349 ("" (skosimp*) (("" (expand "*") (("" (rewrite "times_rec_min_first") nil nil)) nil)) nil) proved ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_min_first formula-decl nil BitvectorMultiplication nil)) 34 30 nil nil)) (times_min_second 0 (times_min_second-1 nil 3249114872 3249231349 ("" (skosimp*) (("" (rewrite "times_comm") (("" (rewrite "times_min_first") (("" (rewrite "times_comm") nil nil)) nil)) nil)) nil) proved ((times_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (times_min_first formula-decl nil BitvectorMultiplication nil)) 235 60 nil nil)) (bv2nat_one 0 (bv2nat_one-1 nil 3249114872 3249231350 ("" (use "N_size") (("" (lemma "bv2nat_lem_rule") (("" (inst?) (("1" (expand "b2n") (("1" (expand "^") (("1" (assert) (("1" (expand "one" -1 1) (("1" (expand "one" -1 1) (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) proved ((bv2nat_lem_rule formula-decl nil bv_arith_nat_caret_rules nil) (b2n const-decl "nbit" bit nil) (fill const-decl "bit" bv nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (N_size formula-decl nil BitvectorMultiplication nil)) 1348 620 nil nil)) (bv2int_one 0 (bv2int_one-1 nil 3249114872 3249231351 ("" (auto-rewrite "bv2nat_one") (("" (expand "bv2int") (("" (reduce) (("" (typepred "exp2(N - 1)") (("" (use "N_size") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int const-decl "rng_2s_comp" bv_int nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (N_size formula-decl nil BitvectorMultiplication nil) (bv2nat_one formula-decl nil BitvectorMultiplication nil)) 329 170 nil nil)) (times_one_first 0 (times_one_first-1 nil 3249114872 3249231353 ("" (use "N_size") (("" (skosimp*) (("" (expand "*") (("" (expand "one") (("" (assert) (("" (expand "times_rec") (("" (case-replace "left_shift(1,
                    times_rec(right_shift(1, (LAMBDA (k: below(N)): k = 0)),
                              bv!1, N - 1)) = fill[N](FALSE)") (("1" (rewrite "bv_add_fill_F[N]") nil nil) ("2" (hide -1 2) (("2" (case-replace "right_shift(1, (LAMBDA (k: below(N)): k = 0)) = fill[N](FALSE)") (("1" (hide -1) (("1" (rewrite "times_rec_zero_left") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((one const-decl "bvec[N]" BitvectorMultiplication nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (times_rec_zero_left formula-decl nil BitvectorMultiplication nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (right_shift const-decl "bvec[N]" bv_shift nil) (left_shift const-decl "bvec[N]" bv_shift nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (N_size formula-decl nil BitvectorMultiplication nil)) 2638 1230 nil nil)) (times_one_second 0 (times_one_second-1 nil 3249114872 3249231353 ("" (skosimp*) (("" (rewrite "times_comm") (("" (rewrite "times_one_first") nil nil)) nil)) nil) proved ((times_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (times_one_first formula-decl nil BitvectorMultiplication nil)) 24 30 nil nil)) (iterate_zero_add 0 (iterate_zero_add-1 nil 3249114872 3249231357 ("" (induct "n") (("1" (skosimp*) (("1" (expand "iterate") (("1" (rewrite "bv_add_comm") (("1" (rewrite "bv_add_fill_F[N]") nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "bv_add_assoc" :dir rl) (("2" (rewrite "bv_add_assoc" :dir rl) (("2" (rewrite "bv_add_comm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv_add_assoc formula-decl nil bv_arith_nat nil) (bv_add_comm formula-decl nil bv_arith_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 3019 1460 nil nil)) (times_rec_distr 0 (times_rec_distr-1 nil 3249114872 3249231360 ("" (skosimp*) (("" (rewrite "times_rec_iterate") (("" (rewrite "times_rec_iterate") (("" (rewrite "times_rec_iterate") (("" (rewrite "bv_add[N]") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (lemma "iterate_add[bvec[N]]") (("1" (inst?) (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (expand "o") (("1" (lemma "iterate_zero_add") (("1" (inst - "bv1!1" "(iterate(LAMBDA (b: bvec[N]): b + bv1!1, bv2nat(bv3!1))
                         (fill[N](FALSE)))" "bv2nat(bv2!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "iterate_add[bvec[N]]") (("2" (inst-cp -1 "LAMBDA (b: bvec[N]): b + bv1!1" "bv2nat(bv2!1) + bv2nat(bv3!1) - exp2(N)" "exp2(N)") (("1" (assert) (("1" (decompose-equality -2) (("1" (expand "o" -1) (("1" (inst - "fill[N](FALSE)") (("1" (lemma "iterate_modulo") (("1" (inst -1 "bv1!1" "1") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (inst?) (("1" (replace -1 2 rl) (("1" (hide -1) (("1" (expand "o") (("1" (lemma "iterate_zero_add") (("1" (inst - "bv1!1" "(iterate(LAMBDA (b: bvec[N]): b + bv1!1, bv2nat(bv3!1))
                                 (fill[N](FALSE)))" "bv2nat(bv2!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((times_rec_iterate formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (bv2!1 skolem-const-decl "bvec[N]" BitvectorMultiplication nil) (bv3!1 skolem-const-decl "bvec[N]" BitvectorMultiplication nil) (iterate_modulo formula-decl nil BitvectorMultiplication nil) (iterate_zero_add formula-decl nil BitvectorMultiplication nil) (iterate def-decl "T" function_iterate nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (O const-decl "T3" function_props nil) (iterate_add formula-decl nil function_iterate nil) (bv_add formula-decl nil bv_arith_nat nil)) 2739 1230 nil nil)) (times_distr_right 0 (times_distr_right-1 nil 3249114872 3249231360 ("" (skosimp*) (("" (expand "*") (("" (rewrite "times_rec_distr") nil nil)) nil)) nil) proved ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_distr formula-decl nil BitvectorMultiplication nil)) 307 150 nil nil)) (times_distr_left 0 (times_distr_left-1 nil 3249114872 3249231361 ("" (skosimp*) (("" (rewrite "times_comm") (("" (rewrite "times_distr_right") (("" (rewrite "times_comm") (("" (case-replace "(bv3!1 * bv2!1) = (bv2!1 * bv3!1)") (("" (rewrite "times_comm") nil nil)) nil)) nil)) nil)) nil)) nil) proved ((times_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (times_distr_right formula-decl nil BitvectorMultiplication nil)) 407 250 nil nil)) (times_distr_iterate 0 (times_distr_iterate-1 nil 3249114872 3249231362 ("" (induct "n") (("1" (skosimp*) (("1" (expand "iterate") (("1" (rewrite "times_zero_second") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (rewrite "times_distr_right") (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((times_distr_right formula-decl nil BitvectorMultiplication nil) (times_zero_second formula-decl nil BitvectorMultiplication nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 1140 510 nil nil)) (times_assoc 0 (times_assoc-1 nil 3249114872 3249231363 ("" (skosimp*) (("" (expand "*" 1 4) (("" (rewrite "times_rec_iterate") (("" (rewrite "times_distr_iterate") (("" (expand "*" 1 2) (("" (rewrite "times_rec_iterate") nil nil)) nil)) nil)) nil)) nil)) nil) proved ((* const-decl "bvec[N]" BitvectorMultiplication nil) (times_distr_iterate formula-decl nil BitvectorMultiplication nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_iterate formula-decl nil BitvectorMultiplication nil)) 359 150 t nil)))(BitvectorMultiplicationWidenNarrow (IMP_BitvectorMultiplication_TCC1 0 (IMP_BitvectorMultiplication_TCC1-1 nil 3249114873 3249231363 ("" (use "N_size") nil nil) proved ((N_size formula-decl nil BitvectorMultiplicationWidenNarrow nil)) 6 10 nil nil)) (IMP_BitvectorMultiplication_TCC2 0 (IMP_BitvectorMultiplication_TCC2-1 nil 3249114873 3249231363 ("" (assuming-tcc) nil nil) proved nil 228 80 nil nil)) (bv2nat_narrow 0 (bv2nat_narrow-1 nil 3249114873 3249231367 ("" (skosimp*) (("" (case "BV!1 = (fill[N](FALSE) o narrow(BV!1))") (("1" (case "bv2nat(BV!1) = bv2nat(fill[N](FALSE) o narrow(BV!1))") (("1" (replace -1 1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "bv2nat_upperbound[2*N]") (("2" (inst?) (("1" (assert) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil) ("2" (use "N_size") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((narrow const-decl "bvec[N]" BitvectorUtil nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (N_size formula-decl nil BitvectorMultiplicationWidenNarrow nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil)) 3807 1850 nil nil)) (bv2nat_times_rec 0 (bv2nat_times_rec-1 nil 3249114873 3249231369 ("" (skosimp*) (("" (lemma "bv2nat_iterate[2*N]") (("" (inst - "BV1!1" "bv2nat(BV2!1)") (("" (split -) (("1" (rewrite "times_rec_iterate") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "exp2_sum") (("2" (inst - "N" "N") (("2" (assert) (("2" (replace -1) (("2" (lemma " lt_times_lt_pos1") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_iterate formula-decl nil BitvectorMultiplication nil) (times_rec_iterate formula-decl nil BitvectorMultiplication nil) (exp2_sum formula-decl nil exp2 nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 1845 870 nil nil)) (bv2nat_times 0 (bv2nat_times-1 nil 3249114873 3249231370 ("" (skosimp*) (("" (expand "*") (("" (rewrite "times_rec_iterate") (("" (rewrite "bv2nat_iterate[2*N]") (("" (assert) nil nil)) nil)) nil)) nil)) nil) proved ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bv2nat_iterate formula-decl nil BitvectorMultiplication nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (times_rec_iterate formula-decl nil BitvectorMultiplication nil)) 1492 680 nil nil)) (bv2int_times_TCC1 0 (bv2int_times_TCC1-1 nil 3249114873 3249231370 ("" (subtype-tcc) nil nil) proved nil 235 80 nil nil)) (bv2int_times 0 (bv2int_times-1 nil 3249114873 3249231375 ("" (use "N_size") (("" (skosimp*) (("" (case "bv2int(BV2!1) = IF bv2nat(BV2!1) < exp2(2 * N - 1)
                                                                          THEN bv2nat(BV2!1)
                                                                        ELSE bv2nat(BV2!1) - exp2(2 * N)
                                                                        ENDIF") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (replace -2) (("1" (expand "*") (("1" (rewrite "times_rec_iterate") (("1" (rewrite "bv2int_iterate[2*N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "bv2int_iterate[2*N]") (("2" (inst - "BV1!1" "exp2(2 * N) - bv2nat(BV2!1)") (("1" (assert) (("1" (lemma "times_min_second[2*N]") (("1" (inst?) (("1" (lemma "bv_double_neg[2*N]") (("1" (inst -1 "(BV1!1 * BV2!1)") (("1" (replace -1 2 rl) (("1" (replace -2 2 rl) (("1" (hide -1 -2) (("1" (rewrite "bv2int_neg") (("1" (assert) (("1" (expand "minint") (("1" (expand "*") (("1" (rewrite "times_rec_iterate") (("1" (rewrite "bv2nat_minus_bv[2*N]") (("1" (replace -1) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bv2int") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) proved ((BV2!1 skolem-const-decl "bvec[2 * N]" BitvectorMultiplicationWidenNarrow nil) (times_min_second formula-decl nil BitvectorMultiplication nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (bv2int_iterate formula-decl nil BitvectorMultiplication nil) (times_rec_iterate formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (N_size formula-decl nil BitvectorMultiplicationWidenNarrow nil)) 4915 2330 nil nil)) (bv2int_times_widens 0 (bv2int_times_widens-1 nil 3249114873 3249231380 ("" (skosimp*) (("" (lemma "bv2int_times") (("" (inst?) (("" (assert) (("" (rewrite "bv2int_widen") (("" (rewrite "bv2int_widen") (("" (assert) (("" (hide 2) (("" (typepred "bv2int[N](bv1!1)") (("" (typepred "bv2int[N](bv2!1)") (("" (expand "minint") (("" (expand "maxint") (("" (assert) (("" (lemma "exp2_sum") (("" (inst - "N-1" "N-1") (("" (assert) (("" (expand "exp2" 1) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (case-replace "bv2int[N](bv1!1)=0") (("1" (assert) nil nil) ("2" (case-replace "bv2int[N](bv2!1)=0") (("1" (assert) nil nil) ("2" (case "bv2int(bv1!1) > 0") (("1" (case "bv2int(bv2!1) > 0") (("1" (lemma "lt_times_lt_pos1") (("1" (inst - "bv2int(bv1!1)" "bv2int(bv2!1)" "exp2(N - 1)" "exp2(N - 1)") (("1" (assert) (("1" (lemma "pos_times_lt") (("1" (inst - "bv2int(bv1!1)" "bv2int(bv2!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (lemma "neg_times_lt") (("2" (inst - "bv2int(bv1!1)" "bv2int(bv2!1)") (("2" (assert) (("2" (lemma "lt_times_lt_neg1") (("2" (inst - "bv2int[N](bv2!1)" "-bv2int[N](bv1!1)" "-exp2(N - 1)" "-exp2(N - 1)") (("2" (assert) (("2" (case-replace "bv2int[N](bv2!1) = -exp2(N - 1)") (("1" (lemma "lt_times_lt_neg1") (("1" (inst - "-bv2int[N](bv1!1)" "-exp2(N - 1)" "-exp2(N - 1)" "-exp2(N - 1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int(bv2!1) > 0") (("1" (lemma "neg_times_lt") (("1" (inst - "bv2int[N](bv2!1)" "bv2int[N](bv1!1)") (("1" (assert) (("1" (lemma "lt_times_lt_neg1") (("1" (inst - "-bv2int[N](bv2!1)" "bv2int[N](bv1!1)" "-exp2(N - 1)" "-exp2(N - 1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int[N](bv1!1) * bv2int(bv2!1) > 0") (("1" (assert) (("1" (lemma "lt_times_lt_neg1") (("1" (inst - "bv2int[N](bv1!1)" "bv2int[N](bv2!1)" "-exp2(N - 1)" "-exp2(N - 1)") (("1" (assert) (("1" (case-replace "bv2int[N](bv1!1) = -exp2(N - 1)") (("1" (lemma "lt_times_lt_neg1") (("1" (inst - "bv2int[N](bv2!1)" "bv2int[N](bv1!1)" "-exp2(N - 1)" "-exp2(N - 1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "pos_times_lt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (exp2_sum formula-decl nil exp2 nil) (bv1!1 skolem-const-decl "bvec[N]" BitvectorMultiplicationWidenNarrow nil) (bv2!1 skolem-const-decl "bvec[N]" BitvectorMultiplicationWidenNarrow nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pos_times_lt formula-decl nil real_props nil) (lt_times_lt_pos1 formula-decl nil real_props nil) (lt_times_lt_neg1 formula-decl nil real_props nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (neg_times_lt formula-decl nil real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (bv2int_widen formula-decl nil BitvectorUtil nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 4744 2110 nil nil)) (bv2int_times_int2bv_first_TCC1 0 (bv2int_times_int2bv_first_TCC1-1 nil 3249114873 3249231381 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil)) 942 450 nil nil)) (bv2int_times_int2bv_first 0 (bv2int_times_int2bv_first-1 nil 3249114873 3249231382 ("" (skosimp*) (("" (lemma "bv2int_times") (("" (inst?) (("1" (assert) nil nil) ("2" (expand "minint") (("2" (expand "maxint") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (int2bv const-decl "{bv | bv2int(bv) = iv}" bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (= const-decl "[T, T -> boolean]" equalities nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (minint const-decl "int" bv_int nil) (k!1 skolem-const-decl "int" BitvectorMultiplicationWidenNarrow nil) (maxint const-decl "int" bv_int nil)) 954 490 nil nil)) (bv2int_times_int2bv_second 0 (bv2int_times_int2bv_second-1 nil 3249114873 3249231383 ("" (skosimp*) (("" (lemma "bv2int_times") (("" (inst?) (("1" (assert) nil nil) ("2" (expand "minint") (("2" (expand "maxint") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (int2bv const-decl "{bv | bv2int(bv) = iv}" bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (= const-decl "[T, T -> boolean]" equalities nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (minint const-decl "int" bv_int nil) (k!1 skolem-const-decl "int" BitvectorMultiplicationWidenNarrow nil) (maxint const-decl "int" bv_int nil)) 500 500 nil nil)) (narrow_iterate 0 (narrow_iterate-1 nil 3249114873 3249231384 ("" (induct "n") (("1" (skosimp*) (("1" (expand "iterate") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (rewrite "narrow_plus") (("2" (inst?) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((narrow_plus formula-decl nil BitvectorUtil nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) 1427 1380 nil nil)) (bv2nat_split_TCC1 0 (bv2nat_split_TCC1-1 nil 3249114873 3249231385 ("" (subtype-tcc) nil nil) proved nil 105 80 nil nil)) (bv2nat_split_TCC2 0 (bv2nat_split_TCC2-1 nil 3249114873 3249231385 ("" (subtype-tcc) nil nil) proved nil 83 80 nil nil)) (bv2nat_split_TCC3 0 (bv2nat_split_TCC3-1 nil 3249114873 3249231385 ("" (subtype-tcc) nil nil) proved nil 93 80 nil nil)) (bv2nat_split_TCC4 0 (bv2nat_split_TCC4-1 nil 3249114873 3249231385 ("" (subtype-tcc) nil nil) proved nil 33 30 nil nil)) (bv2nat_split 0 (bv2nat_split-1 nil 3249114873 3249231389 ("" (skosimp*) (("" (expand "bv2nat") (("" (case "FORALL(n:nat) : n <= 2*N IMPLIES bv2nat_rec(n, BV!1) =
                     exp2(N) * (IF n >= N THEN bv2nat_rec(n-N, BV!1 ^ (2*N - 1, N)) ELSE 0 ENDIF) +
                      bv2nat_rec(IF n<N THEN n ELSE N ENDIF, BV!1 ^ (N - 1, 0))") (("1" (inst -1 "2*N") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (case "1 + j!1 < N") (("1" (assert) (("1" (expand "bv2nat_rec" 1) (("1" (replace*) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case-replace "j!1 = N-1") (("1" (assert) (("1" (expand "bv2nat_rec" +) (("1" (replace*) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "bv2nat_rec" 3 3) (("2" (expand "bv2nat_rec" 3 1) (("2" (assert) (("2" (replace*) (("2" (hide -1) (("2" (case-replace "exp2(j!1) * b2n(BV!1 ^ j!1) = b2n(BV!1 ^ (2 * N - 1, N) ^ (j!1 - N)) * exp2(j!1 - N) * exp2(N)") (("2" (hide 4) (("2" (expand "b2n") (("2" (expand "^") (("2" (lemma "exp2_sum") (("2" (inst - "N" "j!1-N") (("2" (assert) (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reduce) nil nil) ("4" (reduce) nil nil) ("5" (reduce) nil nil) ("6" (reduce) nil nil) ("7" (reduce) nil nil) ("8" (reduce) nil nil)) nil)) nil) ("3" (reduce) nil nil) ("4" (reduce) nil nil) ("5" (reduce) nil nil) ("6" (reduce) nil nil) ("7" (reduce) nil nil) ("8" (reduce) nil nil)) nil)) nil)) nil) proved ((bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2_sum formula-decl nil exp2 nil) (nbit type-eq-decl nil bit nil) (below type-eq-decl nil nat_types nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (= const-decl "[T, T -> boolean]" equalities nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_rec def-decl "nat" bv_nat nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil)) 4139 4000 nil nil)) (narrow_times 0 (narrow_times-1 nil 3249114873 3249231390 ("" (use "N_size") (("" (skosimp*) (("" (expand "*") (("" (rewrite "times_rec_iterate[N]") (("" (rewrite "times_rec_iterate[2*N]") (("" (rewrite "narrow_iterate") (("" (rewrite "bv2nat_split") (("" (lemma "iterate_add[bvec[N]]") (("" (inst?) (("" (replace -1 1 rl) (("" (hide -1) (("" (expand "o") (("" (lemma "iterate_modulo[N]") (("" (inst - "narrow(BV1!1)" "bv2nat(BV2!1 ^ (2 * N - 1, N))") (("" (replace -1) (("" (hide -1) (("" (expand "narrow") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((times_rec_iterate formula-decl nil BitvectorMultiplication nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (narrow_iterate formula-decl nil BitvectorMultiplicationWidenNarrow nil) (iterate_add formula-decl nil function_iterate nil) (O const-decl "T3" function_props nil) (iterate_modulo formula-decl nil BitvectorMultiplication nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat_split formula-decl nil BitvectorMultiplicationWidenNarrow nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (N_size formula-decl nil BitvectorMultiplicationWidenNarrow nil)) 1062 1040 nil nil)) (times_is_java_times 0 (times_is_java_times-1 nil 3249114873 3249231390 ("" (skosimp*) (("" (rewrite "narrow_times") (("" (rewrite "narrow_widen") (("" (rewrite "narrow_widen") nil nil)) nil)) nil)) nil) proved ((narrow_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplicationWidenNarrow nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (narrow_widen formula-decl nil BitvectorUtil nil)) 58 60 nil nil)))(DivisionUtil (leftshift_with_TCC1 0 (leftshift_with_TCC1-1 nil 3249114873 3249231390 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 66 60 nil nil)) (leftshift_with_TCC2 0 (leftshift_with_TCC2-1 nil 3249114873 3249231390 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 135 130 nil nil)) (leftshift_with 0 (leftshift_with-1 nil 3249114873 3249231393 ("" (skosimp*) (("" (lemma "bv2nat_upperbound[n!1]") (("1" (inst - "bv!1" "n!1-1") (("1" (assert) (("1" (inst - "n!1-1") (("1" (assert) (("1" (hide -2) (("1" (rewrite "bv2nat_as_sum[n!1]") (("1" (rewrite "bv2nat_as_sum[n!1]") (("1" (expand "sigma" 2 2) (("1" (assert) (("1" (expand "extend" 2 2) (("1" (expand "b2n" 2 4) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - 0) (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "exp2" -1 3) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_shift") (("1" (inst -1 "extend(LAMBDA (ii: below(n!1)):
                                exp2(ii) *
                                 b2n(left_shift(1, bv!1) WITH [(0) := b!1](ii)))" "n!1-2" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_mult") (("1" (inst?) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                     extend(LAMBDA (ii: below(n!1)):
                              exp2(ii) *
                               b2n(left_shift(1, bv!1) WITH [(0) := b!1](ii)))
                           (1 + n)" "LAMBDA (n:nat):
                      2 *
                       extend(LAMBDA (ii: below(n!1)): exp2(ii) * b2n(bv!1(ii)))
                             (n)" "n!1-2" "0") (("1" (assert) (("1" (hide 3) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) proved ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (sigma def-decl "nat" sums nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma_split formula-decl nil sums nil) (sigma_shift formula-decl nil sums nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (nbit type-eq-decl nil bit nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (b2n const-decl "nbit" bit nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (n!1 skolem-const-decl "nat" DivisionUtil nil)) 2940 2840 nil nil)) (bv2nat_minus 0 (bv2nat_minus-1 nil 3249114873 3249231394 ("" (skosimp*) (("" (expand "-") (("" (rewrite "bv_add[n!1]") (("" (rewrite "bv2nat_minus_bv[n!1]") (("" (reduce) nil nil)) nil)) nil)) nil)) nil) proved ((- const-decl "bvec[N]" bv_arithmetic nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv_add formula-decl nil bv_arith_nat nil)) 692 690 nil nil)))(BitvectorOneComplementDivision (IMP_BitvectorMultiplication_TCC1 0 (IMP_BitvectorMultiplication_TCC1-1 nil 3249114881 3249231394 ("" (use "N_size") nil nil) proved ((N_size formula-decl nil BitvectorOneComplementDivision nil)) 28 10 nil nil)) (divrem_TCC1 0 (divrem_TCC1-1 nil 3249114881 3249231394 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 43 50 nil nil)) (divrem_TCC2 0 (divrem_TCC2-1 nil 3249114881 3249231394 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 68 70 nil nil)) (divrem_TCC3 0 (divrem_TCC3-1 nil 3249114881 3249231395 ("" (subtype-tcc) nil nil) proved ((nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 308 300 nil nil)) (divrem_TCC4 0 (divrem_TCC4-1 nil 3249114881 3249231395 ("" (termination-tcc) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 245 250 nil nil)) (divrem_TCC5 0 (divrem_TCC5-1 nil 3249114881 3249231395 ("" (subtype-tcc) nil nil) proved ((nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 308 300 nil nil)) (divrem_TCC6 0 (divrem_TCC6-1 nil 3249114881 3249231395 ("" (termination-tcc) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 273 250 nil nil)) (divrem_dvd_TCC1 0 (divrem_dvd_TCC1-1 nil 3249114881 3249231395 ("" (subtype-tcc) nil nil) proved nil 30 40 nil nil)) (divrem_dvd_TCC2 0 (divrem_dvd_TCC2-1 nil 3249114881 3249231395 ("" (subtype-tcc) nil nil) proved nil 23 20 nil nil)) (divrem_dvd 0 (divrem_dvd-1 nil 3249114881 3249231397 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "divrem" +) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (inst?) (("1" (replace*) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "k!1") (("2" (inst?) (("2" (replace*) (("2" (hide-all-but 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (left_shift const-decl "bvec[N]" bv_shift nil) (TRUE const-decl "bool" booleans nil) (- const-decl "bvec[N]" bv_arithmetic nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 1593 1530 nil nil)) (divrem_dvs0_TCC1 0 (divrem_dvs0_TCC1-1 nil 3249114881 3249231397 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) 186 180 nil nil)) (divrem_dvs0_TCC2 0 (divrem_dvs0_TCC2-1 nil 3249114881 3249231398 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) 324 320 nil nil)) (divrem_dvs0 0 (divrem_dvs0-1 nil 3249114881 3249231407 ("" (use "N_size") (("" (induct "n") (("1" (grind) (("1" (apply-extensionality :hide? t) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (skosimp*) (("2" (expand "divrem" +) (("2" (rewrite "bv2nat_fill_F[N]") (("2" (assert) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (replace*) (("1" (hide -) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (expand "-") (("2" (rewrite " bv_sub_identity_R") (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) proved ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (TRUE const-decl "bool" booleans nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (bv_sub_identity_R formula-decl nil bv_arith_minus_rules nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (left_shift const-decl "bvec[N]" bv_shift nil) (- const-decl "bvec[N]" bv_arithmetic nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 9304 5550 nil nil)) (bv2nat_left_false_inc 0 (bv2nat_left_false_inc-1 nil 3249114881 3249231415 ("" (use "N_size") (("" (skosimp*) (("" (case-replace "n!1=0") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (lemma " bv2nat_lem") (("1" (inst - "N" "(LAMBDA (i: below(N)): IF i < 1 THEN bv!1(i) ELSE FALSE ENDIF)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (expand "^") (("1" (expand "exp2") (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                          exp2(ii) *
                           IF ii < n!1
                             THEN b2n(bv!1(ii))
                           ELSE b2n(FALSE)
                           ENDIF)" "N-1" "0" "n!1-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case-replace "sigma(n!1, N - 1,
                    extend(LAMBDA (ii: below(N)):
                             exp2(ii) *
                              IF ii < n!1
                                THEN b2n(bv!1(ii))
                              ELSE b2n(FALSE)
                              ENDIF)) = 0") (("1" (hide -1) (("1" (case-replace "n!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                               exp2(ii) *
                                IF ii < 1 + n!1
                                  THEN b2n(bv!1(ii))
                                ELSE b2n(FALSE)
                                ENDIF)" "N-1" "0" "n!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (case-replace "sigma(1 + n!1, N - 1,
                       extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < 1 + n!1
                                   THEN b2n(bv!1(ii))
                                 ELSE b2n(FALSE)
                                 ENDIF)) = 0") (("1" (hide -1) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n:nat):
                          0 *
                           extend(LAMBDA (ii: below(N)):
                                    exp2(ii) *
                                     IF ii < 1 + n!1
                                       THEN b2n(bv!1(ii))
                                     ELSE b2n(FALSE)
                                     ENDIF)
                                 (n)" "extend(LAMBDA (ii: below(N)):
                                 exp2(ii) *
                                  IF ii < 1 + n!1
                                    THEN b2n(bv!1(ii))
                                  ELSE b2n(FALSE)
                                  ENDIF)" "N-1" "1+n!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n:nat) :
                      0 *
                       extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < n!1
                                   THEN b2n(bv!1(ii))
                                 ELSE b2n(FALSE)
                                 ENDIF)
                             (n)" "extend(LAMBDA (ii: below(N)):
                             exp2(ii) *
                              IF ii < n!1
                                THEN b2n(bv!1(ii))
                              ELSE b2n(FALSE)
                              ENDIF)" "N-1" "n!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2nat_as_sum formula-decl nil bv_sum nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_split formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (fill const-decl "bit" bv nil) (above nonempty-type-eq-decl nil integers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (FALSE const-decl "bool" booleans nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 7719 4970 nil nil)) (bv2nat_right_false_inc 0 (bv2nat_right_false_inc-1 nil 3249114881 3249231430 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "bv2nat_as_sum[N]") (("" (rewrite "bv2nat_as_sum[N]") (("" (case-replace "n!1=0") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                         exp2(ii) *
                          IF ii < n!1
                            THEN b2n(FALSE)
                          ELSE b2n(bv!1(ii))
                          ENDIF)" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                          exp2(ii) *
                           IF ii < 1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "b2n" -1 5) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                         exp2(ii) *
                          IF ii < n!1
                            THEN b2n(FALSE)
                          ELSE b2n(bv!1(ii))
                          ENDIF)" "N-1" "0" "n!1-1") (("1" (assert) (("1" (case-replace "sigma(0, n!1 - 1,
                   extend(LAMBDA (ii: below(N)):
                            exp2(ii) *
                             IF ii < n!1
                               THEN b2n(FALSE)
                             ELSE b2n(bv!1(ii))
                             ENDIF)) = 0") (("1" (replace*) (("1" (hide -1 -2) (("1" (assert) (("1" (case-replace "n!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (lemma "sigma_mult") (("1" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                        0 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))" "N-1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < 1 + n!1
                                   THEN b2n(FALSE)
                                 ELSE b2n(bv!1(ii))
                                 ENDIF)" "N-1" "0" "n!1") (("2" (assert) (("2" (case-replace "sigma(0, n!1,
                       extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < 1 + n!1
                                   THEN b2n(FALSE)
                                 ELSE b2n(bv!1(ii))
                                 ENDIF)) = 0") (("1" (replace*) (("1" (hide -1 -2) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                 exp2(ii) *
                                  IF ii < n!1
                                    THEN b2n(FALSE)
                                  ELSE b2n(bv!1(ii))
                                  ENDIF)" "N-1" "n!1" "n!1") (("1" (assert) (("1" (expand "sigma" -1 3) (("1" (expand "extend" -1 2) (("1" (replace -1) (("1" (assert) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat):
                          0 *
                           extend(LAMBDA (ii: below(N)):
                                    exp2(ii) *
                                     IF ii < 1 + n!1
                                       THEN b2n(FALSE)
                                     ELSE b2n(bv!1(ii))
                                     ENDIF)
                                 (n)" "extend(LAMBDA (ii: below(N)):
                                 exp2(ii) *
                                  IF ii < 1 + n!1
                                    THEN b2n(FALSE)
                                  ELSE b2n(bv!1(ii))
                                  ENDIF)" "n!1" "0") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n:nat):
                      0 *
                       extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < n!1
                                   THEN b2n(FALSE)
                                 ELSE b2n(bv!1(ii))
                                 ENDIF)
                             (n)" "extend(LAMBDA (ii: below(N)):
                             exp2(ii) *
                              IF ii < n!1
                                THEN b2n(FALSE)
                              ELSE b2n(bv!1(ii))
                              ENDIF)" "n!1-1" "0") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_mult formula-decl nil sums nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (extend const-decl "[nat -> nat]" bv_sum nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "nat" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_split formula-decl nil sums nil) (= const-decl "[T, T -> boolean]" equalities nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FALSE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 15446 5830 nil nil)) (bv2nat_left_false_dec_TCC1 0 (bv2nat_left_false_dec_TCC1-1 nil 3249114881 3249231431 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 564 240 nil nil)) (bv2nat_left_false_dec_TCC2 0 (bv2nat_left_false_dec_TCC2-1 nil 3249114881 3249231432 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 809 260 nil nil)) (bv2nat_left_false_dec_TCC3 0 (bv2nat_left_false_dec_TCC3-1 nil 3249114881 3249231432 ("" (subtype-tcc) nil nil) proved nil 51 50 nil nil)) (bv2nat_left_false_dec_TCC4 0 (bv2nat_left_false_dec_TCC4-1 nil 3249114881 3249231432 ("" (subtype-tcc) nil nil) proved nil 224 20 nil nil)) (bv2nat_left_false_dec 0 (bv2nat_left_false_dec-1 nil 3249114881 3249231452 ("" (use "N_size") (("" (skosimp*) (("" (case-replace "n!1=N-1") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (lemma " bv2nat_lem") (("1" (inst - "N" "(LAMBDA (i: below(N)): IF i < 1 THEN bv!1(i-1+N) ELSE FALSE ENDIF)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (expand "^") (("1" (expand "exp2") (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (case-replace "n!1=0") (("1" (assert) (("1" (expand "sigma") (("1" (expand "extend" 2 1) (("1" (expand "extend" 2 2) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < N - 1
                                   THEN b2n(bv!1(ii))
                                 ELSE b2n(FALSE)
                                 ENDIF)" "N-2" "0") (("1" (split -) (("1" (replace -1) (("1" (expand "b2n") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                               exp2(ii) *
                                IF ii < N - n!1
                                  THEN b2n(bv!1(ii + n!1))
                                ELSE b2n(FALSE)
                                ENDIF)" "N-1" "0" "N-n!1-1") (("1" (assert) (("1" (case-replace "sigma(N - n!1, N - 1,
                          extend(LAMBDA (ii: below(N)):
                                   exp2(ii) *
                                    IF ii < N - n!1
                                      THEN b2n(bv!1(ii + n!1))
                                    ELSE b2n(FALSE)
                                    ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (lemma "sigma_split") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                    exp2(ii) *
                                     IF ii < N - 1 - n!1
                                       THEN b2n(bv!1(ii + n!1))
                                     ELSE b2n(FALSE)
                                     ENDIF)" "N-1" "0" "N-2-n!1") (("1" (assert) (("1" (case-replace "sigma(N - 1 - n!1, N - 1,
                              extend(LAMBDA (ii: below(N)):
                                       exp2(ii) *
                                        IF ii < N - 1 - n!1
                                          THEN b2n(bv!1(ii + n!1))
                                        ELSE b2n(FALSE)
                                        ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                       exp2(ii) *
                                        IF ii < N - n!1
                                          THEN b2n(bv!1(ii + n!1))
                                        ELSE b2n(FALSE)
                                        ENDIF)" "extend(LAMBDA (ii: below(N)):
                                        exp2(ii) *
                                         IF ii < N - 1 - n!1
                                           THEN b2n(bv!1(ii + n!1))
                                         ELSE b2n(FALSE)
                                         ENDIF)" "N-2-n!1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                                  0 *
                                   extend(LAMBDA (ii: below(N)):
                                            exp2(ii) *
                                             IF ii < N - 1 - n!1
                                               THEN b2n(bv!1(ii + n!1))
                                             ELSE b2n(FALSE)
                                             ENDIF)
                                         (n)" "extend(LAMBDA (ii: below(N)):
                                         exp2(ii) *
                                          IF ii < N - 1 - n!1
                                            THEN b2n(bv!1(ii + n!1))
                                          ELSE b2n(FALSE)
                                          ENDIF)" "N-1" "N-1-n!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                              0 *
                               extend(LAMBDA (ii: below(N)):
                                        exp2(ii) *
                                         IF ii < N - n!1
                                           THEN b2n(bv!1(ii + n!1))
                                         ELSE b2n(FALSE)
                                         ENDIF)
                                     (n)" "extend(LAMBDA (ii: below(N)):
                                     exp2(ii) *
                                      IF ii < N - n!1
                                        THEN b2n(bv!1(ii + n!1))
                                      ELSE b2n(FALSE)
                                      ENDIF)" "N-1" "N-n!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2nat_as_sum formula-decl nil bv_sum nil) (sigma def-decl "nat" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (extend const-decl "[nat -> nat]" bv_sum nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (sigma_mult formula-decl nil sums nil) (sigma_split formula-decl nil sums nil) (fill const-decl "bit" bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (FALSE const-decl "bool" booleans nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 20289 9200 nil nil)) (bv2nat_split_TCC1 0 (bv2nat_split_TCC1-1 nil 3249114881 3249231453 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) 653 320 nil nil)) (bv2nat_split 0 (bv2nat_split-1 nil 3249114881 3249231480 ("" (use "N_size") (("" (skosimp*) (("" (case-replace "m!1=0") (("1" (assert) (("1" (expand "exp2") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "m!1=N") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (assert) (("1" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                        exp2(ii) *
                                         IF ii < m!1
                                           THEN b2n(bv1!1(ii+N-m!1))
                                         ELSE b2n(FALSE)
                                         ENDIF)" "N-1" "0" "m!1-1") (("1" (assert) (("1" (case-replace "sigma(m!1, N - 1,
                                  extend(LAMBDA (ii: below(N)):
                                           exp2(ii) *
                                            IF ii < m!1
                                              THEN b2n(bv1!1(ii+N-m!1))
                                            ELSE b2n(FALSE)
                                            ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_split") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                                exp2(ii) *
                                                 IF ii < N - m!1
                                                   THEN b2n(bv2!1(ii))
                                                 ELSE b2n(FALSE)
                                                 ENDIF)" "N-1" "0" "N-m!1-1") (("1" (assert) (("1" (case-replace "sigma(N - m!1, N - 1,
                                      extend(LAMBDA (ii: below(N)):
                                               exp2(ii) *
                                                IF ii < N - m!1
                                                  THEN b2n(bv2!1(ii))
                                                ELSE b2n(FALSE)
                                                ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_mult") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                     exp2(ii) *
                                                      IF ii < N - m!1
                                                        THEN b2n(bv2!1(ii))
                                                      ELSE b2n(FALSE)
                                                      ENDIF)" "N-1-m!1" "0" "exp2(m!1)") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                 exp2(ii) *
                                                  IF ii < m!1
                                                    THEN b2n(bv1!1(ii + N - m!1))
                                                  ELSE b2n(bv2!1(ii - m!1))
                                                  ENDIF)" "N-1" "0" "m!1-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                       exp2(ii) *
                                        IF ii < m!1
                                          THEN b2n(bv1!1(ii + N - m!1))
                                        ELSE b2n(bv2!1(ii - m!1))
                                        ENDIF)" "extend(LAMBDA (ii: below(N)):
                                         exp2(ii) *
                                          IF ii < m!1
                                            THEN b2n(bv1!1(ii + N - m!1))
                                          ELSE b2n(FALSE)
                                          ENDIF)" "m!1-1" "0") (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                           exp2(ii) *
                                            IF ii < m!1
                                              THEN b2n(bv1!1(ii + N - m!1))
                                            ELSE b2n(bv2!1(ii - m!1))
                                            ENDIF)" "N-1-m!1" "0" "m!1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) (("1" (lemma "exp2_sum") (("1" (inst - "m!1-1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat) :
                                          0 *
                                           extend(LAMBDA (ii: below(N)):
                                                    exp2(ii) *
                                                     IF ii < N - m!1
                                                       THEN b2n(bv2!1(ii))
                                                     ELSE b2n(FALSE)
                                                     ENDIF)
                                                 (n)" "extend(LAMBDA (ii: below(N)):
                                                 exp2(ii) *
                                                  IF ii < N - m!1
                                                    THEN b2n(bv2!1(ii))
                                                  ELSE b2n(FALSE)
                                                  ENDIF)" "N-1" "N-m!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                        0 *
                                         extend(LAMBDA (ii: below(N)):
                                                  exp2(ii) *
                                                   IF ii < m!1
                                                     THEN b2n(bv1!1(ii+N-m!1))
                                                   ELSE b2n(FALSE)
                                                   ENDIF)
                                               (n)" "extend(LAMBDA (ii: below(N)):
                                               exp2(ii) *
                                                IF ii < m!1
                                                  THEN b2n(bv1!1(ii+N-m!1))
                                                ELSE b2n(FALSE)
                                                ENDIF)" "N-1" "m!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((m!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma def-decl "nat" sums nil) (restrict const-decl "[nat -> nat]" sums nil) (exp2_sum formula-decl nil exp2 nil) (sigma_shift formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (sigma_split formula-decl nil sums nil) (FALSE const-decl "bool" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (fill const-decl "bit" bv nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 27176 10280 nil nil)) (bv2nat_left_false_minus_TCC1 0 (bv2nat_left_false_minus_TCC1-1 nil 3249114881 3249231481 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 677 250 nil nil)) (bv2nat_left_false_minus 0 (bv2nat_left_false_minus-1 nil 3249114881 3249231491 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                           exp2(ii) *
                            IF ii < N - n!1
                              THEN b2n(bv!1(ii + n!1))
                            ELSE b2n(FALSE)
                            ENDIF)" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "exp2" -1 3) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_mult") (("1" (inst?) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (expand "sigma" 1 2) (("1" (expand "extend" 1 2) (("1" (expand "b2n" 1 7) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < N - n!1
                                   THEN b2n(bv!1(ii + n!1))
                                 ELSE b2n(FALSE)
                                 ENDIF)" "N-2" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                           extend(LAMBDA (ii: below(N)):
                                    exp2(ii) *
                                     IF ii < N - n!1
                                       THEN b2n(bv!1(ii + n!1))
                                     ELSE b2n(FALSE)
                                     ENDIF)
                                 (1 + n)" "LAMBDA (n:nat):
                            2 *
                             extend(LAMBDA (ii: below(N)):
                                      exp2(ii) *
                                       IF ii < N - 1 - n!1
                                         THEN b2n(bv!1(1 + ii + n!1))
                                       ELSE b2n(FALSE)
                                       ENDIF)
                                   (n)" "N-2" "0") (("1" (assert) (("1" (hide 2) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) proved ((sigma_split formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_shift formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FALSE const-decl "bool" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 10461 4310 nil nil)) (bv2nat_leftshift_exp_TCC1 0 (bv2nat_leftshift_exp_TCC1-1 nil 3249114881 3249231492 ("" (subtype-tcc) nil nil) proved nil 361 40 nil nil)) (bv2nat_leftshift_exp 0 (bv2nat_leftshift_exp-1 nil 3249114881 3249231499 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "bv2nat_as_sum[N]") (("" (assert) (("" (rewrite "bv2nat_as_sum[N]") (("" (expand "sigma" 1 1) (("" (expand "extend" 1 1) (("" (lemma "sigma_split") (("" (inst - "extend(LAMBDA (ii: below(N)):
                        exp2(ii) * b2n(left_shift(1, bv!1)(ii)))" "N-1" "0" "0") (("" (assert) (("" (expand "sigma" -1 2) (("" (expand "extend" -1 2) (("" (expand "left_shift" -1 3) (("" (expand "^") (("" (expand "o ") (("" (expand "fill") (("" (expand "b2n" -1 3) (("" (replace -1) (("" (hide -1) (("" (lemma "sigma_shift") (("" (inst -1 "extend(LAMBDA (ii: below(N)):
                        exp2(ii) * b2n(left_shift(1, bv!1)(ii)))" "N-2" "0" "1") (("" (assert) (("" (replace -1) (("" (hide -1) (("" (case-replace "sigma(0, N - 2,
               LAMBDA (n:nat):
                 extend(LAMBDA (ii: below(N)):
                          exp2(ii) * b2n(left_shift(1, bv!1)(ii)))
                       (1 + n)) = 2 * sigma(0, N - 2,
              extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii))))") (("1" (rewrite "times_div1" :dir rl) nil nil) ("2" (hide 2) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat):
                  extend(LAMBDA (ii: below(N)):
                           exp2(ii) * b2n(left_shift(1, bv!1)(ii)))
                        (1 + n)" "LAMBDA (n:nat):
                   2 *
                    extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "N-2" "0") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((sigma def-decl "nat" sums nil) (sigma_split formula-decl nil sums nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (sigma_shift formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (times_div1 formula-decl nil real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (left_shift const-decl "bvec[N]" bv_shift nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 7156 2460 nil nil)) (divrem_mem_TCC1 0 (divrem_mem_TCC1-1 nil 3249114881 3249231499 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 326 120 nil nil)) (divrem_mem_TCC2 0 (divrem_mem_TCC2-1 nil 3249114881 3249231500 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 447 130 nil nil)) (divrem_mem_TCC3 0 (divrem_mem_TCC3-1 nil 3249114881 3249231501 ("" (subtype-tcc) nil nil) proved ((below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 1748 520 nil nil)) (divrem_mem_TCC4 0 (divrem_mem_TCC4-1 nil 3249114881 3249231502 ("" (termination-tcc) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 811 340 nil nil)) (divrem_mem_TCC5 0 (divrem_mem_TCC5-1 nil 3249114881 3249231503 ("" (subtype-tcc) nil nil) proved ((below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 1157 520 nil nil)) (divrem_mem_TCC6 0 (divrem_mem_TCC6-1 nil 3249114881 3249231504 ("" (termination-tcc) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 666 350 nil nil)) (divrem_mem_first_second_third 0 (divrem_mem_first_second_third-1 nil 3249114881 3249232586 ("" (use "N_size") (("" (induct "n") (("1" (grind) (("1" (apply-extensionality :hide? t) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (expand "divrem" +) (("2" (case-replace "(LAMBDA (i: below(N)):
                      IF i < N - jb!1
                        THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                      ELSE FALSE
                      ENDIF) = (left_shift(1,
                               LAMBDA (i: below(N)):
                                 IF i < N - 1 - jb!1
                                   THEN rem!1(i)
                                 ELSE FALSE
                                 ENDIF)
                      WITH [(0) := quot!1(N - 1)])") (("1" (hide -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (inst - "left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]" "dvs!1" "left_shift(1, quot!1) WITH [(0) := TRUE]" "(left_shift(1,
                                              LAMBDA (i: below(N)):
                                                IF i < N - 1 - jb!1
                                                  THEN rem!1(i)
                                                ELSE FALSE
                                                ENDIF)
                                     WITH [(0) := quot!1(N - 1)])
                                   - dvs!1") (("1" (assert) (("1" (flatten) (("1" (case-replace "(LAMBDA (i: below(N)):
                                IF i < N - jb!1
                                  THEN ((left_shift(1,
                                                    LAMBDA
                                                    (i: below(N)):
                                                    IF i < N - 1 - jb!1
                                                    THEN rem!1(i)
                                                    ELSE FALSE
                                                    ENDIF)
                                           WITH [(0) := quot!1(N - 1)])
                                         - dvs!1)
                                           (i) ELSE FALSE
                                ENDIF) = left_shift(1,
                                           LAMBDA (i: below(N)):
                                             IF i < N - 1 - jb!1
                                               THEN rem!1(i)
                                             ELSE FALSE
                                             ENDIF)
                                  WITH [(0) := quot!1(N - 1)]
                                 - dvs!1") (("1" (assert) (("1" (replace*) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 2) (("2" (name-replace "ls" "(left_shift(1,
                                            LAMBDA (i: below(N)):
                                              IF i < N - 1 - jb!1
                                                THEN rem!1(i)
                                              ELSE FALSE
                                              ENDIF)
                                   WITH [(0) := quot!1(N - 1)])") (("2" (case "bv2nat[N](LAMBDA (i: below(N)):
                                              IF i < N - jb!1
                                                THEN (ls
                                                       - dvs!1)
                                                         (i) ELSE FALSE
                                              ENDIF) = bv2nat[N](ls
                                               - dvs!1)") (("1" (rewrite "bv2nat_inj[N]") nil nil) ("2" (hide 2) (("2" (rewrite "bv2nat_minus") (("2" (case-replace "bv2nat[N](ls) = bv2nat[N-jb!1](ls^(N-jb!1-1,0))") (("1" (hide -1) (("1" (case-replace "bv2nat[N](dvs!1) = bv2nat[N-jb!1](dvs!1^(N-jb!1-1,0))") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                             IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF) = (fill[jb!1](FALSE) o ((ls - dvs!1) ^ (N - 1 - jb!1, 0)))") (("1" (hide -1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) (("1" (expand "-") (("1" (rewrite "bv_add_subrange") (("1" (rewrite "bv_caret_negate") (("1" (lemma "DivisionUtil.bv2nat_minus") (("1" (expand "-") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "dvs!1 = (fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0)))") (("1" (case "bv2nat[N](dvs!1) = bv2nat[N](fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0)))") (("1" (replace -1 1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case-replace "jb!1=0") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "bv2nat_upperbound[N]") (("2" (inst - "dvs!1" "N-jb!1") (("1" (assert) (("1" (hide -2) (("1" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "bv2nat_concat") (("2" (inst - "N-jb!1" "jb!1" "fill[jb!1](FALSE)" "(ls ^ (N - jb!1 - 1, 0))") (("2" (rewrite "bv2nat_fill_F") (("2" (assert) (("2" (case "ls = (fill[jb!1](FALSE) o (ls ^ (N - 1 - jb!1, 0)))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (expand "ls") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst - "left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]" "dvs!1" "left_shift(1, quot!1)" "left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]") (("2" (flatten) (("2" (assert) (("2" (case-replace "(LAMBDA (i: below(N)):
                               IF i < N - jb!1
                                 THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                               ELSE FALSE
                               ENDIF) = left_shift(1,
                                         LAMBDA (i: below(N)):
                                           IF i < N - 1 - jb!1
                                             THEN rem!1(i)
                                           ELSE FALSE
                                           ENDIF)
                                WITH [(0) := quot!1(N - 1)]") (("1" (assert) (("1" (replace*) (("1" (hide-all-but 2) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) proved ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (FALSE const-decl "bool" booleans nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (left_shift const-decl "bvec[N]" bv_shift nil) (- const-decl "bvec[N]" bv_arithmetic nil) (TRUE const-decl "bool" booleans nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_inj formula-decl nil bv_nat nil) (bv2nat_minus formula-decl nil DivisionUtil nil) (ls skolem-const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv_add_subrange formula-decl nil bv_arith_caret nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 620226 33650 t nil)) (divrem_mem_rem 0 (divrem_mem_rem-1 nil 3249114881 3249231549 ("" (use "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (assert) (("1" (expand "divrem_mem") (("1" (case-replace "(LAMBDA (i: below(N)): rem!1(i)) = rem!1") (("1" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (name-replace "ls" "(LAMBDA (i: below(N)):
              IF i < N - jb!1
                THEN left_shift(1, rem!1) WITH [(0) := dvd!1(N - 1)](i)
              ELSE FALSE
              ENDIF)") (("1" (expand "<") (("1" (lemma "leftshift_with") (("1" (inst - "N" "(LAMBDA (i: below(N)):
               IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)" "dvd!1(N - 1)") (("1" (assert) (("1" (split -) (("1" (case-replace "(left_shift(1,
                      (LAMBDA (i: below(N)):
                         IF i < N - 1 - jb!1
                           THEN rem!1(i)
                         ELSE FALSE
                         ENDIF))
             WITH [(0) := dvd!1(N - 1)]) = ls") (("1" (hide -1) (("1" (case-replace "jb!1=0") (("1" (assert) (("1" (case-replace "(LAMBDA (i: below(N)): (ls - dvs!1)(i)) = (ls - dvs!1)") (("1" (hide -1) (("1" (rewrite "bv2nat_minus") (("1" (assert) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil) ("2" (case "bv2nat[N](ls) < exp2(N-jb!1)") (("1" (lemma "bv2nat_upperbound_caret[N]") (("1" (inst-cp - "ls" "N-jb!1") (("1" (assert) (("1" (inst-cp - "dvs!1" "N-jb!1") (("1" (assert) (("1" (inst - "(LAMBDA (i: below(N)):
               IF i < N - jb!1
                 THEN (ls - dvs!1)(i)
               ELSE FALSE
               ENDIF)" "N-jb!1") (("1" (assert) (("1" (split -) (("1" (replace*) (("1" (case-replace "((LAMBDA (i: below(N)):
              IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF)
            ^ (N - 1 - jb!1, 0)) = (ls - dvs!1)^ (N - 1 - jb!1, 0)") (("1" (expand "-") (("1" (rewrite "bv_add_caret") (("1" (rewrite "bv_caret_negate") (("1" (rewrite "-" :dir rl) (("1" (rewrite "bv2nat_minus") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -1 -2 -4 3) (("2" (use "bv2nat_upperbound[N]") (("1" (assert) (("1" (skosimp*) (("1" (expand "ls") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (expand "ls") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 2) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst?) (("1" (assert) (("1" (expand "<") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" bv_arith_nat nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "bvec[N]" bv_arithmetic nil) (TRUE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (fill const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (bv_add_caret formula-decl nil bv_arith_caret_rules nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (below type-eq-decl nil nat_types nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (bv2nat_upperbound_caret formula-decl nil BitvectorUtil nil) (ls skolem-const-decl "[below(N) -> bit]" BitvectorOneComplementDivision nil) (bv2nat_minus formula-decl nil DivisionUtil nil) (leftshift_with formula-decl nil DivisionUtil nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 16558 7780 nil nil)) (div_divrem_mem_TCC1 0 (div_divrem_mem_TCC1-1 nil 3249114881 3249231549 ("" (subtype-tcc) nil nil) proved nil 69 70 nil nil)) (div_divrem_mem 0 (div_divrem_mem-1 nil 3249114881 3249231550 ("" (skosimp*) (("" (expand "div") (("" (use "divrem_mem_first_second_third") (("" (assert) (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil)) 824 360 nil nil)) (rem_divrem_mem 0 (rem_divrem_mem-1 nil 3249114881 3249231551 ("" (skosimp*) (("" (expand "rem") (("" (use "divrem_mem_first_second_third") (("" (assert) (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil)) 642 340 nil nil)) (divrem_mem_invariant 0 (divrem_mem_invariant-1 nil 3249114881 3249233406 ("" (use "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (expand "divrem_mem") (("1" (assert) (("1" (case-replace "(LAMBDA (i: below(N)): aux!1(i)) = aux!1") (("1" (case-replace "(LAMBDA (i: below(N)): rem!1(i)) = rem!1") (("1" (case-replace "(LAMBDA (i: below(N)): quot!1(i)) = quot!1") (("1" (expand "exp2") (("1" (propax) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                         IF i < 1 + jb!1
                           THEN quot!1(i - 1 + N - jb!1)
                         ELSE aux!1(i - 1 - jb!1)
                         ENDIF) = (LAMBDA (i: below(N)):
                         IF i < jb!1
                           THEN left_shift(1, quot!1)(i + N - jb!1)
                         ELSE left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]
                                  (i - jb!1)
                         ENDIF)") (("1" (hide -1) (("1" (replace -3) (("1" (hide -3) (("1" (assert) (("1" (expand "exp2" 1 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                               IF i < N - jb!1
                                 THEN left_shift(1, quot!1) WITH [(0) := TRUE](i)
                               ELSE FALSE
                               ENDIF) = left_shift(1, (LAMBDA (i: below(N)):
                              IF i < N - 1 - jb!1 THEN quot!1(i) ELSE FALSE ENDIF)) WITH [(0) := TRUE]") (("1" (hide -1) (("1" (rewrite "leftshift_with" 1) (("1" (assert) (("1" (expand "b2n") (("1" (lemma "bv2nat_split") (("1" (inst-cp - "quot!1" "rem!1" "1+jb!1") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (inst - "left_shift(1, quot!1)" "left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)] - dvs!1" "jb!1") (("1" (hide -1) (("1" (expand "exp2" 1 1) (("1" (name-replace "lsrem" "(LAMBDA (i: below(N)):
                                      IF i < N - jb!1
                                        THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                                      ELSE FALSE
                                      ENDIF)") (("1" (lemma "bv2nat_split") (("1" (inst -1 "left_shift(1, quot!1)" "lsrem - dvs!1" "jb!1") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (case-replace "bv2nat[N]
                                     (LAMBDA (i: below(N)):
                                        IF i < N - jb!1 THEN (lsrem - dvs!1)(i) ELSE FALSE ENDIF)
                            = bv2nat[N](lsrem) - bv2nat[N](dvs!1)") (("1" (hide -1 -2) (("1" (assert) (("1" (expand "lsrem") (("1" (case-replace "bv2nat[N]
                                        ((LAMBDA (i: below(N)):
                                            IF i < N - jb!1
                                              THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                                            ELSE FALSE
                                            ENDIF)) = 2 *
                                    (bv2nat[N]
                                         (LAMBDA (i: below(N)):
                                            IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)) + b2n(quot!1(N - 1))") (("1" (assert) (("1" (hide -1) (("1" (case-replace "jb!1=0") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (expand "exp2") (("1" (assert) (("1" (rewrite "bv2nat_lem") (("1" (expand "^") (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                                  exp2(ii) *
                                                                   IF ii < jb!1
                                                                     THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                   ELSE b2n(FALSE)
                                                                   ENDIF)" "N-1" "0" "jb!1-1") (("1" (assert) (("1" (case-replace "sigma(jb!1, N - 1,
                                                              extend(LAMBDA (ii: below(N)):
                                                                       exp2(ii) *
                                                                        IF ii < jb!1
                                                                          THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                        ELSE b2n(FALSE)
                                                                        ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (case-replace "jb!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(quot!1(ii)))" "extend(LAMBDA (ii: below(N)):
                                                                               exp2(ii) *
                                                                                IF ii < N - 1
                                                                                  THEN b2n(left_shift(1, quot!1)(1 + ii))
                                                                                ELSE b2n(FALSE)
                                                                                ENDIF)" "N-2" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                                             exp2(ii) *
                                                                              IF ii < 1 + jb!1
                                                                                THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                              ELSE b2n(FALSE)
                                                                              ENDIF)" "N-1" "0" "jb!1") (("1" (assert) (("1" (case-replace "sigma(1 + jb!1, N - 1,
                                                                          extend(LAMBDA (ii: below(N)):
                                                                                   exp2(ii) *
                                                                                    IF ii < 1 + jb!1
                                                                                      THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                    ELSE b2n(FALSE)
                                                                                    ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                                                                     exp2(ii) *
                                                                                      IF ii < 1 + jb!1
                                                                                        THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                      ELSE b2n(FALSE)
                                                                                      ENDIF)" "extend(LAMBDA (ii: below(N)):
                                                                                      exp2(ii) *
                                                                                       IF ii < jb!1
                                                                                         THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                       ELSE b2n(FALSE)
                                                                                       ENDIF)" "jb!1-1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                                                  0 *
                                                                                   extend(LAMBDA (ii: below(N)):
                                                                                            exp2(ii) *
                                                                                             IF ii < 1 + jb!1
                                                                                               THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                             ELSE b2n(FALSE)
                                                                                             ENDIF)
                                                                                         (n)" "extend(LAMBDA (ii: below(N)):
                                                                                         exp2(ii) *
                                                                                          IF ii < 1 + jb!1
                                                                                            THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                          ELSE b2n(FALSE)
                                                                                          ENDIF)" "N-1" "1+jb!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                                                                      0 *
                                                                       extend(LAMBDA (ii: below(N)):
                                                                                exp2(ii) *
                                                                                 IF ii < jb!1
                                                                                   THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                 ELSE b2n(FALSE)
                                                                                 ENDIF)
                                                                             (n)" "extend(LAMBDA (ii: below(N)):
                                                                             exp2(ii) *
                                                                              IF ii < jb!1
                                                                                THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                              ELSE b2n(FALSE)
                                                                              ENDIF)" "N-1" "jb!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (case-replace "jb!1=0") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                         exp2(ii) *
                                                          b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                                                  (ii)))" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "exp2" -1 3) (("1" (replace -1) (("1" (hide -1) (("1" (expand "sigma" 1 2) (("1" (expand "extend" 1 2) (("1" (expand "b2n" 1 6) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                          exp2(ii) *
                                                           b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                                                   (ii)))" "N-2" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                   extend(LAMBDA (ii: below(N)):
                                                            exp2(ii) *
                                                             b2n(left_shift(1, rem!1)
                                                                   WITH [(0) := quot!1(N - 1)]
                                                                     (ii)))
                                                         (1 + n)" "LAMBDA (n:nat):
                                                    2 *
                                                     extend(LAMBDA (ii: below(N)):
                                                              exp2(ii) *
                                                               IF ii < N - 1
                                                                 THEN b2n(rem!1(ii))
                                                               ELSE b2n(FALSE)
                                                               ENDIF)
                                                           (n)" "N-2" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                         exp2(ii) *
                                                          IF ii < N - jb!1
                                                            THEN b2n(left_shift(1, rem!1)
                                                                       WITH [(0) := quot!1(N - 1)]
                                                                         (ii))
                                                          ELSE b2n(FALSE)
                                                          ENDIF)" "N-1" "0" "N-jb!1-1") (("2" (assert) (("2" (case-replace "sigma(N - jb!1, N - 1,
                                                  extend(LAMBDA (ii: below(N)):
                                                           exp2(ii) *
                                                            IF ii < N - jb!1
                                                              THEN b2n(left_shift(1, rem!1)
                                                                         WITH [(0) := quot!1(N - 1)]
                                                                           (ii))
                                                            ELSE b2n(FALSE)
                                                            ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (case-replace "jb!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (expand "exp2" 2 1) (("1" (assert) (("1" (lemma "sigma_mult") (("1" (inst - "LAMBDA (n:nat):
                                                            2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "N-1" "0" "0") (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n: nat):
                                                           0 *
                                                            (2 *
                                                              extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))
                                                                    (n))" "LAMBDA (n:nat):
                                                            2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "N-1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                                 exp2(ii) *
                                                                  IF ii < N - jb!1
                                                                    THEN b2n(left_shift(1, rem!1)
                                                                               WITH [(0) := quot!1(N - 1)]
                                                                                 (ii))
                                                                  ELSE b2n(FALSE)
                                                                  ENDIF)" "N-1-jb!1" "0" "0") (("2" (assert) (("2" (expand "sigma" -1 2) (("2" (expand "extend" -1 2) (("2" (replace -1) (("2" (hide -1) (("2" (expand "exp2" 3 2) (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst -1 "LAMBDA (n:nat):
                                                            2 *
                                                             extend(LAMBDA (ii: below(N)):
                                                                      exp2(ii) *
                                                                       IF ii < N - 1 - jb!1
                                                                         THEN b2n(rem!1(ii))
                                                                       ELSE b2n(FALSE)
                                                                       ENDIF)
                                                                   (n)" "N-1" "0" "N-2-jb!1") (("2" (assert) (("2" (case-replace "sigma(N - 1 - jb!1, N - 1,
                                                          LAMBDA (n: nat):
                                                            2 *
                                                             extend(LAMBDA (ii: below(N)):
                                                                      exp2(ii) *
                                                                       IF ii < N - 1 - jb!1
                                                                         THEN b2n(rem!1(ii))
                                                                       ELSE b2n(FALSE)
                                                                       ENDIF)
                                                                   (n)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                                      exp2(ii) *
                                                                       IF ii < N - jb!1
                                                                         THEN b2n(left_shift(1, rem!1)
                                                                                    WITH [(0) := quot!1(N - 1)]
                                                                                      (ii))
                                                                       ELSE b2n(FALSE)
                                                                       ENDIF)" "N-2-jb!1" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                               extend(LAMBDA (ii: below(N)):
                                                                        exp2(ii) *
                                                                         IF ii < N - jb!1
                                                                           THEN b2n(left_shift(1, rem!1)
                                                                                    WITH [(0) := quot!1(N - 1)]
                                                                                    (ii))
                                                                         ELSE b2n(FALSE)
                                                                         ENDIF)
                                                                     (1 + n)" "LAMBDA (n: nat):
                                                                2 *
                                                                 extend(LAMBDA (ii: below(N)):
                                                                          exp2(ii) *
                                                                           IF ii < N - 1 - jb!1
                                                                             THEN b2n(rem!1(ii))
                                                                           ELSE b2n(FALSE)
                                                                           ENDIF)
                                                                       (n)" "N-2-jb!1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst - "LAMBDA (n: nat):
                                                              2 *
                                                               extend(LAMBDA (ii: below(N)):
                                                                        exp2(ii) *
                                                                         IF ii < N - 1 - jb!1
                                                                           THEN b2n(rem!1(ii))
                                                                         ELSE b2n(FALSE)
                                                                         ENDIF)
                                                                     (n)" "N-1" "N-1-jb!1" "0") (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n: nat):
                                                              2 *
                                                               extend(LAMBDA (ii: below(N)):
                                                                        exp2(ii) *
                                                                         IF ii < N - 1 - jb!1
                                                                           THEN b2n(rem!1(ii))
                                                                         ELSE b2n(FALSE)
                                                                         ENDIF)
                                                                     (n)" "LAMBDA(n:nat) : 0" "N-1" "N-1-jb!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat):
                                                      0 *
                                                       extend(LAMBDA (ii: below(N)):
                                                                exp2(ii) *
                                                                 IF ii < N - jb!1
                                                                   THEN b2n(left_shift(1, rem!1)
                                                                            WITH [(0) := quot!1(N - 1)]
                                                                            (ii))
                                                                 ELSE b2n(FALSE)
                                                                 ENDIF)
                                                             (n)" "extend(LAMBDA (ii: below(N)):
                                                             exp2(ii) *
                                                              IF ii < N - jb!1
                                                                THEN b2n(left_shift(1, rem!1)
                                                                           WITH [(0) := quot!1(N - 1)]
                                                                             (ii))
                                                              ELSE b2n(FALSE)
                                                              ENDIF)" "N-1" "N-jb!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "bv2nat[N](lsrem) = bv2nat[N-jb!1](lsrem^(N-1-jb!1,0))") (("1" (hide -1) (("1" (case-replace "bv2nat[N](dvs!1) = bv2nat[N-jb!1](dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                                 IF i < N - jb!1 THEN (lsrem - dvs!1)(i) ELSE FALSE ENDIF)
                                             = fill[jb!1](FALSE) o (lsrem - dvs!1) ^ (N - 1 - jb!1, 0)") (("1" (hide -1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) (("1" (expand "-") (("1" (rewrite "bv_add_subrange") (("1" (rewrite "bv_caret_negate") (("1" (lemma "DivisionUtil.bv2nat_minus") (("1" (expand "-") (("1" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "bv2nat[N](dvs!1) = bv2nat[N](fill[jb!1](FALSE) o dvs!1^(N-1-jb!1,0))") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "dvs!1 = fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case-replace "jb!1=0") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "bv2nat_upperbound[N]") (("2" (inst - "dvs!1" "N-jb!1") (("1" (assert) (("1" (hide -2) (("1" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (case-replace "bv2nat[N](lsrem) = bv2nat[N](fill[jb!1](FALSE) o lsrem^(N-1-jb!1,0))") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "lsrem = (fill[jb!1](FALSE) o lsrem ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (expand "lsrem") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (hide 1 2) (("2" (case-replace "(LAMBDA (i: below(N)):
                         IF i < 1 + jb!1
                           THEN quot!1(i - 1 + N - jb!1)
                         ELSE aux!1(i - 1 - jb!1)
                         ENDIF) = (LAMBDA (i: below(N)):
                         IF i < jb!1
                           THEN left_shift(1, quot!1)(i + N - jb!1)
                         ELSE left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]
                                  (i - jb!1)
                         ENDIF)") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                              IF i < 1 + jb!1
                                THEN quot!1(i - 1 + N - jb!1)
                              ELSE rem!1(i - 1 - jb!1)
                              ENDIF) = (LAMBDA (i: below(N)):
                              IF i < jb!1
                                THEN left_shift(1, quot!1)(i + N - jb!1)
                              ELSE left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                       (i - jb!1)
                              ENDIF)") (("1" (hide -1) (("1" (replace -2) (("1" (hide -2) (("1" (assert) (("1" (expand "exp2" 1 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                  IF i < N - jb!1
                                    THEN left_shift(1, quot!1)(i)
                                  ELSE FALSE
                                  ENDIF) = left_shift(1, (LAMBDA (i: below(N)):
                                   IF i < N - 1 - jb!1 THEN quot!1(i) ELSE FALSE ENDIF)) WITH [(0) := FALSE]") (("1" (rewrite "leftshift_with") (("1" (expand "b2n") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil) proved ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (FALSE const-decl "bool" booleans nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (leftshift_with formula-decl nil DivisionUtil nil) (b2n const-decl "nbit" bit nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv2nat_minus formula-decl nil DivisionUtil nil) (bv_add_subrange formula-decl nil bv_arith_caret nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (below type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (lsrem skolem-const-decl "[below(N) -> bit]" BitvectorOneComplementDivision nil) (sigma_shift formula-decl nil sums nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (above nonempty-type-eq-decl nil integers nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (^ const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma def-decl "nat" sums nil) (sigma_mult formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (sigma_split formula-decl nil sums nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (nbit type-eq-decl nil bit nil) (bv2nat_split formula-decl nil BitvectorOneComplementDivision nil) (left_shift const-decl "bvec[N]" bv_shift nil) (TRUE const-decl "bool" booleans nil) (- const-decl "bvec[N]" bv_arithmetic nil) (bv2nat_rec def-decl "nat" bv_nat nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 794341 124500 t nil)) (divrem1_eq 0 (divrem1_eq-1 nil 3249114881 3249231676 ("" (skosimp*) (("" (rewrite "div_divrem_mem") (("" (rewrite "rem_divrem_mem") (("" (use "divrem_mem_invariant") (("" (beta) (("" (split -) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (use "divrem_mem_first_second_third") (("1" (beta) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (hide -1 -2 -3) (("1" (case-replace "(LAMBDA (i: below(N)): dvd!1(i)) = dvd!1") (("1" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "bv2nat_fill_F[N]") (("2" (expand "fill") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((div_divrem_mem formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (divrem_mem_invariant formula-decl nil BitvectorOneComplementDivision nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (rem_divrem_mem formula-decl nil BitvectorOneComplementDivision nil)) 1532 750 t nil)) (rem1_below_dvs 0 (rem1_below_dvs-1 nil 3249114881 3249231677 ("" (skosimp*) (("" (rewrite "rem_divrem_mem") (("" (lemma "divrem_mem_rem") (("" (inst?) (("" (expand "<") (("" (assert) (("" (lemma "bv2nat_fill_F[N]") (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((rem_divrem_mem formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (< const-decl "bool" bv_arith_nat nil) (divrem_mem_rem formula-decl nil BitvectorOneComplementDivision nil)) 556 220 nil nil)) (rem1_dvs0 0 (rem1_dvs0-1 nil 3249114881 3249231677 ("" (skosimp*) (("" (expand "rem") (("" (use "divrem_dvs0") (("" (assert) (("" (replace -1) (("" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_dvs0 formula-decl nil BitvectorOneComplementDivision nil)) 531 220 nil nil)) (div1_dvs0 0 (div1_dvs0-1 nil 3249114881 3249231678 ("" (skosimp*) (("" (expand "div") (("" (use "divrem_dvs0") (("" (assert) (("" (replace -1) (("" (assert) (("" (apply-extensionality :hide? t) (("" (expand "fill") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_dvs0 formula-decl nil BitvectorOneComplementDivision nil)) 372 210 nil nil)) (div1_below_dvd 0 (div1_below_dvd-1 nil 3249114881 3249231678 ("" (skosimp*) (("" (use "divrem1_eq") (("" (replace -1 2 rl) (("" (hide -1) (("" (assert) (("" (lemma "le_times_le_pos") (("" (inst - "bv2nat(div(dvd!1, dvs!1))" "1" "bv2nat(dvs!1)" "bv2nat(div(dvd!1, dvs!1))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (le_times_le_pos formula-decl nil real_props nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (nonneg_real nonempty-type-eq-decl nil real_types nil)) 894 390 nil nil)) (divrem1_uniqueness 0 (divrem1_uniqueness-1 nil 3249114881 3249231680 ("" (skosimp*) (("" (use "divrem1_eq") (("" (use "rem1_below_dvs") (("" (assert) (("" (lemma "unique_division") (("" (inst - "bv2nat(dvs!1)" "bv2nat(div(dvd!1, dvs!1))" "q!1" "bv2nat(rem(dvd!1, dvs!1))" "r!1") (("" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (unique_division formula-decl nil euclidean_division nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil)) 1583 820 nil nil)) (divrem1_dvs1 0 (divrem1_dvs1-1 nil 3249114881 3249231681 ("" (skosimp*) (("" (use "rem1_below_dvs") (("" (lemma "bv2nat_one") (("" (assert) (("" (lemma "bv2nat_eq0[N]") (("" (inst?) (("" (assert) (("" (lemma "divrem1_uniqueness") (("" (inst - "dvd!1" "one" "bv2nat(dvd!1)" "bv2nat(rem(dvd!1, one))") (("" (assert) (("" (rewrite "bv2nat_one") (("" (assert) (("" (lemma "bv2nat_inj[N]") (("" (inst - "dvd!1" "div(dvd!1, one)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (divrem1_uniqueness formula-decl nil BitvectorOneComplementDivision nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_inj formula-decl nil bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (bv2nat_one formula-decl nil BitvectorMultiplication nil)) 400 360 nil nil)) (div1_eq0 0 (div1_eq0-1 nil 3249114881 3249231681 ("" (use "N_size") (("" (skosimp*) (("" (case-replace "bv2nat(dvs!1) = 0") (("1" (lemma "bv2nat_eq0[N]") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (rewrite "div1_dvs0") (("1" (rewrite "bv2nat_fill_T[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (iff) (("2" (use "divrem1_eq") (("2" (use "rem1_below_dvs") (("2" (assert) (("2" (split +) (("1" (reduce) nil nil) ("2" (flatten) (("2" (assert) (("2" (case "bv2nat(div(dvd!1, dvs!1)) * bv2nat(dvs!1) >= bv2nat(dvs!1)") (("1" (assert) nil nil) ("2" (hide -1 -2 -3) (("2" (lemma "ge_times_ge_pos") (("2" (inst - "bv2nat(dvs!1)" "1" "bv2nat(div(dvd!1, dvs!1))" "bv2nat(dvs!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (ge_times_ge_pos formula-decl nil real_props nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_fill_T formula-decl nil bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 801 750 nil nil)))(BitvectorTwoComplementDivision (IMP_BitvectorOneComplementDivision_TCC1 0 (IMP_BitvectorOneComplementDivision_TCC1-1 nil 3249114883 3249231681 ("" (use "N_size") nil nil) proved ((N_size formula-decl nil BitvectorTwoComplementDivision nil)) 6 10 nil nil)) (IMP_BitvectorOneComplementDivision_TCC2 0 (IMP_BitvectorOneComplementDivision_TCC2-1 nil 3249114883 3249231681 ("" (assuming-tcc) nil nil) proved nil 75 80 nil nil)) (DIVREM1_eq 0 (DIVREM1_eq-1 nil 3249114883 3249231683 ("" (skosimp*) (("" (use "divrem1_eq[2*N]") (("" (lemma "bv2nat_times[N]") (("" (rewrite -1) (("" (inst?) (("" (assert) (("" (replace -1 -2 rl) (("" (hide -1) (("" (lemma "bv_add[2*N]") (("" (inst?) (("" (assert) (("" (replace -1 -2 rl) (("" (hide -1) (("" (rewrite "bv2nat_inj") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (bv2nat_inj formula-decl nil bv_nat nil) (= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (bv_add formula-decl nil bv_arith_nat nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_times formula-decl nil BitvectorMultiplicationWidenNarrow nil)) 951 940 nil nil)) (div1_cancel 0 (div1_cancel-1 nil 3249114883 3249231684 ("" (use "N_size") (("" (skosimp*) (("" (case "bv2nat(DVS!1) = 0") (("1" (lemma "bv2nat_eq0[2*N]") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (rewrite "times_zero_second") (("1" (rewrite "div1_dvs0") (("1" (rewrite "div1_dvs0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2nat(div(BV!1 * DVD!1, BV!1 * DVS!1)) = bv2nat(div(DVD!1, DVS!1)) AND (bv2nat(DVS!1) /= 0 IMPLIES bv2nat(rem(BV!1 * DVD!1, BV!1 * DVS!1)) = bv2nat(BV!1 * rem(DVD!1, DVS!1)))") (("1" (flatten) (("1" (use "bv2nat_inj[2*N]") (("1" (assert) (("1" (hide -1 -2) (("1" (use "bv2nat_inj[2*N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "divrem1_uniqueness[2*N]") (("2" (inst - "BV!1 * DVD!1" "BV!1 * DVS!1" "bv2nat(div(DVD!1,DVS!1))" "bv2nat(BV!1) * bv2nat(rem(DVD!1,DVS!1))") (("2" (assert) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (rewrite "bv2nat_times[N]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_times[N]") (("2" (use "rem1_below_dvs[2*N]") (("2" (assert) (("2" (use "both_sides_times_pos_lt2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (rewrite "bv2nat_times[N]") (("3" (rewrite "bv2nat_times[N]") (("3" (assert) (("3" (lemma "divrem1_eq[2*N]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_inj formula-decl nil bv_nat nil) (divrem1_uniqueness formula-decl nil BitvectorOneComplementDivision nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (times_zero_second formula-decl nil BitvectorMultiplication nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 1906 1820 nil nil)) (rem_dvs0 0 (rem_dvs0-1 nil 3249114883 3249231685 ("" (use "N_size") (("" (skosimp*) (("" (expand "//") (("" (rewrite "bv2int_fill_F[N]") (("" (assert) (("" (rewrite "rem1_dvs0[N]") (("" (rewrite "rem1_dvs0[N]") (("" (rewrite "bv_double_neg") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int_fill_F formula-decl nil bv_int nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 186 180 nil nil)) (div_dvs0 0 (div_dvs0-1 nil 3249114883 3249231685 ("" (use "N_size") (("" (skosimp*) (("" (expand "/") (("" (rewrite "bv2int_fill_F[N]") (("" (assert) (("" (rewrite "div1_dvs0[N]") (("" (rewrite "div1_dvs0[N]") (("" (lift-if) (("" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide 1) (("2" (case "bv2int[N](-fill[N](TRUE)) = bv2int(one[N])") (("1" (use "bv2int_inj[N]") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "bv2int_one") (("2" (rewrite "bv2int_neg[N]") (("2" (rewrite "bv2int_fill_T[N]") (("2" (expand "minint") (("2" (assert) (("2" (typepred "exp2(N - 1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int_fill_F formula-decl nil bv_int nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (TRUE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bv2int_inj formula-decl nil bv_int nil) (bv2int_one formula-decl nil BitvectorMultiplication nil) (bv2int_fill_T formula-decl nil bv_int nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (NOT const-decl "[bool -> bool]" booleans nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 442 410 nil nil)) (divrem_dvs1 0 (divrem_dvs1-1 nil 3249114883 3249231685 ("" (use "N_size") (("" (skosimp*) (("" (expand "/") (("" (expand "//") (("" (rewrite "bv2int_one") (("" (assert) (("" (lift-if +) (("" (split +) (("1" (flatten) (("1" (use "divrem1_dvs1[N]") nil nil)) nil) ("2" (flatten) (("2" (use "divrem1_dvs1[N]") (("2" (flatten) (("2" (assert) (("2" (replace*) (("2" (rewrite "bv_double_neg") (("2" (rewrite "min_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (divrem1_dvs1 formula-decl nil BitvectorOneComplementDivision nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (min_fill_F formula-decl nil BitvectorUtil nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2int_one formula-decl nil BitvectorMultiplication nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 310 300 nil nil)) (rem_below_dvs 0 (rem_below_dvs-1 nil 3249114883 3249231692 ("" (use "N_size") (("" (skosimp*) (("" (expand "//") (("" (expand "abs") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (use "rem1_below_dvs[N]") (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "/=") (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "bv2nat_eq0[N]") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (rewrite "min_fill_F[N]") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv2int_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "bv2int") (("2" (reduce) (("2" (expand "exp2" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "rem1_below_dvs[N]") (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (use "rem1_below_dvs[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "/=") (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "bv2nat_eq0[N]") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (rewrite "min_fill_F[N]") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv2int_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "bv2int_neg[N]") (("2" (expand "minint") (("2" (expand "bv2int" -2) (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "exp2" -2) (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "bv2int_neg[N]") (("2" (use "rem1_below_dvs[N]") (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (min_fill_F formula-decl nil BitvectorUtil nil) (bv2int_fill_F formula-decl nil bv_int nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (/= const-decl "boolean" notequal nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 6077 5910 nil nil)) (divrem_eq_TCC1 0 (divrem_eq_TCC1-1 nil 3249114883 3249231692 ("" (subtype-tcc) nil nil) proved nil 33 40 nil nil)) (divrem_eq 0 (divrem_eq-1 nil 3249114883 3249231707 ("" (use "N_size") (("" (skosimp*) (("" (expand "/") (("" (expand "//") (("" (case "bv2int(dvd!1) = IF bv2nat(dvd!1) < exp2(N - 1)
                                                          THEN bv2nat(dvd!1)
                                                        ELSE bv2nat(dvd!1) - exp2(N)
                                                        ENDIF") (("1" (case "bv2int(dvs!1) = IF bv2nat(dvs!1) < exp2(N - 1)
                                                                        THEN bv2nat(dvs!1)
                                                                      ELSE bv2nat(dvs!1) - exp2(N)
                                                                      ENDIF") (("1" (case "bv2int[N](dvs!1) = 0") (("1" (assert) (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "bv2nat_eq0[N]") (("1" (inst - "dvs!1") (("1" (assert) (("1" (replace -1) (("1" (rewrite "rem1_dvs0") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "div1_dvs0") (("1" (rewrite "div1_dvs0") (("1" (rewrite "bv2int_neg[N]") (("1" (rewrite "bv2int_fill_T[N]") (("1" (rewrite "bv2int_fill_F[N]") (("1" (rewrite "bv_double_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (replace*) (("1" (expand "bv2int" +) (("1" (use "rem1_below_dvs[N]") (("1" (use "div1_below_dvd[N]") (("1" (assert) (("1" (use "divrem1_eq[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "rem1_below_dvs[N]") (("2" (use "div1_below_dvd[N]") (("2" (assert) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "exp2" -1) (("2" (assert) (("2" (expand "bv2int") (("2" (assert) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (use "divrem1_eq[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lift-if +) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "exp2" -1 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "exp2" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (expand "exp2" -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "exp2" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (use "rem1_below_dvs[N]") (("1" (use "div1_below_dvd[N]") (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "/=") (("1" (assert) (("1" (use "divrem1_eq[N]") (("1" (assert) (("1" (expand "bv2int") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lift-if +) (("1" (split +) (("1" (flatten) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (expand "exp2" -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "exp2" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "rem1_below_dvs[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (lemma "div1_below_dvd[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) (("2" (lemma "divrem1_eq[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (assert) (("2" (expand "bv2int") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (case-replace "bv2nat(rem[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) (("1" (case "bv2nat(div[N](-dvd!1, -dvs!1)) < exp2(N - 1)") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "exp2" -3) (("2" (case-replace "bv2nat(dvd!1) = exp2(N - 1)") (("1" (assert) (("1" (case-replace "bv2nat(dvs!1) = exp2(N) -1") (("1" (assert) nil nil) ("2" (case-replace "bv2nat[N](div[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) nil nil) ("2" (lemma "gt_times_gt_pos1") (("2" (inst - "1" "exp2(N-1)" "bv2nat[N](div[N](-dvd!1, -dvs!1))" "exp2(N) - bv2nat[N](dvs!1)") (("2" (assert) (("2" (case-replace "exp2(N) = 2 * exp2(N-1)") (("1" (assert) nil nil) ("2" (expand "exp2" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2nat(div[N](-dvd!1, -dvs!1)) < exp2(N - 1)") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "exp2" -2) (("2" (case-replace "bv2nat(dvd!1) = exp2(N - 1)") (("1" (assert) (("1" (case-replace "bv2nat(dvs!1) = exp2(N) -1") (("1" (assert) nil nil) ("2" (case-replace "bv2nat[N](div[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) nil nil) ("2" (lemma "gt_times_gt_pos1") (("2" (inst - "1" "exp2(N-1)" "bv2nat[N](div[N](-dvd!1, -dvs!1))" "exp2(N) - bv2nat[N](dvs!1)") (("2" (assert) (("2" (case-replace "exp2(N) = 2 * exp2(N-1)") (("1" (assert) nil nil) ("2" (expand "exp2" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bv2int") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "bv2int") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (div1_below_dvd formula-decl nil BitvectorOneComplementDivision nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (gt_times_gt_pos1 formula-decl nil real_props nil) (/= const-decl "boolean" notequal nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int_fill_T formula-decl nil bv_int nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_F formula-decl nil bv_int nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (TRUE const-decl "bool" booleans nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 14881 14490 nil nil)) (divrem_overflow 0 (divrem_overflow-1 nil 3249114883 3249231707 ("" (skosimp*) (("" (expand "/") (("" (expand "//") (("" (assert) (("" (case-replace "-dvs!1 = one") (("1" (use "divrem1_dvs1[N]") (("1" (flatten) (("1" (replace*) (("1" (rewrite "bv2int_neg[N]") (("1" (rewrite "bv2int_neg[N]") (("1" (rewrite "bv2int_fill_F[N]") (("1" (expand "minint") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "bv2int_neg[N]") (("2" (inst?) (("2" (expand "minint") (("2" (use "N_size") (("2" (assert) (("2" (replace -3) (("2" (assert) (("2" (expand "bv2int" -2) (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "bv2nat_one[N]") (("1" (use "bv2nat_inj[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil) (bv2nat_one formula-decl nil BitvectorMultiplication nil) (bv2nat_inj formula-decl nil bv_nat nil) (divrem1_dvs1 formula-decl nil BitvectorOneComplementDivision nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bv2int_fill_F formula-decl nil bv_int nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil)) 752 720 nil nil)) (div_sgn 0 (div_sgn-1 nil 3249114883 3249231747 ("" (use "N_size") (("" (skosimp*) (("" (expand "/") (("" (expand "abs") (("" (case "bv2int[N](dvs!1) > 0") (("1" (case "bv2int[N](dvd!1) >= 0") (("1" (assert) (("1" (use "div1_eq0[N]") (("1" (use "div1_below_dvd[N]") (("1" (expand "bv2int") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (use "div1_eq0[N]") (("2" (assert) (("2" (use "div1_below_dvd[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "bv2int") (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (reduce) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int[N](dvd!1) >= 0") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (use "div1_below_dvd[N]") (("1" (use "div1_eq0[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "bv2int") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (reduce) (("1" (expand "exp2" -4 1) (("1" (assert) nil nil)) nil) ("2" (expand "exp2" -4 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int[N](dvs!1) >= 0") (("1" (hide 5) (("1" (expand "bv2int") (("1" (reduce) nil nil)) nil)) nil) ("2" (assert) (("2" (use "div1_below_dvd[N]") (("2" (use "div1_eq0[N]") (("2" (assert) (("2" (case "bv2nat(-dvs!1) /= 0 ") (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lift-if -) (("1" (split -) (("1" (expand "bv2int") (("1" (reduce) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "bv2int") (("2" (expand "exp2" -2) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (case "bv2nat(div[N](-dvd!1, -dvs!1)) < exp2(N - 1)") (("1" (reduce) nil nil) ("2" (assert) (("2" (case-replace "bv2nat[N](div(-dvd!1, -dvs!1)) = exp2(N-1)") (("1" (hide -2 1 3 5) (("1" (use "divrem1_eq[N]") (("1" (replace -2) (("1" (case "exp2(N - 1) * bv2nat(-dvs!1) >= exp2(N)") (("1" (assert) nil nil) ("2" (hide -1) (("2" (case "bv2nat(-dvs!1) >= 2") (("1" (expand "exp2" 1 2) (("1" (assert) (("1" (lemma "both_sides_times_pos_ge1") (("1" (inst - "exp2(N-1)" "bv2nat(-dvs!1)" "2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "bv2nat(-dvs!1) = 1") (("1" (use "bv2nat_one[N]") (("1" (hide -1) (("1" (use "bv2nat_inj[N]") (("1" (assert) (("1" (use "divrem1_dvs1[N]") (("1" (flatten) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "exp2" -4 1) (("1" (expand "exp2" 7 1) (("1" (case-replace "dvs!1 = -one[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (assert) (("1" (lemma "bv2nat_one[N]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "bv2nat(-one[N]) = exp2(N) - 1") (("1" (use "bv2nat_inj[N]") (("1" (assert) nil nil)) nil) ("2" (rewrite "bv2nat_minus_bv[N]") (("2" (lemma "bv2nat_one[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2 3 4 5 7) (("2" (expand "/=") (("2" (lemma "bv2nat_eq0[N]") (("2" (inst?) (("2" (assert) (("2" (lemma "bv2nat_minus_bv[N]") (("2" (inst?) (("2" (replace -2) (("2" (rewrite "bv2nat_fill_F[N]") (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (exp2 def-decl "posnat" exp2 nil) (/= const-decl "boolean" notequal nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (bv2nat_one formula-decl nil BitvectorMultiplication nil) (bv2nat_inj formula-decl nil bv_nat nil) (divrem1_dvs1 formula-decl nil BitvectorOneComplementDivision nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (div1_eq0 formula-decl nil BitvectorOneComplementDivision nil) (div1_below_dvd formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 39240 18210 nil nil)) (rem_sgn 0 (rem_sgn-1 nil 3249114883 3249231781 ("" (use "N_size") (("" (skosimp*) (("" (assert) (("" (case "bv2int(dvs!1) = 0") (("1" (expand "bv2int") (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "bv2nat_eq0[N]") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (expand "//") (("1" (rewrite "bv2int_fill_F[N]") (("1" (assert) (("1" (lift-if +) (("1" (rewrite "rem1_dvs0") (("1" (assert) (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv_double_neg") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "NOT (bv2int(dvd!1) = -exp2(N - 1) AND bv2int(dvs!1) = -1)") (("1" (use "div_sgn") (("1" (use "divrem_eq") (("1" (replace 1) (("1" (assert) (("1" (flatten) (("1" (case "(bv2int(dvd!1 / dvs!1) = 0)") (("1" (assert) (("1" (hide 1 2) (("1" (expand "abs") (("1" (expand "bv2int") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(bv2int(dvd!1 / dvs!1) > 0)") (("1" (assert) (("1" (hide 2 3) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "rem1_below_dvs[N]") (("1" (inst - "dvd!1" "dvs!1") (("1" (expand "bv2int") (("1" (expand "//") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 4) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "bv2int") (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split -) (("1" (propax) nil nil) ("2" (split -) (("1" (flatten) (("1" (assert) (("1" (expand "//") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lemma "rem1_below_dvs[N]") (("1" (inst - "-dvd!1" "-dvs!1") (("1" (assert) (("1" (split -) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (reduce) nil nil)) nil) ("2" (expand "/=") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 3 4) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (expand "//") (("1" (use "rem1_below_dvs[N]") (("1" (assert) (("1" (split -) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "bv2int") (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "bv2int[N](dvs!1) = 0") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "bv2int" 1) (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide 3) (("2" (expand "//") (("2" (use "rem1_below_dvs[N]") (("2" (assert) (("2" (split -) (("1" (expand "bv2int") (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (split -) (("1" (assert) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split -) (("1" (assert) (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (reduce) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (use "divrem_overflow") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_F formula-decl nil bv_int nil) (divrem_overflow formula-decl nil BitvectorTwoComplementDivision nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (/= const-decl "boolean" notequal nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (NOT const-decl "[bool -> bool]" booleans nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 34440 14390 nil nil)) (divrem_uniqueness 0 (divrem_uniqueness-1 nil 3249114883 3249231823 ("" (use "N_size") (("" (skosimp*) (("" (use "divrem_eq") (("" (use "rem_sgn") (("" (use "rem_below_dvs") (("" (use "div_sgn") (("" (replace 1) (("" (assert) (("" (flatten) (("" (lemma "unique_division") (("" (case "(bv2int(dvd!1) > 0)") (("1" (assert) (("1" (expand "abs") (("1" (case "bv2int(dvs!1) < 0") (("1" (assert) (("1" (inst - "-bv2int(dvs!1)" "-q!1" "-bv2int[N](dvd!1 / dvs!1)" "r!1" "bv2int[N](dvd!1 // dvs!1)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst - "bv2int(dvs!1)" "q!1" "bv2int[N](dvd!1 / dvs!1)" "r!1" "bv2int[N](dvd!1 // dvs!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "(bv2int(dvd!1) < 0)") (("1" (assert) (("1" (expand "abs") (("1" (case "bv2int(dvs!1) < 0") (("1" (assert) (("1" (inst - "-bv2int(dvs!1)" "q!1" "bv2int[N](dvd!1 / dvs!1)" "-r!1" "-bv2int[N](dvd!1 // dvs!1)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "bv2int(dvs!1)" "-q!1" "-bv2int[N](dvd!1 / dvs!1)" "-r!1" "-bv2int[N](dvd!1 // dvs!1)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "bv2int(dvd!1) = 0") (("1" (case-replace "q!1=0") (("1" (reduce) nil nil) ("2" (reduce) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((rem_sgn formula-decl nil BitvectorTwoComplementDivision nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (unique_division formula-decl nil euclidean_division nil) (dvd!1 skolem-const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (dvs!1 skolem-const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (r!1 skolem-const-decl "int" BitvectorTwoComplementDivision nil) (= const-decl "[T, T -> boolean]" equalities nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rem_below_dvs formula-decl nil BitvectorTwoComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 41653 19480 nil nil)) (div_largest 0 (div_largest-1 nil 3249114883 3249231841 ("" (use "N_size") (("" (skosimp*) (("" (case "(bv2int(dvd!1) = -exp2(N-1) AND bv2int(dvs!1) = -1)") (("1" (flatten) (("1" (replace*) (("1" (expand "abs") (("1" (assert) (("1" (use "divrem_overflow") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "divrem_eq") (("2" (replace 1) (("2" (assert) (("2" (expand "abs") (("2" (use "div_sgn") (("2" (use "rem_sgn") (("2" (use "rem_below_dvs") (("2" (replace*) (("2" (assert) (("2" (expand "abs") (("2" (flatten) (("2" (case "bv2int(dvs!1) > 0") (("1" (assert) (("1" (case "bv2int(dvd!1) > 0") (("1" (assert) (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "q!1 >= 0") (("1" (assert) (("1" (rewrite "neg_times_lt") (("1" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_lt") (("2" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "bv2int(dvd!1) = 0") (("1" (assert) (("1" (rewrite "neg_times_lt") (("1" (replace*) (("1" (case "q!1 >= 0") (("1" (assert) (("1" (rewrite "neg_times_le") nil nil)) nil) ("2" (assert) (("2" (lemma "pos_times_ge") (("2" (inst - "bv2int(dvs!1)" "q!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvd!1) <= -bv2int(dvs!1)") (("1" (assert) (("1" (case-replace "bv2int(dvd!1 // dvs!1) = 0") (("1" (assert) (("1" (rewrite "neg_times_lt") (("1" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * q!1 <= bv2int(dvs!1) * -bv2int[N](dvd!1 / dvs!1)") (("1" (rewrite "both_sides_times_pos_le2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * -q!1 <= bv2int(dvs!1) * -bv2int[N](dvd!1 / dvs!1)") (("1" (rewrite "both_sides_times_pos_le2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_lt") (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_lt") (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int(dvd!1) > 0") (("1" (assert) (("1" (case-replace "q!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "neg_times_lt") (("2" (case "bv2int(dvd!1) >= -bv2int(dvs!1)") (("1" (assert) (("1" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_lt") (("2" (case-replace "q!1 = 0") (("1" (assert) nil nil) ("2" (case-replace "bv2int(dvd!1) = 0") (("1" (assert) (("1" (replace*) (("1" (case "q!1 >= 0") (("1" (assert) (("1" (lemma "pos_times_ge") (("1" (inst - "bv2int(dvs!1)" "q!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_le") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvd!1) <= bv2int(dvs!1)") (("1" (assert) (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) proved ((divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (rem_below_dvs formula-decl nil BitvectorTwoComplementDivision nil) (both_sides_times_neg_lt2 formula-decl nil real_props nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (pos_times_ge formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (neg_times_lt formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem_sgn formula-decl nil BitvectorTwoComplementDivision nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (divrem_overflow formula-decl nil BitvectorTwoComplementDivision nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) 18298 8470 nil nil)))(BitvectorTwoComplementDivisionWidenNarrow (IMP_BitvectorTwoComplementDivision_TCC1 0 (IMP_BitvectorTwoComplementDivision_TCC1-1 nil 3249114884 3249231841 ("" (use "N_size") nil nil) proved ((N_size formula-decl nil BitvectorTwoComplementDivisionWidenNarrow nil)) 6 10 nil nil)) (IMP_BitvectorTwoComplementDivision_TCC2 0 (IMP_BitvectorTwoComplementDivision_TCC2-1 nil 3249114884 3249231842 ("" (assuming-tcc) nil nil) proved nil 225 70 nil nil)) (DIVREM_eq 0 (DIVREM_eq-1 nil 3249114884 3249231847 ("" (skosimp*) (("" (expand "/") (("" (expand "//") (("" (reduce) (("1" (use "DIVREM1_eq[N]") nil nil) ("2" (use "DIVREM1_eq[N]") (("2" (rewrite "times_min_first") (("2" (rewrite "times_min_second" :dir rl) nil nil)) nil)) nil) ("3" (use "DIVREM1_eq[N]") (("3" (rewrite "times_min_first") (("3" (rewrite "bv_neg_distrib[2*N]" :dir rl) (("3" (replace -1) (("3" (rewrite "bv_double_neg[2*N]") nil nil)) nil)) nil)) nil)) nil) ("4" (use "DIVREM1_eq[N]") (("4" (rewrite "times_min_second") (("4" (rewrite "-" :dir rl) (("4" (lemma "bv_double_neg[2*N]") (("4" (inst - "rem(-DVD!1, -DVS!1)") (("4" (replace -1 -2 rl) (("4" (hide -1) (("4" (rewrite "bv_neg_distrib" :dir rl) (("4" (lemma "bv_double_neg[2*N]") (("4" (inst - "DVD!1") (("4" (replace -2 -1 rl) (("4" (rewrite "bv_double_neg[2*N]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivisionWidenNarrow nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (DIVREM1_eq formula-decl nil BitvectorTwoComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (times_min_first formula-decl nil BitvectorMultiplication nil) (times_min_second formula-decl nil BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv_neg_distrib formula-decl nil bv_arithmetic nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "bvec[N]" bv_arithmetic nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil)) 4874 2360 nil nil)) (divrem_widens_TCC1 0 (divrem_widens_TCC1-1 nil 3249114884 3249231847 ("" (subtype-tcc) nil nil) proved nil 33 30 nil nil)) (divrem_widens 0 (divrem_widens-1 nil 3249114884 3249231858 ("" (use "N_size") (("" (skosimp*) (("" (case "bv2int(dvs!1) = 0") (("1" (hide 1) (("1" (expand "bv2int") (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "bv2nat_eq0[N]") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (case-replace "widen(fill[N](FALSE)) = fill[2*N](FALSE)") (("1" (expand "/") (("1" (expand "//") (("1" (assert) (("1" (rewrite "bv2int_fill_F") (("1" (rewrite "bv2int_fill_F[N]") (("1" (assert) (("1" (rewrite "bv2int_widen") (("1" (rewrite "div1_dvs0[2*N]") (("1" (rewrite "div1_dvs0[N]") (("1" (rewrite "div1_dvs0[2*N]") (("1" (rewrite "rem1_dvs0[N]") (("1" (rewrite "rem1_dvs0[2*N]") (("1" (rewrite "rem1_dvs0[2*N]") (("1" (lift-if +) (("1" (split +) (("1" (flatten) (("1" (hide-all-but 1) (("1" (assert) (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "div1_dvs0[N]") (("2" (rewrite "rem1_dvs0[N]") (("2" (split +) (("1" (hide-all-but 1) (("1" (case "bv2int[2*N](-fill[2 * N](TRUE)) = bv2int[2*N](widen(-fill[N](TRUE)))") (("1" (rewrite "bv2int_inj") nil nil) ("2" (hide 2) (("2" (rewrite "bv2int_widen") (("2" (rewrite "bv2int_neg[N]") (("2" (rewrite "bv2int_neg[2*N]") (("2" (rewrite "bv2int_fill_T[2*N]") (("2" (rewrite "bv2int_fill_T[N]") (("2" (expand "minint") (("2" (typepred "exp2(2 * N - 1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv_double_neg[2*N]") (("2" (rewrite "bv_double_neg[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "divrem_uniqueness[2*N]") (("2" (inst - "widen(dvd!1)" "widen(dvs!1)" "bv2int(widen(dvd!1 / dvs!1))" "bv2int(widen(dvd!1 // dvs!1))") (("2" (split -) (("1" (flatten) (("1" (rewrite "bv2int_inj") (("1" (rewrite "bv2int_inj") nil nil)) nil)) nil) ("2" (rewrite "bv2int_widen") (("2" (rewrite "bv2int_widen") (("2" (flatten) (("2" (assert) (("2" (typepred "bv2int[N](dvd!1)") (("2" (expand "minint") (("2" (expand "maxint") (("2" (lemma "exp2_lt") (("2" (inst - "2*N-1" "N-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "bv2int_widen") (("3" (assert) nil nil)) nil) ("4" (rewrite "bv2int_widen") (("4" (rewrite "bv2int_widen") (("4" (rewrite "bv2int_widen") (("4" (use "div_sgn[N]") (("4" (replace*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (rewrite "bv2int_widen") (("5" (rewrite "bv2int_widen") (("5" (rewrite "bv2int_widen") (("5" (use "div_sgn[N]") (("5" (replace*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (rewrite "bv2int_widen") (("6" (rewrite "bv2int_widen") (("6" (rewrite "bv2int_widen") (("6" (use "div_sgn[N]") (("6" (replace*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (rewrite "bv2int_widen") (("7" (rewrite "bv2int_widen") (("7" (use "rem_sgn[N]") (("7" (flatten) (("7" (assert) nil nil)) nil)) nil)) nil)) nil) ("8" (rewrite "bv2int_widen") (("8" (rewrite "bv2int_widen") (("8" (use "rem_sgn[N]") (("8" (flatten) (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("9" (rewrite "bv2int_widen") (("9" (rewrite "bv2int_widen") (("9" (use "rem_below_dvs[N]") (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (rewrite "bv2int_widen") (("10" (rewrite "bv2int_widen") (("10" (rewrite "bv2int_widen") (("10" (rewrite "bv2int_widen") (("10" (use "divrem_eq[N]") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((divrem_uniqueness formula-decl nil BitvectorTwoComplementDivision nil) (exp2_lt formula-decl nil exp2 nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (rem_sgn formula-decl nil BitvectorTwoComplementDivision nil) (rem_below_dvs formula-decl nil BitvectorTwoComplementDivision nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (bv2int_fill_F formula-decl nil bv_int nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_T formula-decl nil bv_int nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (NOT const-decl "[bool -> bool]" booleans nil) (bv2int_inj formula-decl nil bv_int nil) (TRUE const-decl "bool" booleans nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (bv2int_widen formula-decl nil BitvectorUtil nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivisionWidenNarrow nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (N_size formula-decl nil BitvectorTwoComplementDivisionWidenNarrow nil)) 11212 5290 nil nil)) (div_cancel_TCC1 0 (div_cancel_TCC1-1 nil 3249114884 3249231858 ("" (subtype-tcc) nil nil) proved nil 83 90 nil nil)) (div_cancel 0 (div_cancel-1 nil 3249114884 3249231902 ("" (use "N_size") (("" (skosimp*) (("" (case "bv2int[2*N]((BV!1 * DVD!1) / (BV!1 * DVS!1)) = bv2int[2*N](DVD!1 / DVS!1) AND
              bv2int[2*N]((BV!1 * DVD!1) // (BV!1 * DVS!1)) = bv2int[2*N](BV!1 * (DVD!1 // DVS!1))") (("1" (flatten) (("1" (rewrite "bv2int_inj") (("1" (rewrite "bv2int_inj") nil nil)) nil)) nil) ("2" (hide 5) (("2" (case "-exp2(2 * N - 1) < bv2int(BV!1) * bv2int(DVD!1 // DVS!1)
            AND bv2int(BV!1) * bv2int(DVD!1 // DVS!1) < exp2(2 * N - 1)") (("1" (lemma "divrem_uniqueness[2*N]") (("1" (inst - "BV!1 * DVD!1" "BV!1 * DVS!1" "bv2int(DVD!1/DVS!1)" "bv2int(BV!1) * bv2int(DVD!1//DVS!1)") (("1" (assert) (("1" (rewrite "bv2int_times") (("1" (rewrite "bv2int_times") (("1" (rewrite "bv2int_times") (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil) ("3" (flatten) (("3" (assert) nil nil)) nil) ("4" (flatten) (("4" (assert) (("4" (use "div_sgn[2*N]") (("4" (assert) (("4" (replace*) (("4" (flatten) (("4" (assert) (("4" (rewrite "neg_times_lt") (("4" (rewrite "pos_times_gt") (("4" (replace*) (("4" (iff) (("4" (split +) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (split +) (("1" (assert) (("1" (rewrite "both_sides_times_pos_ge2") nil nil)) nil) ("2" (assert) (("2" (rewrite "both_sides_times_neg_le2") nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (rewrite "both_sides_times_neg_ge2") nil nil)) nil) ("2" (assert) (("2" (rewrite "both_sides_times_pos_le2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (rewrite "both_sides_times_neg_ge2") nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "both_sides_times_pos_ge2") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (rewrite "both_sides_times_pos_le2") nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "both_sides_times_neg_le2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (assert) (("5" (use "div_sgn[2*N]") (("5" (replace*) (("5" (assert) (("5" (flatten) (("5" (assert) (("5" (rewrite "abs_mult") (("5" (rewrite "abs_mult") (("5" (replace*) (("5" (hide -1 -2 -3 2) (("5" (iff) (("5" (lemma "both_sides_times_pos_lt2") (("5" (inst - "abs(bv2int(BV!1))" "abs(bv2int(DVD!1))" "abs(bv2int(DVS!1))") (("1" (reduce) nil nil) ("2" (expand "abs" 1) (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (flatten) (("6" (assert) (("6" (use "div_sgn[2*N]") (("6" (replace*) (("6" (assert) (("6" (flatten) (("6" (replace*) (("6" (rewrite "pos_times_gt") (("6" (rewrite "neg_times_lt") (("6" (assert) (("6" (iff) (("6" (split +) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (split +) (("1" (assert) (("1" (lemma "both_sides_times_pos_ge2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "both_sides_times_neg_ge2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (lemma "both_sides_times_neg_ge2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "both_sides_times_pos_ge2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_pos_ge2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_neg_ge2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_neg_le2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_pos_le2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (use "rem_sgn[2*N]") (("7" (flatten) (("7" (assert) (("7" (rewrite "pos_times_ge") (("7" (rewrite "pos_times_gt") (("7" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("8" (flatten) (("8" (use "rem_sgn[2*N]") (("8" (rewrite "neg_times_lt") (("8" (rewrite "neg_times_le") (("8" (reduce) nil nil)) nil)) nil)) nil)) nil) ("9" (rewrite "abs_mult") (("9" (rewrite "abs_mult") (("9" (use "rem_below_dvs[2*N]") (("9" (assert) (("9" (rewrite "both_sides_times_pos_lt2") (("9" (expand "abs" 1) (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (use "divrem_eq[2*N]") (("10" (replace*) (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "rem_below_dvs[2*N]") (("2" (assert) (("2" (expand "abs") (("2" (case "bv2int(BV!1) > 0") (("1" (assert) (("1" (case "bv2int(DVS!1) > 0") (("1" (assert) (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_pos_lt2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "bv2int(DVS!1)") (("1" (assert) (("1" (lemma "both_sides_times_pos_gt2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVS!1)" "-bv2int(DVD!1//DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_pos_gt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "bv2int(DVS!1)") (("2" (assert) (("2" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) >= 0") (("1" (assert) nil nil) ("2" (rewrite "pos_times_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_pos_lt2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "bv2int(DVS!1)") (("1" (assert) (("1" (case " bv2int(BV!1) * bv2int(DVD!1 // DVS!1) <= 0") (("1" (assert) nil nil) ("2" (rewrite "neg_times_le") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_pos_lt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "bv2int(DVS!1)") (("2" (assert) (("2" (lemma "both_sides_times_pos_lt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(DVS!1) > 0") (("1" (assert) (("1" (lift-if -) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_neg_lt2") (("1" (inst - "bv2int(BV!1)" "-bv2int(DVD!1//DVS!1)" "bv2int(DVS!1)") (("1" (assert) (("1" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) >= 0") (("1" (assert) nil nil) ("2" (rewrite "pos_times_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_neg_lt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "bv2int(DVS!1)") (("2" (assert) (("2" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) <= 0") (("1" (assert) nil nil) ("2" (rewrite "neg_times_le") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if -) (("2" (split -) (("1" (flatten) (("1" (lemma "both_sides_times_neg_lt2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "bv2int(DVS!1)") (("1" (assert) (("1" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) >= 0") (("1" (assert) nil nil) ("2" (rewrite "pos_times_ge") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_neg_lt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "-bv2int(DVS!1)") (("2" (assert) (("2" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) <= 0") (("1" (assert) nil nil) ("2" (rewrite "neg_times_le") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((both_sides_times_pos_gt2 formula-decl nil real_props nil) (both_sides_times_neg_lt2 formula-decl nil real_props nil) (divrem_uniqueness formula-decl nil BitvectorTwoComplementDivision nil) (neg_times_lt formula-decl nil real_props nil) (both_sides_times_neg_le2 formula-decl nil real_props nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge2 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (both_sides_times_neg_ge2 formula-decl nil real_props nil) (pos_times_gt formula-decl nil real_props nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (abs_mult formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m}" real_defs nil) (BV!1 skolem-const-decl "bvec[2 * N]" BitvectorTwoComplementDivisionWidenNarrow nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (pos_times_ge formula-decl nil real_props nil) (rem_sgn formula-decl nil BitvectorTwoComplementDivision nil) (neg_times_le formula-decl nil real_props nil) (rem_below_dvs formula-decl nil BitvectorTwoComplementDivision nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (bv2int_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int_inj formula-decl nil bv_int nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivisionWidenNarrow nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivisionWidenNarrow nil)) 43739 20260 nil nil)))(bv_mult_div_rem)
