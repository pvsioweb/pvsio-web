(BitvectorMultiplication (IMP_BitvectorUtil_TCC1 0 (IMP_BitvectorUtil_TCC1-1 nil 3342224217 ("" (lemma "N_size") (("" (propax) nil nil)) nil) ((N_size formula-decl nil BitvectorMultiplication nil)) nil)) (times_rec_TCC1 0 (times_rec_TCC1-1 nil 3342224217 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (times_rec_TCC2 0 (times_rec_TCC2-1 nil 3342224217 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (times_rec_TCC3 0 (times_rec_TCC3-1 nil 3342224217 ("" (termination-tcc) nil nil) nil nil)) (times_rec_TCC4 0 (times_rec_TCC4-1 nil 3342224217 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (times_rec_TCC5 0 (times_rec_TCC5-1 nil 3342224217 ("" (termination-tcc) nil nil) nil nil)) (times_rec_zero_right 0 (times_rec_zero_right-1 nil 3342224295 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "times_rec" +) (("2" (inst?) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "bv_add_fill_F[N]") (("2" (inst - "left_shift(1, fill[N](FALSE))") (("2" (rewrite "bv_add_comm[N]") (("2" (replace -1) (("2" (hide -1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((right_shift const-decl "bvec[N]" bv_shift nil) (left_shift const-decl "bvec[N]" bv_shift nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv_add_comm formula-decl nil bv_arith_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (times_rec_zero_left 0 (times_rec_zero_left-1 nil 3342224413 ("" (induct "n") (("1" (expand "times_rec") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (expand "times_rec" +) (("2" (expand "fill" 1 1) (("2" (case-replace "right_shift(1, fill[N](FALSE)) = fill[N](FALSE)") (("1" (inst?) (("1" (replace -2) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (left_shift const-decl "bvec[N]" bv_shift nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (right_shift const-decl "bvec[N]" bv_shift nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (times_rec_repeat 0 (times_rec_repeat-1 nil 3342224505 ("" (induct "n") (("1" (skosimp) (("1" (expand "exp2") (("1" (use "bv2nat_eq0[N]") (("1" (assert) (("1" (replace -1) (("1" (rewrite "times_rec_zero_left") (("1" (rewrite "times_rec_zero_left") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "times_rec" +) (("2" (inst - "right_shift(1, bv1!1)" "bv2!1" "m!1") (("2" (use "bv2nat_rightshift_upperbound") (("1" (expand "exp2" -1) (("1" (expand "exp2" -1) (("1" (expand "exp2" -3) (("1" (assert) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((right_shift const-decl "bvec[N]" bv_shift nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (fill const-decl "bit" bv nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (bv2nat_rightshift_upperbound formula-decl nil BitvectorUtil nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (times_rec_zero_left formula-decl nil BitvectorMultiplication nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (times_zero_first 0 (times_zero_first-1 nil 3342232363 ("" (skolem!) (("" (expand "*") (("" (rewrite "times_rec_zero_left") nil nil)) nil)) nil) ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_zero_left formula-decl nil BitvectorMultiplication nil)) shostak)) (times_zero_second 0 (times_zero_second-1 nil 3342232416 ("" (skolem!) (("" (expand "*") (("" (rewrite "times_rec_zero_right") nil nil)) nil)) nil) ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_zero_right formula-decl nil BitvectorMultiplication nil)) shostak)) (times_rec_inc_right_TCC1 0 (times_rec_inc_right_TCC1-1 nil 3342224217 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil)) nil)) (times_rec_inc_right_TCC2 0 (times_rec_inc_right_TCC2-1 nil 3342224217 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (times_rec_inc_right_TCC3 0 (times_rec_inc_right_TCC3-1 nil 3342224217 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (times_rec_inc_right 0 (times_rec_inc_right-2 "" 3369457452 ("" (lemma "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (use "bv_add_fill_F[N]") (("1" (grind) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "times_rec" +) (("2" (inst - "right_shift(1, bv1!1)" "bv2!1") (("2" (assert) (("2" (lift-if -) (("2" (ground) (("1" (use "bv_add_fill_F[N]") (("1" (replace -1) (("1" (replace -3) (("1" (hide -1 -3) (("1" (lift-if) (("1" (ground) (("1" (replace*) (("1" (name-replace "tmp" "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, 0))") (("1" (lemma "bv_add_two_consts[N]") (("1" (inst - "bv2!1" "tmp" 1 0) (("1" (lemma "bv_plus0[N]") (("1" (inst - "tmp" 0) (("1" (replace -1) (("1" (assert) (("1" (replace -2) (("1" (hide -1 -2 -5) (("1" (lemma "bv2nat_elim[N]") (("1" (expand* "o" "^" "fill") (("1" (assert) (("1" (inst - "bv2!1 + tmp" "LAMBDA (nm: below(N - 1 - jb!1 + (1 + jb!1))): IF nm < 1 + jb!1 THEN TRUE ELSE FALSE ENDIF") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (case-replace "bv2nat((LAMBDA (nm: below(N - 1 - jb!1 + (1 + jb!1))): IF nm < 1 + jb!1 THEN TRUE ELSE FALSE ENDIF)) = 1") (("1" (hide 2) (("1" (use "bv2nat_lem_rule") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (expand* "b2n" "^") (("1" (lemma "bv2nat_fill_F[N - 1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand* "o" "^" "fill") (("2" (lemma "bv_add_fill_F[N]") (("2" (inst - "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, 0))") (("2" (expand "fill") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (lift-if) (("2" (ground) (("1" (rewrite "leftshift1_add") (("1" (lemma "bv_add_two_consts[N]") (("1" (inst - "bv2!1" "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, jb!1)) + left_shift(1, (fill[N - jb!1](FALSE) o right_shift(1, bv1!1) ^ (jb!1 - 1, 0)))" 1 0) (("1" (assert) (("1" (lemma "bv_plus0[N]") (("1" (inst - "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, jb!1)) + left_shift(1, (fill[N - jb!1](FALSE) o right_shift(1, bv1!1) ^ (jb!1 - 1, 0)))" 0) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (rewrite "bv_add_assoc[N]") (("1" (rewrite "bv_add_const_assoc[N]" :dir rl) (("1" (case-replace "left_shift(1, (fill[N - jb!1](FALSE) o right_shift(1, bv1!1) ^ (jb!1 - 1, 0))) + 1 = fill[N - 1 - jb!1](FALSE) o bv1!1 ^ (jb!1, 0)") (("1" (hide 2) (("1" (case "FORALL (b: bvec[N]): NOT b(0) IMPLIES b + 1 = LAMBDA (i: below(N)): i = 0 OR b(i)") (("1" (grind-with-ext) nil nil) ("2" (hide-all-but 1) (("2" (skosimp) (("2" (use "bv2nat_inj[N]") (("2" (assert) (("2" (hide 3) (("2" (case-replace "bv2nat[N](b!1 + 1) = bv2nat[N](b!1) + 1") (("1" (hide -1) (("1" (expand "bv2nat") (("1" (case "FORALL (n: below(N+1)): n > 0 IMPLIES 1 + bv2nat_rec(n, b!1) = bv2nat_rec(n, LAMBDA (i: below(N)): i = 0 OR b!1(i))") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (skosimp) (("2" (case-replace "jb!2 = 0") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "bv2nat_rec" +) (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "b!1 + 1") (("2" (typepred "mod(1 + bv2nat(b!1), exp2(N))") (("2" (case "bv2nat(b!1) < exp2(N) - 1") (("1" (expand "mod") (("1" (assert) (("1" (case "(1 + bv2nat(b!1)) / exp2(N) < 1") (("1" (assert) nil nil) ("2" (use "div_mult_pos_lt1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (typepred "bv2nat(b!1)") (("2" (rewrite "bv2nat_eq_max") (("2" (expand "fill") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "leftshift1_add") (("2" (case-replace "left_shift(1, (fill[N - jb!1](FALSE) o right_shift(1, bv1!1) ^ (jb!1 - 1, 0))) = (fill[N - 1 - jb!1](FALSE) o bv1!1 ^ (jb!1, 0))") (("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil) ((nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (right_shift const-decl "bvec[N]" bv_shift nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (leftshift1_add formula-decl nil BitvectorUtil nil) (bv_add_const_assoc formula-decl nil bv_arith_nat nil) (bv2nat_inj formula-decl nil bv_nat nil) (nil application-judgement "below(m)" mod nil) (bv2nat_eq_max formula-decl nil bv_nat nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (bv2nat_rec def-decl "nat" bv_nat nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bv_add_assoc formula-decl nil bv_arith_nat nil) (int_plus_int_is_int application-judgement "int" integers nil) (bv_add_two_consts formula-decl nil bv_arith_nat nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (bv2nat_lem_rule formula-decl nil bv_arith_nat_caret_rules nil) (above nonempty-type-eq-decl nil integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (TRUE const-decl "bool" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (left_shift const-decl "bvec[N]" bv_shift nil) (N_size formula-decl nil BitvectorMultiplication nil)) shostak) (times_rec_inc_right-1 nil 3342232445 ("" (lemma "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (use "bv_add_fill_F[N]") (("1" (grind) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "times_rec" +) (("2" (inst - "right_shift(1, bv1!1)" "bv2!1") (("2" (assert) (("2" (lift-if -) (("2" (ground) (("1" (use "bv_add_fill_F[N]") (("1" (replace -1) (("1" (replace -3) (("1" (hide -1 -3) (("1" (lift-if) (("1" (ground) (("1" (replace*) (("1" (name-replace "tmp" "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, 0))") (("1" (lemma "bv_add_two_consts[N]") (("1" (inst - "bv2!1" "tmp" 1 0) (("1" (lemma "bv_plus0[N]") (("1" (inst - "tmp" 0) (("1" (replace -1) (("1" (assert) (("1" (replace -2) (("1" (hide -1 -2 -5) (("1" (lemma "bv2nat_elim[N]") (("1" (expand* "o" "^" "fill") (("1" (assert) (("1" (inst - "bv2!1 + tmp" "LAMBDA (nm: below(N - 1 - jb!1 + (1 + jb!1))): IF nm < 1 + jb!1 THEN TRUE ELSE FALSE ENDIF") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (case-replace "bv2nat((LAMBDA (nm: below(N - 1 - jb!1 + (1 + jb!1))): IF nm < 1 + jb!1 THEN TRUE ELSE FALSE ENDIF)) = 1") (("1" (hide 2) (("1" (use "bv2nat_lem_rule") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (expand* "b2n" "^") (("1" (lemma "bv2nat_fill_F[N - 1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand* "o" "^" "fill") (("2" (lemma "bv_add_fill_F[N]") (("2" (inst - "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, 0))") (("2" (expand "fill") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (lift-if) (("2" (ground) (("1" (rewrite "leftshift1_add") (("1" (lemma "bv_add_two_consts[N]") (("1" (inst - "bv2!1" "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, jb!1)) + left_shift(1, (fill[N - jb!1](FALSE) o right_shift(1, bv1!1) ^ (jb!1 - 1, 0)))" 1 0) (("1" (assert) (("1" (lemma "bv_plus0[N]") (("1" (inst - "left_shift(1, times_rec(right_shift(1, bv1!1), bv2!1, jb!1)) + left_shift(1, (fill[N - jb!1](FALSE) o right_shift(1, bv1!1) ^ (jb!1 - 1, 0)))" 0) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (rewrite "bv_add_assoc") (("1" (rewrite "bv_add_const_assoc" :dir rl) (("1" (case-replace "left_shift(1, (fill[N - jb!1](FALSE) o right_shift(1, bv1!1) ^ (jb!1 - 1, 0))) + 1 = fill[N - 1 - jb!1](FALSE) o bv1!1 ^ (jb!1, 0)") (("1" (hide 2) (("1" (case "FORALL (b: bvec[N]): NOT b(0) IMPLIES b + 1 = LAMBDA (i: below(N)): i = 0 OR b(i)") (("1" (grind-with-ext) nil nil) ("2" (hide-all-but 1) (("2" (skosimp) (("2" (use "bv2nat_inj[N]") (("2" (assert) (("2" (hide 3) (("2" (case-replace "bv2nat[N](b!1 + 1) = bv2nat[N](b!1) + 1") (("1" (hide -1) (("1" (expand "bv2nat") (("1" (case "FORALL (n: below(N+1)): n > 0 IMPLIES 1 + bv2nat_rec(n, b!1) = bv2nat_rec(n, LAMBDA (i: below(N)): i = 0 OR b!1(i))") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (skosimp) (("2" (case-replace "jb!2 = 0") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "bv2nat_rec" +) (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "b!1 + 1") (("2" (typepred "mod(1 + bv2nat(b!1), exp2(N))") (("2" (case "bv2nat(b!1) < exp2(N) - 1") (("1" (expand "mod") (("1" (assert) (("1" (case "(1 + bv2nat(b!1)) / exp2(N) < 1") (("1" (assert) nil nil) ("2" (use "div_mult_pos_lt1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (typepred "bv2nat(b!1)") (("2" (rewrite "bv2nat_eq_max") (("2" (expand "fill") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "leftshift1_add") (("2" (case-replace "left_shift(1, (fill[N - jb!1](FALSE) o right_shift(1, bv1!1) ^ (jb!1 - 1, 0))) = (fill[N - 1 - jb!1](FALSE) o bv1!1 ^ (jb!1, 0))") (("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil) ((nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (right_shift const-decl "bvec[N]" bv_shift nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (leftshift1_add formula-decl nil BitvectorUtil nil) (bv_add_const_assoc formula-decl nil bv_arith_nat nil) (bv2nat_inj formula-decl nil bv_nat nil) (nil application-judgement "below(m)" mod nil) (bv2nat_eq_max formula-decl nil bv_nat nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (bv2nat_rec def-decl "nat" bv_nat nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bv_add_assoc formula-decl nil bv_arith_nat nil) (int_plus_int_is_int application-judgement "int" integers nil) (bv_add_two_consts formula-decl nil bv_arith_nat nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (bv2nat_lem_rule formula-decl nil bv_arith_nat_caret_rules nil) (above nonempty-type-eq-decl nil integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (TRUE const-decl "bool" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (left_shift const-decl "bvec[N]" bv_shift nil) (N_size formula-decl nil BitvectorMultiplication nil)) shostak)) (times_rec_max_inc_right 0 (times_rec_max_inc_right-1 nil 3342293972 ("" (lemma "N_size") (("" (skolem!) (("" (rewrite "times_rec_inc_right") (("" (assert) (("" (expand "o") (("" (case-replace "(LAMBDA (nm: below(0 + N)): (bv1!1 ^ (N - 1, 0))(nm)) = bv1!1") (("" (hide 2) (("" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_inc_right formula-decl nil BitvectorMultiplication nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (N_size formula-decl nil BitvectorMultiplication nil)) shostak)) (times_rec_max_inc_n_right 0 (times_rec_max_inc_n_right-2 "" 3369457858 ("" (induct "n") (("1" (skolem!) (("1" (expand "iterate") (("1" (rewrite "bv_plus0[N]") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (lemma "times_rec_max_inc_right") (("2" (inst - "bv1!1" "bv2!1 + j!1") (("2" (rewrite "bv_add_2_consts[N]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((times_rec_max_inc_right formula-decl nil BitvectorMultiplication nil) (bv_add_2_consts formula-decl nil bv_arith_nat nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (iterate def-decl "T" function_iterate nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak) (times_rec_max_inc_n_right-1 nil 3342294096 ("" (induct "n") (("1" (skolem!) (("1" (expand "iterate") (("1" (rewrite "bv_plus0[N]") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (lemma "times_rec_max_inc_right") (("2" (inst - "bv1!1" "bv2!1 + j!1") (("2" (rewrite "bv_add_2_consts") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((times_rec_max_inc_right formula-decl nil BitvectorMultiplication nil) (bv_add_2_consts formula-decl nil bv_arith_nat nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (iterate def-decl "T" function_iterate nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (times_rec_iterate 0 (times_rec_iterate-2 "" 3369457909 ("" (skolem!) (("" (lemma "bv2nat_elim[N]") (("" (inst - "fill[N](FALSE)" "bv2!1") (("" (lemma "bv_add_fill_F[N]") (("" (inst - "bv2!1") (("" (rewrite "bv_add_comm[N]") (("" (replace -1) (("" (replace -2 * rl) (("" (hide -1 -2) (("" (rewrite "times_rec_max_inc_n_right") (("" (rewrite "times_rec_zero_right") (("" (case-replace "bv2nat(fill[N](FALSE) + bv2nat(bv2!1)) = bv2nat(bv2!1)") (("" (hide 2) (("" (use "bv_fill_F_plus[N]") (("" (expand "mod") (("" (assert) (("" (hide -1) (("" (typepred "floor(bv2nat(bv2!1) / exp2(N))") (("" (use "div_mult_pos_lt1" ("x" 1)) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (bv_add_comm formula-decl nil bv_arith_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (times_rec_max_inc_n_right formula-decl nil BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (bv_fill_F_plus formula-decl nil bv_arith_nat nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (times_rec_zero_right formula-decl nil BitvectorMultiplication nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak) (times_rec_iterate-1 nil 3342294318 ("" (skolem!) (("" (lemma "bv2nat_elim[N]") (("" (inst - "fill[N](FALSE)" "bv2!1") (("" (lemma "bv_add_fill_F[N]") (("" (inst - "bv2!1") (("" (rewrite "bv_add_comm") (("" (replace -1) (("" (replace -2 * rl) (("" (hide -1 -2) (("" (rewrite "times_rec_max_inc_n_right") (("" (rewrite "times_rec_zero_right") (("" (case-replace "bv2nat(fill[N](FALSE) + bv2nat(bv2!1)) = bv2nat(bv2!1)") (("" (hide 2) (("" (use "bv_fill_F_plus[N]") (("" (expand "mod") (("" (assert) (("" (hide -1) (("" (typepred "floor(bv2nat(bv2!1) / exp2(N))") (("" (use "div_mult_pos_lt1" ("x" 1)) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (bv_add_comm formula-decl nil bv_arith_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (times_rec_max_inc_n_right formula-decl nil BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (bv_fill_F_plus formula-decl nil bv_arith_nat nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (times_rec_zero_right formula-decl nil BitvectorMultiplication nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak)) (bv2nat_iterate 0 (bv2nat_iterate-1 nil 3342295121 ("" (induct "n") (("1" (skosimp) (("1" (expand "iterate") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (assert) (("2" (rewrite "bv_add[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv_add formula-decl nil bv_arith_nat nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) shostak)) (bv2int_iterate_TCC1 0 (bv2int_iterate_TCC1-1 nil 3342224217 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (bv2int_iterate 0 (bv2int_iterate-1 nil 3342295187 ("" (induct "n") (("1" (skosimp) (("1" (expand "iterate") (("1" (rewrite "bv2int_fill_F[N]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (ground) (("1" (rewrite "bv2int_add[N]") (("1" (assert) nil nil) ("2" (expand* "in_rng_2s_comp" "minint" "maxint") (("2" (assert) nil nil)) nil)) nil) ("2" (use "pos_times_ge") (("2" (assert) nil nil)) nil) ("3" (use "neg_times_ge") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil) ((neg_times_ge formula-decl nil real_props nil) (pos_times_ge formula-decl nil real_props nil) (bv2int_add formula-decl nil bv_arithmetic nil) (in_rng_2s_comp const-decl "bool" bv_int_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (bv2int_fill_F formula-decl nil bv_int nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (iterate_inc 0 (iterate_inc-1 nil 3342295571 ("" (induct "n") (("1" (skolem!) (("1" (expand "iterate") (("1" (rewrite "bv_plus0[N]") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (replace -1) (("2" (hide -1) (("2" (use "bv_add_two_consts[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (bv_add_two_consts formula-decl nil bv_arith_nat nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nil application-judgement "above(n)" exp2 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (iterate_inc_m 0 (iterate_inc_m-1 nil 3342295650 ("" (induct "m") (("1" (skolem!) (("1" (assert) (("1" (lemma "bv_plus0[N]") (("1" (inst-cp - "iterate[bvec[N]](LAMBDA (b: bvec[N]): b + bv1!1, n!1)(fill[N](FALSE))" 0) (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "(LAMBDA (b: bvec[N]): b + (bv1!1 + 0)) = (LAMBDA (b: bvec[N]): b + bv1!1)") (("1" (hide 2) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (inst - "bv1!1 + 1" "n!1") (("2" (case-replace "(LAMBDA (b: bvec[N]): b + (bv1!1 + 1 + j!1)) = (LAMBDA (b: bvec[N]): b + (bv1!1 + (1 + j!1)))") (("1" (replace -2) (("1" (hide -1 -2) (("1" (rewrite "iterate_inc") (("1" (rewrite "bv_add_2_consts[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv_add_2_consts[N]") nil nil)) nil)) nil)) nil)) nil)) nil) ((iterate_inc formula-decl nil BitvectorMultiplication nil) (int_plus_int_is_int application-judgement "int" integers nil) (bv_add_2_consts formula-decl nil bv_arith_nat nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_rec def-decl "nat" bv_nat nil) (bv1!1 skolem-const-decl "bvec[N]" BitvectorMultiplication nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (iterate_modulo 0 (iterate_modulo-1 nil 3342295976 ("" (skolem!) (("" (lemma "iterate_inc_m") (("" (inst - "bv2!1" "i!1 * exp2(N)" "bv2nat(-bv2!1)") (("" (lemma "bv_plus_wrap[N]") (("" (inst - "iterate[bvec[N]](LAMBDA (b: bvec[N]): b + bv2!1, i!1 * exp2(N))(fill[N](FALSE))" "i!1 * bv2nat(-bv2!1)") (("" (replace -1) (("" (replace -2 + rl) (("" (hide -1 -2) (("" (rewrite "bv2nat_elim[N]") (("" (rewrite "plus_min_zero") (("" (case "FORALL (n: nat): fill[N](FALSE) = iterate[bvec[N]](LAMBDA (b: bvec[N]): b + fill[N](FALSE), n)(fill[N](FALSE))") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (skosimp) (("2" (expand "iterate" +) (("2" (rewrite "bv_add_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((iterate_inc_m formula-decl nil BitvectorMultiplication nil) (bv_plus_wrap formula-decl nil bv_arith_nat nil) (plus_min_zero formula-decl nil BitvectorUtil nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (iterate def-decl "T" function_iterate nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak)) (iterate_comm 0 (iterate_comm-1 nil 3342296153 ("" (lemma "bvec_induction") (("" (inst - "LAMBDA (bv2: bvec[N]): FORALL (bv1: bvec[N]): iterate[bvec[N]](LAMBDA (b: bvec[N]): b + bv1, bv2nat(bv2))(fill[N](FALSE)) = iterate[bvec[N]](LAMBDA (b: bvec[N]): b + bv2, bv2nat(bv1))(fill[N](FALSE))") (("" (split) (("1" (skolem!) (("1" (inst?) nil nil)) nil) ("2" (hide 2) (("2" (lemma "bvec_induction") (("2" (inst - "LAMBDA(bv1: bvec[N]): iterate[bvec[N]](LAMBDA (b: bvec[N]): b + bv1, bv2nat(fill[N](FALSE)))(fill[N](FALSE)) = iterate[bvec[N]](LAMBDA (b: bvec[N]): b + fill[N](FALSE), bv2nat(bv1))(fill[N](FALSE))") (("2" (ground) (("2" (hide 2) (("2" (skosimp) (("2" (rewrite "bv2nat_fill_F[N]") (("2" (expand "iterate" 1 1) (("2" (expand "iterate" -1 1) (("2" (rewrite "bv_plus1[N]") (("2" (lift-if) (("2" (ground) (("1" (expand "iterate") (("1" (propax) nil nil)) nil) ("2" (expand "iterate" +) (("2" (rewrite "bv_add_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (rewrite "bv_plus1[N]") (("3" (lift-if) (("3" (ground) (("1" (expand "iterate" 1 1) (("1" (replace -1) (("1" (lemma "iterate_inc") (("1" (inst - "bv!1" "bv2nat(bv1!1)") (("1" (replace -1) (("1" (hide -1) (("1" (inst - "bv1!1") (("1" (replace -2 * rl) (("1" (hide -2) (("1" (case-replace "iterate[bvec[N]](LAMBDA (b: bvec[N]): b + bv1!1, (exp2(N) - 1))(fill[N](FALSE)) + bv2nat(bv1!1) = iterate[bvec[N]](LAMBDA (b: bvec[N]): b + bv1!1, exp2(N))(fill[N](FALSE))") (("1" (hide -1 -2) (("1" (lemma "iterate_modulo") (("1" (inst - "bv1!1" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "iterate" 1 2) (("2" (rewrite "bv2nat_elim[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "iterate" 2 1) (("2" (inst - "bv1!1") (("2" (replace -1) (("2" (hide -1) (("2" (lemma "iterate_inc") (("2" (inst - "bv!1" "bv2nat(bv1!1)") (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "bv2nat_elim[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (iterate def-decl "T" function_iterate nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (iterate_modulo formula-decl nil BitvectorMultiplication nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (bv2nat_elim formula-decl nil bv_arith_nat nil) (iterate_inc formula-decl nil BitvectorMultiplication nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv_plus1 formula-decl nil bv_arith_nat nil) (nil application-judgement "above(n)" exp2 nil) (bvec_induction formula-decl nil BitvectorUtil nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil)) shostak)) (times_rec_comm 0 (times_rec_comm-1 nil 3342296596 ("" (skolem!) (("" (rewrite "times_rec_iterate") (("" (rewrite "times_rec_iterate") (("" (rewrite "iterate_comm") nil nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (times_rec_iterate formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (iterate_comm formula-decl nil BitvectorMultiplication nil)) shostak)) (times_comm 0 (times_comm-1 nil 3342296626 ("" (skolem!) (("" (expand "*") (("" (rewrite "times_rec_comm") nil nil)) nil)) nil) ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_comm formula-decl nil BitvectorMultiplication nil)) shostak)) (iterate_min_second 0 (iterate_min_second-1 nil 3342296683 ("" (induct "n") (("1" (skolem!) (("1" (expand "iterate") (("1" (rewrite "min_fill_F") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (rewrite "bv_neg_distribution") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((bv_neg_distribution formula-decl nil bv_arith_minus_rules nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (min_fill_F formula-decl nil BitvectorUtil nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (times_rec_min_first 0 (times_rec_min_first-1 nil 3342296807 ("" (skolem!) (("" (rewrite "times_rec_iterate") (("" (rewrite "times_rec_iterate") (("" (use "iterate_min_second") nil nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (times_rec_iterate formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (iterate_min_second formula-decl nil BitvectorMultiplication nil)) shostak)) (times_rec_min_second 0 (times_rec_min_second-1 nil 3342296837 ("" (skolem!) (("" (rewrite "times_rec_comm") (("" (rewrite "times_rec_min_first") (("" (rewrite "times_rec_comm") nil nil)) nil)) nil)) nil) ((times_rec_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (times_rec_min_first formula-decl nil BitvectorMultiplication nil)) shostak)) (times_min_first 0 (times_min_first-1 nil 3342296868 ("" (skolem!) (("" (expand "*") (("" (rewrite "times_rec_min_first") nil nil)) nil)) nil) ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_min_first formula-decl nil BitvectorMultiplication nil)) shostak)) (times_min_second 0 (times_min_second-1 nil 3342296895 ("" (skolem!) (("" (rewrite "times_comm") (("" (rewrite "times_min_first") (("" (rewrite "times_comm") nil nil)) nil)) nil)) nil) ((times_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (times_min_first formula-decl nil BitvectorMultiplication nil)) shostak)) (bv2nat_one 0 (bv2nat_one-1 nil 3342296929 ("" (lemma "N_size") (("" (assert) (("" (use "bv2nat_lem_rule") (("" (expand* "b2n" "^") (("" (expand "one" -1 1) (("" (expand "one" -1 1) (("" (lemma "bv2nat_fill_F[N - 1]") (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (b2n const-decl "nbit" bit nil) (fill const-decl "bit" bv nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (bv2nat_lem_rule formula-decl nil bv_arith_nat_caret_rules nil) (N_size formula-decl nil BitvectorMultiplication nil)) shostak)) (bv2int_one 0 (bv2int_one-1 nil 3342297054 ("" (lemma "N_size") (("" (auto-rewrite "bv2nat_one") (("" (expand "bv2int") (("" (reduce) nil nil)) nil)) nil)) nil) ((bv2nat_one formula-decl nil BitvectorMultiplication nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (N_size formula-decl nil BitvectorMultiplication nil)) shostak)) (times_one_first 0 (times_one_first-1 nil 3342297131 ("" (lemma "N_size") (("" (skolem!) (("" (expand* "*" "one" "times_rec") (("" (assert) (("" (case-replace "left_shift(1, times_rec(right_shift(1, (LAMBDA (k: below(N)): k = 0)), bv!1, N - 1)) = fill[N](FALSE)") (("1" (rewrite "bv_add_fill_F[N]") nil nil) ("2" (hide -1 2) (("2" (case-replace "right_shift(1, (LAMBDA (k: below(N)): k = 0)) = fill[N](FALSE)") (("1" (hide -1) (("1" (rewrite "times_rec_zero_left") (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (hide 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (times_rec_zero_left formula-decl nil BitvectorMultiplication nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (right_shift const-decl "bvec[N]" bv_shift nil) (left_shift const-decl "bvec[N]" bv_shift nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (times_rec def-decl "bvec[N]" BitvectorMultiplication nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (N_size formula-decl nil BitvectorMultiplication nil)) shostak)) (times_one_second 0 (times_one_second-1 nil 3342297264 ("" (skolem!) (("" (rewrite "times_comm") (("" (rewrite "times_one_first") nil nil)) nil)) nil) ((times_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (times_one_first formula-decl nil BitvectorMultiplication nil)) shostak)) (iterate_zero_add 0 (iterate_zero_add-2 "" 3369457970 ("" (induct "n") (("1" (skolem!) (("1" (expand "iterate") (("1" (rewrite "bv_add_comm[N]") (("1" (rewrite "bv_add_fill_F[N]") nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "bv_add_assoc[N]" :dir rl) (("2" (rewrite "bv_add_assoc[N]" :dir rl) (("2" (rewrite "bv_add_comm[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv_add_assoc formula-decl nil bv_arith_nat nil) (bv_add_comm formula-decl nil bv_arith_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak) (iterate_zero_add-1 nil 3342297295 ("" (induct "n") (("1" (skolem!) (("1" (expand "iterate") (("1" (rewrite "bv_add_comm") (("1" (rewrite "bv_add_fill_F[N]") nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "bv_add_assoc" :dir rl) (("2" (rewrite "bv_add_assoc" :dir rl) (("2" (rewrite "bv_add_comm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv_add_assoc formula-decl nil bv_arith_nat nil) (bv_add_comm formula-decl nil bv_arith_nat nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak)) (times_rec_distr 0 (times_rec_distr-1 nil 3342297371 ("" (skolem!) (("" (rewrite "times_rec_iterate") (("" (rewrite "times_rec_iterate") (("" (rewrite "times_rec_iterate") (("" (rewrite "bv_add[N]") (("" (lift-if) (("" (ground) (("1" (use "iterate_add[bvec[N]]") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (expand "o") (("1" (lemma "iterate_zero_add") (("1" (inst - "bv1!1" "(iterate(LAMBDA (b: bvec[N]): b + bv1!1, bv2nat(bv3!1))(fill[N](FALSE)))" "bv2nat(bv2!1)") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "iterate_add[bvec[N]]") (("2" (inst-cp - "LAMBDA (b: bvec[N]): b + bv1!1" "bv2nat(bv2!1) + bv2nat(bv3!1) - exp2(N)" "exp2(N)") (("2" (assert) (("2" (decompose-equality) (("2" (expand "o" -1) (("2" (inst - "fill[N](FALSE)") (("2" (lemma "iterate_modulo") (("2" (inst - "bv1!1" 1) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (inst?) (("2" (replace -1 + rl) (("2" (hide -1) (("2" (expand "o") (("2" (lemma "iterate_zero_add") (("2" (inst - "bv1!1" "(iterate(LAMBDA (b: bvec[N]): b + bv1!1, bv2nat(bv3!1))(fill[N](FALSE)))" "bv2nat(bv2!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((times_rec_iterate formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (iterate_modulo formula-decl nil BitvectorMultiplication nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (iterate_add formula-decl nil function_iterate nil) (iterate_zero_add formula-decl nil BitvectorMultiplication nil) (iterate def-decl "T" function_iterate nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (O const-decl "T3" function_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bv_add formula-decl nil bv_arith_nat nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak)) (times_distr_right 0 (times_distr_right-1 nil 3342297606 ("" (skolem!) (("" (expand "*") (("" (rewrite "times_rec_distr") nil nil)) nil)) nil) ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_distr formula-decl nil BitvectorMultiplication nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak)) (times_distr_left 0 (times_distr_left-1 nil 3342297643 ("" (skolem!) (("" (rewrite "times_comm") (("" (rewrite "times_distr_right") (("" (rewrite "times_comm") (("" (case-replace "bv3!1 * bv2!1 = bv2!1 * bv3!1") (("" (rewrite "times_comm") nil nil)) nil)) nil)) nil)) nil)) nil) ((times_comm formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (times_distr_right formula-decl nil BitvectorMultiplication nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil)) shostak)) (times_distr_iterate 0 (times_distr_iterate-1 nil 3342297717 ("" (induct "n") (("1" (skolem!) (("1" (expand "iterate") (("1" (rewrite "times_zero_second") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "iterate" +) (("2" (inst?) (("2" (rewrite "times_distr_right") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((times_distr_right formula-decl nil BitvectorMultiplication nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (times_zero_second formula-decl nil BitvectorMultiplication nil) (nat_induction formula-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (iterate def-decl "T" function_iterate nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (times_assoc 0 (times_assoc-1 nil 3342297771 ("" (skolem!) (("" (expand "*" 1 4) (("" (rewrite "times_rec_iterate") (("" (rewrite "times_distr_iterate") (("" (expand "*" 1 2) (("" (rewrite "times_rec_iterate") nil nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "bvec[N]" BitvectorMultiplication nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (times_distr_iterate formula-decl nil BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorMultiplication nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (times_rec_iterate formula-decl nil BitvectorMultiplication nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak)))
