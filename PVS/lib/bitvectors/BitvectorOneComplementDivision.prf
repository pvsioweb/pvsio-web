(BitvectorOneComplementDivision (IMP_BitvectorMultiplication_TCC1 0 (IMP_BitvectorMultiplication_TCC1-1 nil 3342401097 ("" (lemma "N_size") (("" (propax) nil nil)) nil) ((N_size formula-decl nil BitvectorOneComplementDivision nil)) nil)) (divrem_TCC1 0 (divrem_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (divrem_TCC2 0 (divrem_TCC2-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (divrem_TCC3 0 (divrem_TCC3-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil)) (divrem_TCC4 0 (divrem_TCC4-1 nil 3342401097 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (divrem_TCC5 0 (divrem_TCC5-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil)) (divrem_TCC6 0 (divrem_TCC6-1 nil 3342401097 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (divrem_TCC7 0 (divrem_TCC7-1 nil 3510509895 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (divrem_dvd_TCC1 0 (divrem_dvd_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) nil nil)) (divrem_dvd_TCC2 0 (divrem_dvd_TCC2-1 nil 3342401097 ("" (subtype-tcc) nil nil) nil nil)) (divrem_dvd 0 (divrem_dvd-1 nil 3342401159 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "divrem" +) (("2" (lift-if) (("2" (ground) (("1" (inst?) (("1" (replace*) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst?) (("2" (replace*) (("2" (hide-all-but 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "bvec[N]" bv_arithmetic_defs nil) (TRUE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (divrem_dvs0_TCC1 0 (divrem_dvs0_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil)) (divrem_dvs0_TCC2 0 (divrem_dvs0_TCC2-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (divrem_dvs0 0 (divrem_dvs0-1 nil 3342401275 ("" (lemma "N_size") (("" (induct "n") (("1" (grind-with-ext) nil nil) ("2" (skosimp*) (("2" (expand "divrem" +) (("2" (rewrite "bv2nat_fill_F[N]") (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (inst?) (("2" (assert) (("2" (replace*) (("2" (hide -) (("2" (decompose-equality) (("1" (grind-with-ext) nil nil) ("2" (expand "-") (("2" (rewrite "bv_sub_identity_R") (("2" (grind-with-ext) nil nil)) nil)) nil) ("3" (reduce) nil nil) ("4" (reduce) nil nil) ("5" (reduce) nil nil) ("6" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reduce) nil nil) ("4" (reduce) nil nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (TRUE const-decl "bool" booleans nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (bv_sub_identity_R formula-decl nil bv_arith_minus_rules nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (left_shift const-decl "bvec[N]" bv_shift nil) (- const-decl "bvec[N]" bv_arithmetic_defs nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (bv2nat_left_false_inc 0 (bv2nat_left_false_inc-1 nil 3342401631 ("" (lemma "N_size") (("" (skolem!) (("" (case-replace "n!1 = 0") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "bv2nat_lem") (("1" (inst - "N" "LAMBDA (i: below(N)): IF i < 1 THEN bv!1(i) ELSE FALSE ENDIF") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (expand* "^" "exp2") (("1" (lemma "bv2nat_fill_F[N - 1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "n!1 - 1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case-replace "sigma(n!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (hide -1) (("1" (case-replace "n!1 = N - 1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (use "sigma_restrict_eq") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + n!1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "n!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (case-replace "sigma(1 + n!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + n!1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (hide -1) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (use "sigma_restrict_eq") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (use "sigma_mult" ("x" 0)) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + n!1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + n!1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)" "N - 1" "1 + n!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "sigma_mult" ("x" 0)) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)" "N - 1" "n!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_split formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (restrict const-decl "[nat -> nat]" sums nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (extend const-decl "[nat -> nat]" bv_sum nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (fill const-decl "bit" bv nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (FALSE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (above nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (even_times_int_is_even application-judgement "even_int" integers nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (nil application-judgement "above(n)" exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (bv2nat_right_false_inc 0 (bv2nat_right_false_inc-1 nil 3342402227 ("" (lemma "N_size") (("" (skolem!) (("" (rewrite "bv2nat_as_sum[N]") (("" (rewrite "bv2nat_as_sum[N]") (("" (case-replace "n!1 = 0") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst-cp - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "N - 1" 0 0) (("1" (assert) (("1" (expand "sigma" -2 2) (("1" (expand "extend" -2 2) (("1" (replace -2) (("1" (hide -2) (("1" (assert) (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "N - 1" 0 0) (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "b2n" -1 5) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (use "sigma_restrict_eq") (("1" (assert) (("1" (hide 2) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "N - 1" 0 "n!1 - 1") (("1" (assert) (("1" (case-replace "sigma(0, n!1 - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)) = 0") (("1" (replace*) (("1" (hide -1 -2) (("1" (assert) (("1" (case-replace "n!1 = N - 1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (use "sigma_mult" ("x" 0)) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))" "N - 1" 0) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "N - 1" 0 "n!1") (("2" (assert) (("2" (case-replace "sigma(0, n!1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)) = 0") (("1" (replace*) (("1" (hide -1 -2) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "N - 1" "n!1" "n!1") (("1" (assert) (("1" (expand "sigma" -1 3) (("1" (expand "extend" -1 2) (("1" (replace -1) (("1" (assert) (("1" (hide -1) (("1" (use "sigma_restrict_eq") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (use "sigma_mult" ("x" 0)) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "n!1" 0) (("2" (assert) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (use "sigma_mult" ("x" 0)) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < n!1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "n!1 - 1" 0) (("2" (assert) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (sigma_mult formula-decl nil sums nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma def-decl "nat" sums nil) (restrict const-decl "[nat -> nat]" sums nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_restrict_eq formula-decl nil sums nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_split formula-decl nil sums nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FALSE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (bv2nat_left_false_dec_TCC1 0 (bv2nat_left_false_dec_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil)) (bv2nat_left_false_dec_TCC2 0 (bv2nat_left_false_dec_TCC2-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (bv2nat_left_false_dec_TCC3 0 (bv2nat_left_false_dec_TCC3-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (bv2nat_left_false_dec_TCC4 0 (bv2nat_left_false_dec_TCC4-1 nil 3342401097 ("" (subtype-tcc) nil nil) nil nil)) (bv2nat_left_false_dec 0 (bv2nat_left_false_dec-1 nil 3342402844 ("" (lemma "N_size") (("" (skolem!) (("" (case-replace "n!1 = N - 1") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "bv2nat_lem") (("1" (inst - "N" "LAMBDA (i: below(N)): IF i < 1 THEN bv!1(i - 1 + N) ELSE FALSE ENDIF") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (expand* "^" "exp2") (("1" (lemma "bv2nat_fill_F[N - 1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (case-replace "n!1 = 0") (("1" (assert) (("1" (expand "sigma") (("1" (expand "extend" 2 1) (("1" (expand "extend" 2 2) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 THEN b2n(bv!1(ii)) ELSE b2n(FALSE) ENDIF)" "N - 2" 0) (("1" (expand "b2n") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "N - n!1 - 1") (("1" (assert) (("1" (case-replace "sigma(N - n!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "N - 2 - n!1") (("1" (assert) (("1" (case-replace "sigma(N - 1 - n!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)" "N - 2 - n!1" 0) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (use "sigma_mult" ("x" 0)) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" "N - 1 - n!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (use "sigma_mult" ("x" 0)) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" "N - n!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((bv2nat_as_sum formula-decl nil bv_sum nil) (sigma def-decl "nat" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (extend const-decl "[nat -> nat]" bv_sum nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sigma_mult formula-decl nil sums nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma_split formula-decl nil sums nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (fill const-decl "bit" bv nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (above nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (bv2nat_split_TCC1 0 (bv2nat_split_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (bv2nat_split 0 (bv2nat_split-1 nil 3342441614 ("" (lemma "N_size") (("" (skolem!) (("" (case-replace "m!1 = 0") (("1" (assert) (("1" (expand "exp2") (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "m!1 = N") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (assert) (("1" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (lemma "sigma_split") (("1" (inst-cp - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < m!1 THEN b2n(bv1!1(ii+N-m!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "m!1 - 1") (("1" (assert) (("1" (case-replace "sigma(m!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < m!1 THEN b2n(bv1!1(ii+N-m!1)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (replace -3) (("1" (hide -1 -3) (("1" (inst-cp - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - m!1 THEN b2n(bv2!1(ii)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "N - m!1 - 1") (("1" (assert) (("1" (case-replace "sigma(N - m!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - m!1 THEN b2n(bv2!1(ii)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (replace -3) (("1" (hide -1 -3) (("1" (lemma "sigma_mult") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - m!1 THEN b2n(bv2!1(ii)) ELSE b2n(FALSE) ENDIF)" "N - 1 - m!1" 0 "exp2(m!1)") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < m!1 THEN b2n(bv1!1(ii + N - m!1)) ELSE b2n(bv2!1(ii - m!1)) ENDIF)" "N - 1" 0 "m!1 - 1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < m!1 THEN b2n(bv1!1(ii + N - m!1)) ELSE b2n(bv2!1(ii - m!1)) ENDIF)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < m!1 THEN b2n(bv1!1(ii + N - m!1)) ELSE b2n(FALSE) ENDIF)" "m!1 - 1" 0) (("1" (split) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < m!1 THEN b2n(bv1!1(ii + N - m!1)) ELSE b2n(bv2!1(ii - m!1)) ENDIF)" "N - 1 - m!1" 0 "m!1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (use "sigma_restrict_eq") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) (("1" (lemma "exp2_sum") (("1" (inst - "m!1 - 1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reduce) nil nil) ("3" (reduce) nil nil)) nil)) nil)) nil) ("2" (reduce) nil nil) ("3" (reduce) nil nil)) nil)) nil)) nil)) nil) ("2" (reduce) nil nil) ("3" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (reduce) nil nil) ("3" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reduce) nil nil) ("3" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 4) (("2" (use "sigma_mult" ("x" 0)) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - m!1 THEN b2n(bv2!1(ii)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - m!1 THEN b2n(bv2!1(ii)) ELSE b2n(FALSE) ENDIF)" "N - 1" "N - m!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 4) (("2" (use "sigma_mult" ("x" 0)) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < m!1 THEN b2n(bv1!1(ii+N-m!1)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < m!1 THEN b2n(bv1!1(ii+N-m!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" "m!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (reduce) nil nil)) nil)) nil) ("2" (reduce) nil nil)) nil)) nil) ("3" (reduce) nil nil)) nil)) nil) ("2" (reduce) nil nil)) nil)) nil)) nil) ("2" (reduce) nil nil)) nil)) nil) ("2" (reduce) nil nil) ("3" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ((m!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma def-decl "nat" sums nil) (sigma_mult formula-decl nil sums nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (exp2_sum formula-decl nil exp2 nil) (restrict const-decl "[nat -> nat]" sums nil) (int_plus_int_is_int application-judgement "int" integers nil) (sigma_shift formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_split formula-decl nil sums nil) (FALSE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (fill const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (bv2nat_left_false_minus_TCC1 0 (bv2nat_left_false_minus_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (bv2nat_left_false_minus 0 (bv2nat_left_false_minus-1 nil 3342443582 ("" (lemma "N_size") (("" (skolem!) (("" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 0) (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "exp2" -1 3) (("1" (replace -1) (("1" (hide -1) (("1" (use "sigma_mult") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (expand "sigma" 1 2) (("1" (expand "extend" 1 2) (("1" (expand "b2n" 1 7) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)" "N - 2" 0 1) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - n!1 THEN b2n(bv!1(ii + n!1)) ELSE b2n(FALSE) ENDIF)(1 + n)" "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - n!1 THEN b2n(bv!1(1 + ii + n!1)) ELSE b2n(FALSE) ENDIF)(n)" "N - 2" 0) (("1" (assert) (("1" (hide 2) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (reduce) nil nil) ("3" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reduce) nil nil)) nil)) nil)) nil) ("2" (reduce) nil nil)) nil) ("2" (reduce) nil nil)) nil)) nil)) nil) ((sigma_split formula-decl nil sums nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (sigma_mult formula-decl nil sums nil) (sigma_shift formula-decl nil sums nil) (int_plus_int_is_int application-judgement "int" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (restrict const-decl "[nat -> nat]" sums nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (extend const-decl "[nat -> nat]" bv_sum nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FALSE const-decl "bool" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (bv2nat_leftshift_exp_TCC1 0 (bv2nat_leftshift_exp_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (bv2nat_leftshift_exp 0 (bv2nat_leftshift_exp-1 nil 3342443834 ("" (lemma "N_size") (("" (skolem!) (("" (rewrite "bv2nat_as_sum[N]") (("" (assert) (("" (rewrite "bv2nat_as_sum[N]") (("" (expand "sigma" 1 1) (("" (expand "extend" 1 1) (("" (lemma "sigma_split") (("" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(1, bv!1)(ii)))" "N - 1" 0 0) (("" (assert) (("" (expand "sigma" -1 2) (("" (expand "extend" -1 2) (("" (expand "left_shift" -1 3) (("" (expand* "^" "o" "fill") (("" (expand "b2n" -1 3) (("" (replace -1) (("" (hide -1) (("" (lemma "sigma_shift") (("" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(1, bv!1)(ii)))" "N - 2" 0 1) (("" (assert) (("" (replace -1) (("" (hide -1) (("" (case-replace "sigma(0, N - 2, LAMBDA (n: nat): extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(1, bv!1)(ii)))(1 + n)) = 2 * sigma(0, N - 2, extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii))))") (("1" (rewrite "times_div1" :dir rl) nil nil) ("2" (hide 2) (("2" (use "sigma_mult") (("2" (replace -1 * rl) (("2" (hide -1) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat): extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(1, bv!1)(ii)))(1 + n)" "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "N - 2" 0) (("2" (assert) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rat_plus_rat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma def-decl "nat" sums nil) (sigma_split formula-decl nil sums nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (fill const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (sigma_shift formula-decl nil sums nil) (int_plus_int_is_int application-judgement "int" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sigma_restrict_eq formula-decl nil sums nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (restrict const-decl "[nat -> nat]" sums nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma_mult formula-decl nil sums nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (times_div1 formula-decl nil real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (extend const-decl "[nat -> nat]" bv_sum nil) (left_shift const-decl "bvec[N]" bv_shift nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (divrem_mem_TCC1 0 (divrem_mem_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (left_shift const-decl "bvec[N]" bv_shift nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (divrem_mem_TCC2 0 (divrem_mem_TCC2-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (left_shift const-decl "bvec[N]" bv_shift nil)) nil)) (divrem_mem_TCC3 0 (divrem_mem_TCC3-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (left_shift const-decl "bvec[N]" bv_shift nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (divrem_mem_TCC4 0 (divrem_mem_TCC4-1 nil 3342401097 ("" (termination-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (left_shift const-decl "bvec[N]" bv_shift nil)) nil)) (divrem_mem_first_second_third 0 (divrem_mem_first_second_third-1 nil 3342444107 ("" (lemma "N_size") (("" (assert) (("" (induct "n") (("1" (grind-with-ext) nil nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (expand "divrem" +) (("2" (case-replace "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i) ELSE FALSE ENDIF) = (left_shift(1, LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF) WITH [(0) := quot!1(N - 1)])") (("1" (hide -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (inst - "left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]" "dvs!1" "left_shift(1, quot!1) WITH [(0) := TRUE]" "(left_shift(1, LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF) WITH [(0) := quot!1(N - 1)]) - dvs!1") (("1" (assert) (("1" (flatten) (("1" (case-replace "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN ((left_shift(1, LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF) WITH [(0) := quot!1(N - 1)]) - dvs!1)(i) ELSE FALSE ENDIF) = left_shift(1, LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF) WITH [(0) := quot!1(N - 1)] - dvs!1") (("1" (assert) (("1" (replace*) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 2) (("2" (name-replace "ls" "(left_shift(1, LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF) WITH [(0) := quot!1(N - 1)])") (("2" (case "bv2nat[N](LAMBDA (i: below(N)): IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF) = bv2nat[N](ls - dvs!1)") (("1" (rewrite "bv2nat_inj[N]") nil nil) ("2" (hide 2) (("2" (rewrite "bv2nat_minus3") (("2" (case-replace "bv2nat[N](ls) = bv2nat[N - jb!1](ls ^ (N - jb!1 - 1, 0))") (("1" (hide -1) (("1" (case-replace "bv2nat[N](dvs!1) = bv2nat[N - jb!1](dvs!1 ^ (N - jb!1 - 1, 0))") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF) = (fill[jb!1](FALSE) o ((ls - dvs!1) ^ (N - 1 - jb!1, 0)))") (("1" (hide -1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) (("1" (lemma "bv2nat_minus3") (("1" (expand "-") (("1" (rewrite "bv_add_subrange") (("1" (rewrite "bv_caret_negate") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "dvs!1 = (fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0)))") (("1" (case "bv2nat[N](dvs!1) = bv2nat[N](fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0)))") (("1" (replace -1 +) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case-replace "jb!1 = 0") (("1" (grind-with-ext) nil nil) ("2" (assert) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst - "dvs!1" "N - jb!1") (("2" (assert) (("2" (apply-extensionality 2 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "bv2nat_concat") (("2" (inst - "N - jb!1" "jb!1" "fill[jb!1](FALSE)" "ls ^ (N - jb!1 - 1, 0)") (("2" (rewrite "bv2nat_fill_F") (("2" (assert) (("2" (case "ls = fill[jb!1](FALSE) o (ls ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "ls") (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst - "left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]" "dvs!1" "left_shift(1, quot!1)" "left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]") (("2" (flatten) (("2" (assert) (("2" (case-replace "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i) ELSE FALSE ENDIF) = left_shift(1, LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF) WITH [(0) := quot!1(N - 1)]") (("1" (assert) (("1" (replace*) (("1" (hide-all-but 2) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (nil application-judgement "above(n)" exp2 nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv_add_subrange formula-decl nil bv_arith_caret nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (ls skolem-const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_minus3 formula-decl nil DivisionUtil nil) (bv2nat_inj formula-decl nil bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (TRUE const-decl "bool" booleans nil) (- const-decl "bvec[N]" bv_arithmetic_defs nil) (left_shift const-decl "bvec[N]" bv_shift nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (FALSE const-decl "bool" booleans nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (divrem_mem_rem 0 (divrem_mem_rem-1 nil 3342830783 ("" (lemma "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (assert) (("1" (expand "divrem_mem") (("1" (case-replace "(LAMBDA (i: below(N)): rem!1(i)) = rem!1") (("1" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (name-replace "ls" "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN left_shift(1, rem!1) WITH [(0) := dvd!1(N - 1)](i) ELSE FALSE ENDIF)") (("1" (expand "<") (("1" (lemma "leftshift_with") (("1" (inst - "N" "(LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)" "dvd!1(N - 1)") (("1" (assert) (("1" (split) (("1" (case-replace "(left_shift(1, (LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)) WITH [(0) := dvd!1(N - 1)]) = ls") (("1" (hide -1) (("1" (case-replace "jb!1 = 0") (("1" (assert) (("1" (case-replace "(LAMBDA (i: below(N)): (ls - dvs!1)(i)) = ls - dvs!1") (("1" (rewrite "bv2nat_minus3") (("1" (assert) nil nil)) nil) ("2" (apply-extensionality) nil nil)) nil)) nil) ("2" (case "bv2nat[N](ls) < exp2(N - jb!1)") (("1" (assert) (("1" (lemma "bv2nat_upperbound_caret[N]") (("1" (inst-cp - "ls" "N - jb!1") (("1" (inst-cp - "dvs!1" "N - jb!1") (("1" (inst - "LAMBDA (i: below(N)): IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF" "N - jb!1") (("1" (assert) (("1" (split) (("1" (replace*) (("1" (case-replace "((LAMBDA (i: below(N)): IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF) ^ (N - 1 - jb!1, 0)) = (ls - dvs!1) ^ (N - 1 - jb!1, 0)") (("1" (expand "-") (("1" (rewrite "bv_add_caret") (("1" (rewrite "bv_caret_negate") (("1" (rewrite "-" :dir rl) (("1" (rewrite "bv2nat_minus3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 3) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 3) (("2" (assert) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp) (("2" (expand "ls") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "ls") (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (hide -1 -3 2) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst?) (("2" (expand "<") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" bv_arith_nat_defs nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "bvec[N]" bv_arithmetic_defs nil) (TRUE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (fill const-decl "bit" bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (int_plus_int_is_int application-judgement "int" integers nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_upperbound_caret formula-decl nil BitvectorUtil nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (below type-eq-decl nil nat_types nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv_add_caret formula-decl nil bv_arith_caret_rules nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (ls skolem-const-decl "[below(N) -> bit]" BitvectorOneComplementDivision nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bv2nat_minus3 formula-decl nil DivisionUtil nil) (nil application-judgement "above(n)" exp2 nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (leftshift_with formula-decl nil DivisionUtil nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (div_divrem_mem_TCC1 0 (div_divrem_mem_TCC1-1 nil 3342401097 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (div_divrem_mem 0 (div_divrem_mem-1 nil 3342833395 ("" (skolem!) (("" (expand "div") (("" (use "divrem_mem_first_second_third") (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (rem_divrem_mem 0 (rem_divrem_mem-1 nil 3342833434 ("" (skolem!) (("" (expand "rem") (("" (use "divrem_mem_first_second_third") (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (divrem_mem_invariant 0 (divrem_mem_invariant-1 nil 3342833469 ("" (lemma "N_size") (("" (assert) (("" (induct "n") (("1" (skosimp*) (("1" (expand "divrem_mem") (("1" (assert) (("1" (case-replace "(LAMBDA (i: below(N)): aux!1(i)) = aux!1") (("1" (case-replace "(LAMBDA (i: below(N)): rem!1(i)) = rem!1") (("1" (case-replace "(LAMBDA (i: below(N)): quot!1(i)) = quot!1") (("1" (expand "exp2") (("1" (propax) nil nil)) nil) ("2" (apply-extensionality) nil nil)) nil) ("2" (apply-extensionality) nil nil)) nil) ("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (case-replace "(LAMBDA (i: below(N)): IF i < 1 + jb!1 THEN quot!1(i - 1 + N - jb!1) ELSE aux!1(i - 1 - jb!1) ENDIF) = (LAMBDA (i: below(N)): IF i < jb!1 THEN left_shift(1, quot!1)(i + N - jb!1) ELSE left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)](i - jb!1) ENDIF)") (("1" (replace -4) (("1" (hide -1 -4) (("1" (assert) (("1" (expand "exp2" 1 1) (("1" (case-replace "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN left_shift(1, quot!1) WITH [(0) := TRUE](i) ELSE FALSE ENDIF) = left_shift(1, (LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN quot!1(i) ELSE FALSE ENDIF)) WITH [(0) := TRUE]") (("1" (hide -1) (("1" (rewrite "leftshift_with" +) (("1" (assert) (("1" (expand "b2n") (("1" (lemma "bv2nat_split") (("1" (inst-cp - "quot!1" "rem!1" "1 + jb!1") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (inst - "left_shift(1, quot!1)" "left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)] - dvs!1" "jb!1") (("1" (hide -1) (("1" (expand "exp2" 1 1) (("1" (name-replace "lsrem" "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i) ELSE FALSE ENDIF)") (("1" (lemma "bv2nat_split") (("1" (inst - "left_shift(1, quot!1)" "lsrem - dvs!1" "jb!1") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (case-replace "bv2nat[N](LAMBDA (i: below(N)): IF i < N - jb!1 THEN (lsrem - dvs!1)(i) ELSE FALSE ENDIF) = bv2nat[N](lsrem) - bv2nat[N](dvs!1)") (("1" (hide -1 -2) (("1" (assert) (("1" (expand "lsrem") (("1" (case-replace "bv2nat[N]((LAMBDA (i: below(N)): IF i < N - jb!1 THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i) ELSE FALSE ENDIF)) = 2 * (bv2nat[N](LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)) + b2n(quot!1(N - 1))") (("1" (assert) (("1" (hide -1) (("1" (case-replace "jb!1 = 0") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (expand "exp2") (("1" (assert) (("1" (rewrite "bv2nat_lem") (("1" (expand "^") (("1" (lemma "bv2nat_fill_F[N - 1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < jb!1 THEN b2n(left_shift(1, quot!1)(ii + N - jb!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "jb!1 - 1") (("1" (assert) (("1" (case-replace "sigma(jb!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < jb!1 THEN b2n(left_shift(1, quot!1)(ii + N - jb!1)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (case-replace "jb!1 = N - 1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(quot!1(ii)))" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 THEN b2n(left_shift(1, quot!1)(1 + ii)) ELSE b2n(FALSE) ENDIF)" "N - 2" 0) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + jb!1 THEN b2n(quot!1(ii - 1 + N - jb!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "jb!1") (("1" (assert) (("1" (case-replace "sigma(1 + jb!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + jb!1 THEN b2n(quot!1(ii - 1 + N - jb!1)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + jb!1 THEN b2n(quot!1(ii - 1 + N - jb!1)) ELSE b2n(FALSE) ENDIF)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < jb!1 THEN b2n(left_shift(1, quot!1)(ii + N - jb!1)) ELSE b2n(FALSE) ENDIF)" "jb!1 - 1" 0) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + jb!1 THEN b2n(quot!1(ii - 1 + N - jb!1)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < 1 + jb!1 THEN b2n(quot!1(ii - 1 + N - jb!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" "1 + jb!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < jb!1 THEN b2n(left_shift(1, quot!1)(ii + N - jb!1)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < jb!1 THEN b2n(left_shift(1, quot!1)(ii + N - jb!1)) ELSE b2n(FALSE) ENDIF)" "N - 1" "jb!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (use "sigma_mult") (("2" (replace -1 * rl) (("2" (hide -1) (("2" (case-replace "jb!1 = 0") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)))" "N - 1" 0 0) (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "exp2" -1 3) (("1" (replace -1) (("1" (hide -1) (("1" (expand "sigma" 1 2) (("1" (expand "extend" 1 2) (("1" (expand "b2n" 1 6) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)))" "N - 2" 0 1) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)))(1 + n)" "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 THEN b2n(rem!1(ii)) ELSE b2n(FALSE) ENDIF)(n)" "N - 2" 0) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - jb!1 THEN b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)) ELSE b2n(FALSE) ENDIF)" "N - 1" 0 "N - jb!1 - 1") (("2" (assert) (("2" (case-replace "sigma(N - jb!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - jb!1 THEN b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)) ELSE b2n(FALSE) ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (case-replace "jb!1 = N - 1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (expand "exp2" 2 1) (("1" (assert) (("1" (lemma "sigma_mult") (("1" (inst - "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "N - 1" 0 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): 0 * (2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n))" "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "N - 1" 0) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - jb!1 THEN b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)) ELSE b2n(FALSE) ENDIF)" "N - 1 - jb!1" 0 0) (("2" (assert) (("2" (expand "sigma" -1 2) (("2" (expand "extend" -1 2) (("2" (replace -1) (("2" (hide -1) (("2" (expand "exp2" 3 2) (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - jb!1 THEN b2n(rem!1(ii)) ELSE b2n(FALSE) ENDIF)(n)" "N - 1" 0 "N - 2 - jb!1") (("2" (assert) (("2" (case-replace "sigma(N - 1 - jb!1, N - 1, LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - jb!1 THEN b2n(rem!1(ii)) ELSE b2n(FALSE) ENDIF)(n)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - jb!1 THEN b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)) ELSE b2n(FALSE) ENDIF)" "N - 2 - jb!1" 0 1) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n: nat): extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - jb!1 THEN b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)) ELSE b2n(FALSE) ENDIF)(1 + n)" "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - jb!1 THEN b2n(rem!1(ii)) ELSE b2n(FALSE) ENDIF)(n)" "N - 2 - jb!1" 0) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst - "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - jb!1 THEN b2n(rem!1(ii)) ELSE b2n(FALSE) ENDIF)(n)" "N - 1" "N - 1 - jb!1" 0) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat): 2 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - 1 - jb!1 THEN b2n(rem!1(ii)) ELSE b2n(FALSE) ENDIF)(n)" "LAMBDA (n: nat): 0" "N - 1" "N - 1 - jb!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (use "sigma_mult" ("x" 0)) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - jb!1 THEN b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)) ELSE b2n(FALSE) ENDIF)(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * IF ii < N - jb!1 THEN b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](ii)) ELSE b2n(FALSE) ENDIF)" "N - 1" "N - jb!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "bv2nat[N](lsrem) = bv2nat[N - jb!1](lsrem ^ (N - 1 - jb!1, 0))") (("1" (hide -1) (("1" (case-replace "bv2nat[N](dvs!1) = bv2nat[N - jb!1](dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN (lsrem - dvs!1)(i) ELSE FALSE ENDIF) = fill[jb!1](FALSE) o (lsrem - dvs!1) ^ (N - 1 - jb!1, 0)") (("1" (hide -1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) (("1" (lemma "bv2nat_minus3") (("1" (expand "-") (("1" (rewrite "bv_add_subrange") (("1" (rewrite "bv_caret_negate") (("1" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "bv2nat[N](dvs!1) = bv2nat[N](fill[jb!1](FALSE) o dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "dvs!1 = fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case-replace "jb!1 = 0") (("1" (grind-with-ext) nil nil) ("2" (assert) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst - "dvs!1" "N - jb!1") (("2" (assert) (("2" (hide -2) (("2" (apply-extensionality 2 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (case-replace "bv2nat[N](lsrem) = bv2nat[N](fill[jb!1](FALSE) o lsrem ^ (N - 1 - jb!1, 0))") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "lsrem = (fill[jb!1](FALSE) o lsrem ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (expand "lsrem") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (hide 2) (("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil) ("5" (skosimp) (("5" (assert) nil nil)) nil) ("6" (skosimp) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (hide 1 2) (("2" (case-replace "(LAMBDA (i: below(N)): IF i < 1 + jb!1 THEN quot!1(i - 1 + N - jb!1) ELSE aux!1(i - 1 - jb!1) ENDIF) = (LAMBDA (i: below(N)): IF i < jb!1 THEN left_shift(1, quot!1)(i + N - jb!1) ELSE left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)](i - jb!1) ENDIF)") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)): IF i < 1 + jb!1 THEN quot!1(i - 1 + N - jb!1) ELSE rem!1(i - 1 - jb!1) ENDIF) = (LAMBDA (i: below(N)): IF i < jb!1 THEN left_shift(1, quot!1)(i + N - jb!1) ELSE left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i - jb!1) ENDIF)") (("1" (replace -3) (("1" (hide -1 -3) (("1" (assert) (("1" (expand "exp2" 1 1) (("1" (case-replace "(LAMBDA (i: below(N)): IF i < N - jb!1 THEN left_shift(1, quot!1)(i) ELSE FALSE ENDIF) = left_shift(1, (LAMBDA (i: below(N)): IF i < N - 1 - jb!1 THEN quot!1(i) ELSE FALSE ENDIF)) WITH [(0) := FALSE]") (("1" (rewrite "leftshift_with") (("1" (expand "b2n") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (use "bv2nat_upperbound[N]") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil) ("5" (skosimp) (("5" (assert) nil nil)) nil) ("6" (skosimp) (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil) ("5" (skosimp) (("5" (assert) nil nil)) nil) ("6" (skosimp) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((nil application-judgement "above(n)" exp2 nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "bvec[N]" bv_arithmetic_defs nil) (TRUE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (leftshift_with formula-decl nil DivisionUtil nil) (even_times_int_is_even application-judgement "even_int" integers nil) (b2n const-decl "nbit" bit nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (bv2nat_rec def-decl "nat" bv_nat nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv2nat_minus3 formula-decl nil DivisionUtil nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (bv_add_subrange formula-decl nil bv_arith_caret nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (lsrem skolem-const-decl "[below(N) -> bit]" BitvectorOneComplementDivision nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_shift formula-decl nil sums nil) (below type-eq-decl nil nat_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (above nonempty-type-eq-decl nil integers nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (^ const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (sigma_split formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (sigma_restrict_eq formula-decl nil sums nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_mult formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (extend const-decl "[nat -> nat]" bv_sum nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (nbit type-eq-decl nil bit nil) (bv2nat_split formula-decl nil BitvectorOneComplementDivision nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (FALSE const-decl "bool" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (divrem1_eq 0 (divrem1_eq-1 nil 3342836500 ("" (skolem!) (("" (rewrite "div_divrem_mem") (("" (rewrite "rem_divrem_mem") (("" (use "divrem_mem_invariant") (("" (assert) (("" (split) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (use "divrem_mem_first_second_third") (("1" (beta) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (case-replace "(LAMBDA (i: below(N)): dvd!1(i)) = dvd!1") (("1" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "bv2nat_fill_F[N]") (("2" (expand "fill") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((div_divrem_mem formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (divrem_mem_invariant formula-decl nil BitvectorOneComplementDivision nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (nil application-judgement "above(n)" exp2 nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (rem_divrem_mem formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (rem1_below_dvs 0 (rem1_below_dvs-1 nil 3342836603 ("" (skosimp) (("" (rewrite "rem_divrem_mem") (("" (use "divrem_mem_rem") (("" (expand "<") (("" (assert) (("" (lemma "bv2nat_fill_F[N]") (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem_divrem_mem formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (< const-decl "bool" bv_arith_nat_defs nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem_rem formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (rem1_dvs0 0 (rem1_dvs0-1 nil 3342836648 ("" (skolem!) (("" (expand "rem") (("" (use "divrem_dvs0") (("" (assert) (("" (replace -1) (("" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil) ((rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_dvs0 formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (div1_dvs0 0 (div1_dvs0-1 nil 3342836680 ("" (skolem!) (("" (expand "div") (("" (use "divrem_dvs0") (("" (assert) (("" (replace -1) (("" (apply-extensionality) (("" (expand "fill") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_dvs0 formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (div1_below_dvd 0 (div1_below_dvd-1 nil 3342836716 ("" (skosimp) (("" (use "divrem1_eq") (("" (replace -1 2 rl) (("" (hide -1) (("" (assert) (("" (lemma "le_times_le_pos") (("" (inst - "bv2nat(div(dvd!1, dvs!1))" "1" "bv2nat(dvs!1)" "bv2nat(div(dvd!1, dvs!1))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (le_times_le_pos formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (divrem1_uniqueness 0 (divrem1_uniqueness-1 nil 3342836764 ("" (skosimp) (("" (use "divrem1_eq") (("" (use "rem1_below_dvs") (("" (assert) (("" (lemma "unique_division") (("" (inst - "bv2nat(dvs!1)" "bv2nat(div(dvd!1, dvs!1))" "q!1" "bv2nat(rem(dvd!1, dvs!1))" "r!1") (("" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (unique_division formula-decl nil euclidean_division nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil)) shostak)) (divrem1_dvs1 0 (divrem1_dvs1-1 nil 3342836807 ("" (skolem!) (("" (use "rem1_below_dvs") (("" (lemma "bv2nat_one") (("" (assert) (("" (use "bv2nat_eq0[N]") (("" (assert) (("" (lemma "divrem1_uniqueness") (("" (inst - "dvd!1" "one" "bv2nat(dvd!1)" "bv2nat(rem(dvd!1, one))") (("" (assert) (("" (lemma "bv2nat_inj[N]") (("" (inst - "dvd!1" "div(dvd!1, one)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat_inj formula-decl nil bv_nat nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (divrem1_uniqueness formula-decl nil BitvectorOneComplementDivision nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (bv2nat_one formula-decl nil BitvectorMultiplication nil)) shostak)) (div1_eq0 0 (div1_eq0-1 nil 3342836923 ("" (lemma "N_size") (("" (skolem!) (("" (case-replace "bv2nat(dvs!1) = 0") (("1" (forward-chain "bv2nat_eq0[N]") (("1" (replace -1) (("1" (rewrite "div1_dvs0") (("1" (rewrite "bv2nat_fill_T[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (iff) (("2" (use "divrem1_eq") (("2" (use "rem1_below_dvs") (("2" (reduce) (("2" (lemma "ge_times_ge_pos") (("2" (inst - "bv2nat(dvs!1)" 1 "bv2nat(div(dvd!1, dvs!1))" "bv2nat(dvs!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (ge_times_ge_pos formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (bv2nat_fill_T formula-decl nil bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) shostak)))
