(BitvectorUtil (bvec_induction 0 (bvec_induction-1 nil 3341620150 ("" (skosimp) (("" (measure-induct+ "bv2nat(bv)" ("bv")) (("" (rewrite "bv2nat_eq0") (("" (use "bv_minus1[N]") (("" (assert) (("" (inst - "x!1 - 1") (("" (inst - "x!1 - 1") (("" (assert) (("" (expand "-") (("" (rewrite "bv_add_2_consts[N]") (("" (hide -1 -2 -3) (("" (rewrite "bv_plus0[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (wf_nat formula-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (bv_minus1 formula-decl nil bv_arith_nat nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "bvec[N]" bv_arith_nat_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv_add_2_consts formula-decl nil bv_arith_nat nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (bv_plus0 formula-decl nil bv_arith_nat nil) (minus_int_is_int application-judgement "int" integers nil) (bv2nat_eq0 formula-decl nil bv_nat nil)) shostak)) (plus_min_zero_TCC1 0 (plus_min_zero_TCC1-1 nil 3341620121 ("" (use "N_size") (("" (assert) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) nil)) (plus_min_zero 0 (plus_min_zero-1 nil 3341621698 ("" (use "N_size") (("" (skolem!) (("" (assert) (("" (lemma "bv2nat_eq0[N]") (("" (inst?) (("" (assert) (("" (rewrite "bv_add[N]") (("" (rewrite "bv2nat_minus_bv[N]") (("" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bv_add formula-decl nil bv_arith_nat nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (min_fill_F 0 (min_fill_F-1 nil 3341622009 ("" (use "N_size") (("" (assert) (("" (lemma "bv_sub_identity_L") (("" (inst - "N" "fill[N](FALSE)") (("" (rewrite "bv_add_fill_F[N]") nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv_add_fill_F formula-decl nil bv_arith_nat nil) (bv_sub_identity_L formula-decl nil bv_arith_minus_rules nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (inc_zero_TCC1 0 (inc_zero_TCC1-1 nil 3341620121 ("" (lemma "N_size") (("" (assert) nil nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) nil)) (inc_zero 0 (inc_zero-1 nil 3342224883 ("" (lemma "N_size") (("" (skolem!) (("" (ground) (("1" (use "bv_plus1[N]") (("1" (lift-if) (("1" (prop) (("1" (use "bv2nat_eq0[N]") (("1" (expand "fill") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "bv2nat_lem") (("2" (inst-cp - "N" "bv!1") (("2" (inst - "N" "bv!1 + 1") (("2" (assert) (("2" (replace*) (("2" (expand "^" -3 1) (("2" (expand "^" -3 2) (("2" (expand "b2n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2nat[N](bv!1 + 1) = bv2nat[N](LAMBDA (i: below(N)): i = 0 OR bv!1(i))") (("1" (use "bv2nat_inj[N]") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case-replace "bv2nat[N](bv!1 + 1) = bv2nat[N](bv!1) + 1") (("1" (hide -1) (("1" (expand "bv2nat") (("1" (case "FORALL (n: below(N + 1)): n > 0 IMPLIES 1 + bv2nat_rec(n, bv!1) = bv2nat_rec(n, LAMBDA (i: below(N)): i = 0 OR bv!1(i))") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "n") (("1" (grind) nil nil) ("2" (skosimp) (("2" (expand "bv2nat_rec" +) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "bv!1 + 1") (("2" (typepred "mod(1 + bv2nat(bv!1), exp2(N))") (("2" (case "bv2nat(bv!1) < exp2(N) - 1") (("1" (expand "mod") (("1" (assert) (("1" (lemma "div_mult_pos_lt1") (("1" (inst - "exp2(N)" 1 "1 + bv2nat(bv!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (typepred "bv2nat(bv!1)") (("2" (rewrite "bv2nat_eq_max") (("2" (expand "fill") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nil application-judgement "above(n)" exp2 nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_inj formula-decl nil bv_nat nil) (nil application-judgement "below(m)" mod nil) (bv2nat_eq_max formula-decl nil bv_nat nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_rec def-decl "nat" bv_nat nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (below_induction formula-decl nil bounded_nat_inductions nil) (int_times_even_is_even application-judgement "even_int" integers nil) (bv_plus1 formula-decl nil bv_arith_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (fill const-decl "bit" bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bvn: bvec[N] | bv2nat(bvn) = mod(bv2nat(bv) + i, exp2(N))}" bv_arith_nat_defs nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (above nonempty-type-eq-decl nil integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (sum_upper_n 0 (sum_upper_n-1 nil 3342226617 ("" (skosimp) (("" (use "sigma_split" ("m" "n!1")) (("" (ground) (("1" (replace -1) (("1" (expand "sigma" 1 2) (("1" (reduce) nil nil)) nil)) nil) ("2" (expand "sigma") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil) ((sigma_split formula-decl nil sums nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma def-decl "nat" sums nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (bv2nat_upper_n 0 (bv2nat_upper_n-1 nil 3342226902 ("" (skosimp) (("" (rewrite "bv2nat_as_sum[N]") (("" (use "sum_upper_n" ("n" "n!1")) (("" (assert) (("" (expand "extend" -1 2) (("" (expand "b2n" -1 2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2nat_as_sum formula-decl nil bv_sum nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (extend const-decl "[nat -> nat]" bv_sum nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sum_upper_n formula-decl nil BitvectorUtil nil)) shostak)) (bv2nat_upperbound 0 (bv2nat_upperbound-1 nil 3342226989 ("" (skolem!) (("" (prop) (("1" (skosimp) (("1" (use "bv2nat_upper_n") (("1" (assert) (("1" (lemma "exp2_lt") (("1" (inst - "k!1" "n!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "n!1 = 0") (("1" (case-replace "bv!1 = fill[N](FALSE)") (("1" (rewrite "bv2nat_fill_F") (("1" (expand "exp2") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2nat(bv!1) = bv2nat(bv!1 ^ (n!1 - 1, 0))") (("1" (typepred "bv2nat(bv!1 ^ (n!1 - 1, 0))") (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[n!1]") (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1" 0 "n!1 - 1") (("2" (assert) (("2" (case-replace "sigma(n!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (use "sigma_restrict_eq") (("1" (assert) (("1" (hide -1 2) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (use "sigma_mult" ("x" 0)) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n:nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1" "n!1") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2nat_upper_n formula-decl nil BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (exp2_lt formula-decl nil exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_split formula-decl nil sums nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (x!1 skolem-const-decl "nat" BitvectorUtil nil) (sigma_mult formula-decl nil sums nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (extend const-decl "[nat -> nat]" bv_sum nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak)) (bv2nat_upperbound_caret_TCC1 0 (bv2nat_upperbound_caret_TCC1-1 nil 3341620121 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) nil)) (bv2nat_upperbound_caret_TCC2 0 (bv2nat_upperbound_caret_TCC2-1 nil 3341620121 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) nil)) (bv2nat_upperbound_caret 0 (bv2nat_upperbound_caret-1 nil 3342227439 ("" (lemma "N_size") (("" (skosimp) (("" (use "bv2nat_upperbound") (("" (assert) (("" (hide -3) (("" (lift-if) (("" (ground) (("1" (case-replace "bv!1 = fill[N](FALSE)") (("1" (rewrite "bv2nat_fill_F") nil nil) ("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("2" (use "sigma_split" ("m" "n!1 - 1")) (("2" (assert) (("2" (case-replace "sigma(n!1, N - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))) = 0") (("1" (replace -2) (("1" (hide -) (("1" (assert) (("1" (rewrite "bv2nat_as_sum[n!1]") (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "extend(LAMBDA (ii: below(n!1)): exp2(ii) * b2n((bv!1 ^ (n!1 - 1, 0))(ii)))" "n!1 - 1" 0) (("1" (assert) (("1" (hide 3) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (use "sigma_mult" ("x" 0)) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "LAMBDA (n:nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "N - 1" "n!1") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "nat" BitvectorUtil nil) (sigma_mult formula-decl nil sums nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sigma_restrict_eq formula-decl nil sums nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (restrict const-decl "[nat -> nat]" sums nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sigma def-decl "nat" sums nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nbit type-eq-decl nil bit nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma_split formula-decl nil sums nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (int_plus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (widen_TCC1 0 (widen_TCC1-1 nil 3341620121 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (widen_TCC2 0 (widen_TCC2-1 nil 3341620121 ("" (subtype-tcc) nil nil) nil nil)) (bv2int_widen_TCC1 0 (bv2int_widen_TCC1-1 nil 3341620121 ("" (lemma "N_size") (("" (assert) nil nil)) nil) ((mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) nil)) (bv2int_widen 0 (bv2int_widen-2 "" 3369450129 ("" (skolem!) (("" (lemma "N_size") (("" (rewrite "bv2int_lem") (("" (rewrite "bv2int_lem[N]") (("" (expand* "^" "b2n") (("" (expand "widen" 1 2) (("" (assert) (("" (rewrite "bv2nat_as_sum[N]") (("" (rewrite "bv2nat_as_sum[2 * N]") (("" (lift-if) (("" (ground) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "2 * N - 1" 0 "N - 1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1" 0) (("1" (split) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(N, 2 * N - 1, extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))) = exp2(2 * N) - exp2(N)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "sigma(N, 2 * N - 1, extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))) = sigma(N, 2 * N - 1, LAMBDA (n:nat): exp2(n))") (("1" (replace -1) (("1" (hide -1 -2) (("1" (case "FORALL (N: posnat): sigma(N, 2 * N - 1, LAMBDA (n: nat): exp2(n)) = exp2(2 * N) - exp2(N)") (("1" (inst?) nil nil) ("2" (hide 2) (("2" (induct "N") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skosimp) (("3" (case "j!1 = 0") (("1" (grind) nil nil) ("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (n: nat): exp2(n)" "2 * j!1 - 1" "j!1" "j!1") (("2" (assert) (("2" (case "j!1 = 1") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "sigma" -1 3) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (n: nat): exp2(n)" "2 * j!1 + 1" "j!1 + 1" "2 * j!1 - 1") (("2" (assert) (("2" (expand "sigma" -1 3) (("2" (expand "sigma" -1 3) (("2" (replace -1) (("2" (hide -1) (("2" (case " sigma(1 + j!1, 2 * j!1 - 1, LAMBDA (n: nat): exp2(n)) = exp2(2 * j!1) - 2 * exp2(j!1)") (("1" (replace -1) (("1" (hide -1 -2) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "LAMBDA (n: nat): exp2(n)" "2 * N - 1" "N") (("2" (assert) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "2 * N - 1" "0" "N - 1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "2 * N - 1" "N" 0) (("2" (rewrite "zero_times1") (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat): 0" "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "2 * N - 1" "N") (("2" (split) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1" 0) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((N_size formula-decl nil BitvectorUtil nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (zero_times1 formula-decl nil real_props nil) (sigma_mult formula-decl nil sums nil) (sigma_split formula-decl nil sums nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "nat" sums nil) (NOT const-decl "[bool -> bool]" booleans nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (restrict const-decl "[nat -> nat]" sums nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_restrict_eq formula-decl nil sums nil) (extend const-decl "[nat -> nat]" bv_sum nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (bv2int_lem formula-decl nil bv_int nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil)) shostak) (bv2int_widen-1 nil 3342227876 ("" (skolem!) (("" (lemma "N_size") (("" (rewrite "bv2int_lem") (("" (rewrite "bv2int_lem") (("" (expand* "^" "b2n") (("" (expand "widen" 1 2) (("" (assert) (("" (rewrite "bv2nat_as_sum[N]") (("" (rewrite "bv2nat_as_sum[2 * N]") (("" (lift-if) (("" (ground) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "2 * N - 1" 0 "N - 1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1" 0) (("1" (split) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(N, 2 * N - 1, extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))) = exp2(2 * N) - exp2(N)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "sigma(N, 2 * N - 1, extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))) = sigma(N, 2 * N - 1, LAMBDA (n:nat): exp2(n))") (("1" (replace -1) (("1" (hide -1 -2) (("1" (case "FORALL (N: posnat): sigma(N, 2 * N - 1, LAMBDA (n: nat): exp2(n)) = exp2(2 * N) - exp2(N)") (("1" (inst?) nil nil) ("2" (hide 2) (("2" (induct "N") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skosimp) (("3" (case "j!1 = 0") (("1" (grind) nil nil) ("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (n: nat): exp2(n)" "2 * j!1 - 1" "j!1" "j!1") (("2" (assert) (("2" (case "j!1 = 1") (("1" (grind) nil nil) ("2" (assert) (("2" (expand "sigma" -1 3) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (n: nat): exp2(n)" "2 * j!1 + 1" "j!1 + 1" "2 * j!1 - 1") (("2" (assert) (("2" (expand "sigma" -1 3) (("2" (expand "sigma" -1 3) (("2" (replace -1) (("2" (hide -1) (("2" (case " sigma(1 + j!1, 2 * j!1 - 1, LAMBDA (n: nat): exp2(n)) = exp2(2 * j!1) - 2 * exp2(j!1)") (("1" (replace -1) (("1" (hide -1 -2) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "LAMBDA (n: nat): exp2(n)" "2 * N - 1" "N") (("2" (assert) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "2 * N - 1" "0" "N - 1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "2 * N - 1" "N" 0) (("2" (rewrite "zero_times1") (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat): 0" "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "2 * N - 1" "N") (("2" (split) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(widen(bv!1)(ii)))" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1" 0) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((N_size formula-decl nil BitvectorUtil nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (zero_times1 formula-decl nil real_props nil) (sigma_mult formula-decl nil sums nil) (sigma_split formula-decl nil sums nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma def-decl "nat" sums nil) (NOT const-decl "[bool -> bool]" booleans nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "[nat -> nat]" sums nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_restrict_eq formula-decl nil sums nil) (extend const-decl "[nat -> nat]" bv_sum nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (^ const-decl "bit" bv nil) (b2n const-decl "nbit" bit nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (bv2int_lem formula-decl nil bv_int nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil)) shostak)) (widen_inj 0 (widen_inj-1 nil 3342228633 ("" (skolem!) (("" (iff) (("" (ground) (("" (decompose-equality) (("" (decompose-equality) (("" (expand "widen") (("" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (bv2int_plus_widens 0 (bv2int_plus_widens-1 nil 3342228721 ("" (lemma "N_size") (("" (skolem!) (("" (rewrite "bv2int_add_combined_rule") (("" (expand "in_rng_2s_comp") (("" (rewrite "bv2int_widen") (("" (rewrite "bv2int_widen") (("" (assert) (("" (typepred "bv2int[N](bv1!1)") (("" (typepred "bv2int[N](bv2!1)") (("" (expand* "minint" "maxint") (("" (assert) (("" (lemma "exp2_lt") (("" (inst - "2 * N - 1" "N") (("" (expand "exp2" -1 1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (in_rng_2s_comp const-decl "bool" bv_int_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (exp2_lt formula-decl nil exp2 nil) (exp2 def-decl "posnat" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bv2int_widen formula-decl nil BitvectorUtil nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2int_add_combined_rule formula-decl nil bv_arith_int_rules nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (bv2int_min_widen 0 (bv2int_min_widen-1 nil 3342228904 ("" (lemma "N_size") (("" (skolem!) (("" (rewrite "bv2int_neg") (("" (rewrite "bv2int_widen") (("" (assert) (("" (typepred "bv2int[N](bv!1)") (("" (expand* "minint" "maxint") (("" (lemma "exp2_lt") (("" (inst - "2 * N - 1" "N - 1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int_widen formula-decl nil BitvectorUtil nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (exp2_lt formula-decl nil exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (bv2nat_widen_TCC1 0 (bv2nat_widen_TCC1-1 nil 3341620121 ("" (lemma "N_size") (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) nil)) (bv2nat_widen 0 (bv2nat_widen-1 nil 3342229069 ("" (lemma "N_size") (("" (skolem!) (("" (lift-if) (("" (ground) (("1" (case-replace "widen(bv!1) = fill[N](FALSE) o bv!1") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "widen(bv!1) = fill[N](TRUE) o bv!1") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_T") (("1" (assert) (("1" (use "exp2_sum") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_times_even_is_even application-judgement "even_int" integers nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (exp2_sum formula-decl nil exp2 nil) (bv2nat_fill_T formula-decl nil bv_nat_rules nil) (TRUE const-decl "bool" booleans nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (bv2nat_widen_null 0 (bv2nat_widen_null-1 nil 3342229312 ("" (lemma "N_size") (("" (skolem!) (("" (iff) (("" (ground) (("1" (use "bv2nat_eq0[2 * N]") (("1" (assert) (("1" (case "bv!1 = fill[N](FALSE)") (("1" (replace -1 1) (("1" (rewrite "bv2nat_fill_F") nil nil)) nil) ("2" (hide -2 2) (("2" (decompose-equality) (("2" (decompose-equality) (("2" (expand* "fill" "widen") (("2" (inst-cp - "N") (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "bv2nat_eq0[N]") (("2" (assert) (("2" (replace -1) (("2" (hide -1 -2) (("2" (case-replace "widen(fill[N](FALSE)) = fill[2 * N](FALSE)") (("1" (rewrite "bv2nat_fill_F") nil nil) ("2" (hide 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (narrow_TCC1 0 (narrow_TCC1-1 nil 3341620121 ("" (lemma "N_size") (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) nil)) (narrow_TCC2 0 (narrow_TCC2-1 nil 3341620121 ("" (lemma "N_size") (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) nil)) (bv2int_narrow 0 (bv2int_narrow-1 nil 3342229496 ("" (lemma "N_size") (("" (skosimp) (("" (expand "narrow") (("" (assert) (("" (use "bv2int_of_sign_extension") (("" (assert) (("" (hide 2) (("" (expand* "in_rng_2s_comp" "minint" "maxint") (("" (auto-rewrite "exp2") (("" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (in_rng_2s_comp const-decl "bool" bv_int_defs nil) (exp2 def-decl "posnat" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2int_of_sign_extension formula-decl nil bv_arith_int_caret nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (narrow_int2bv_TCC1 0 (narrow_int2bv_TCC1-1 nil 3341620121 ("" (lemma "N_size") (("" (skosimp) (("" (expand* "minint" "maxint") (("" (assert) (("" (lemma "exp2_lt") (("" (inst - "2 * N - 1" "N - 1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (exp2_lt formula-decl nil exp2 nil) (minint const-decl "int" bv_int_defs nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (maxint const-decl "int" bv_int_defs nil) (N_size formula-decl nil BitvectorUtil nil)) nil)) (narrow_int2bv_TCC2 0 (narrow_int2bv_TCC2-1 nil 3341620121 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (narrow_int2bv 0 (narrow_int2bv-1 nil 3342229738 ("" (lemma "N_size") (("" (skosimp) (("" (assert) (("" (case "bv2int[N](narrow(int2bv[2 * N](k!1))) = bv2int(int2bv[N](k!1))") (("1" (rewrite "bv2int_inj[N]") nil nil) ("2" (hide 2) (("2" (rewrite "bv2int_narrow") (("2" (rewrite "bv2int_inv[2 * N]") (("2" (rewrite "bv2int_inv[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int2bv const-decl "{bv: bvec[N] | bv2int(bv) = iv}" bv_int_defs nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (bv2int_inj formula-decl nil bv_int nil) (bv2int_narrow formula-decl nil BitvectorUtil nil) (bv2int_inv formula-decl nil bv_int nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (narrow_widen 0 (narrow_widen-1 nil 3342229906 ("" (skolem!) (("" (apply-extensionality :hide? t) (("" (expand* "narrow" "^" "widen") (("" (reduce) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil)) shostak)) (narrow_plus 0 (narrow_plus-1 nil 3342229944 ("" (lemma "N_size") (("" (skolem!) (("" (expand "narrow") (("" (rewrite "bv_add_caret") nil nil)) nil)) nil)) nil) ((mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv_add_caret formula-decl nil bv_arith_caret_rules nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (narrow_min 0 (narrow_min-1 nil 3342229973 ("" (lemma "N_size") (("" (skolem!) (("" (expand "narrow") (("" (rewrite "bv_caret_negate") nil nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (narrow_minus 0 (narrow_minus-1 nil 3342230005 ("" (lemma "N_size") (("" (skolem!) (("" (expand "-") (("" (rewrite "narrow_plus") (("" (rewrite "narrow_min") nil nil)) nil)) nil)) nil)) nil) ((> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (narrow_plus formula-decl nil BitvectorUtil nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (narrow_min formula-decl nil BitvectorUtil nil) (- const-decl "bvec[N]" bv_arithmetic_defs nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (narrow_concat 0 (narrow_concat-1 nil 3342230057 ("" (lemma "N_size") (("" (grind-with-ext) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (leftshift_zero 0 (leftshift_zero-1 nil 3342230092 ("" (grind-with-ext) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (left_shift const-decl "bvec[N]" bv_shift nil)) shostak)) (leftshift_inc 0 (leftshift_inc-1 nil 3342230103 ("" (grind-with-ext) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (left_shift const-decl "bvec[N]" bv_shift nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (bv2nat_leftshift_TCC1 0 (bv2nat_leftshift_TCC1-1 nil 3341620121 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil)) nil)) (bv2nat_leftshift 0 (bv2nat_leftshift-1 nil 3342230123 ("" (skosimp) (("" (case-replace "n!1 = 0") (("1" (grind) nil nil) ("2" (rewrite "bv2nat_upperbound") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1" 0 "exp2(n!1)") (("2" (replace -1 * rl) (("2" (hide -1) (("2" (lemma "sigma_shift") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N - 1" 0 "n!1") (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat): extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))(n + n!1)" "LAMBDA (n:nat): exp2(n!1) * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "N - 1" 0) (("2" (split) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst-cp - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N - 1" 0 "n!1 - 1") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "sigma(0, n!1 - 1, extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))) = 0") (("1" (hide -1) (("1" (assert) (("1" (case "sigma(N, N - 1 + n!1, extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))) = 0") (("1" (case-replace "n!1 = N - 1") (("1" (assert) (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "2 * N - 2" "N - 1" "N - 1") (("1" (assert) nil nil)) nil)) nil) ("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N - 1 + n!1" "n!1" "N - 1") (("2" (assert) nil nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N - 1 + n!1" "N" 0) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "N - 1 + n!1" "N") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (expand* "restrict" "extend") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 3) (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "n!1 - 1" 0 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat): 0 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(left_shift(n!1, bv!1)(ii)))" "n!1 - 1" 0) (("2" (assert) (("2" (hide -1 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (apply-extensionality :hide? t) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (expand* "extend" "b2n" "left_shift" "^" "o") (("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (rewrite "exp2_sum") nil nil) ("2" (inst - "x!1") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (left_shift const-decl "bvec[N]" bv_shift nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (sigma_mult formula-decl nil sums nil) (sigma_shift formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_split formula-decl nil sums nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (n!1 skolem-const-decl "below(N)" BitvectorUtil nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma def-decl "nat" sums nil) (exp2_sum formula-decl nil exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (extend const-decl "[nat -> nat]" bv_sum nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nbit type-eq-decl nil bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (bv2nat_rightshift_upperbound 0 (bv2nat_rightshift_upperbound-1 nil 3342230785 ("" (skolem!) (("" (case-replace "n!1 = 0") (("1" (grind) nil nil) ("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_mult") (("2" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))" "N - 1" 0 "exp2(n!1)") (("2" (replace -1 * rl) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (case "N - 1 >= n!1") (("1" (inst - "LAMBDA (n:nat): exp2(n!1) * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))(n)" "N - 1" 0 "N - n!1 - 1") (("1" (assert) (("1" (case-replace "sigma(N - n!1, N - 1, LAMBDA (n: nat): exp2(n!1) * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))(n)) = 0") (("1" (assert) (("1" (replace -3) (("1" (hide -1 -3) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1 -n!1" 0 "n!1") (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat): extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n + n!1)" "LAMBDA (n: nat): exp2(n!1) * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))(n)" "N - 1 - n!1" 0) (("1" (split) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "N - 1" 0 "n!1 - 1") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (apply-extensionality :hide? t) (("2" (grind :rewrites ("exp2_sum")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3) (("2" (lemma "sigma_mult") (("2" (inst - "LAMBDA (n: nat): exp2(n!1) * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))(n)" "N - 1" "N - n!1" 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (m: nat): 0 * (exp2(n!1) * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))(m))" "LAMBDA (n: nat): exp2(n!1) * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(right_shift(n!1, bv!1)(ii)))(n)" "N - 1" "N - n!1") (("2" (assert) (("2" (hide -1 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (nil application-judgement "above(n)" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_rec def-decl "nat" bv_nat nil) (b2n const-decl "nbit" bit nil) (^ const-decl "bit" bv nil) (right_shift const-decl "bvec[N]" bv_shift nil) (exp2 def-decl "posnat" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (extend const-decl "[nat -> nat]" bv_sum nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nbit type-eq-decl nil bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (fill const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (exp2_sum formula-decl nil exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_shift formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma_split formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (bv2nat_as_sum formula-decl nil bv_sum nil)) shostak)) (bv2int_rightshift_upperbound 0 (bv2int_rightshift_upperbound-1 nil 3342231237 ("" (skosimp) (("" (expand "bv2int") (("" (lift-if -) (("" (ground) (("" (use "bv2nat_rightshift_upperbound") (("" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2nat_rightshift_upperbound formula-decl nil BitvectorUtil nil)) shostak)) (rightshift_zero 0 (rightshift_zero-1 nil 3342231321 ("" (grind) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (right_shift const-decl "bvec[N]" bv_shift nil)) shostak)) (rightshift_inc 0 (rightshift_inc-1 nil 3342231338 ("" (grind-with-ext) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (right_shift const-decl "bvec[N]" bv_shift nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (bv2int_rightshift_pos 0 (bv2int_rightshift_pos-1 nil 3342231350 ("" (skolem!) (("" (expand "bv2int") (("" (lift-if) (("" (ground) (("" (lemma "N_size") (("" (rewrite "bv2nat_upperbound") (("" (hide 2) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (N formal-const-decl "nat" BitvectorUtil nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (right_shift const-decl "bvec[N]" bv_shift nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (leftshift1_add_aux_TCC1 0 (leftshift1_add_aux_TCC1-1 nil 3341620121 ("" (subtype-tcc) nil nil) nil nil)) (leftshift1_add_aux_TCC2 0 (leftshift1_add_aux_TCC2-1 nil 3341620121 ("" (subtype-tcc) nil nil) nil nil)) (leftshift1_add_aux 0 (leftshift1_add_aux-1 nil 3342231488 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "n_cout_rec" 1 1) (("2" (inst?) (("2" (replace -2) (("2" (hide -2) (("2" (expand "n_cout_rec" 1 2) (("2" (expand* "left_shift" "^" "o") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (oba_cout const-decl "bit" bv_adder nil) (fill const-decl "bit" bv nil) (^ const-decl "bit" bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (N formal-const-decl "nat" BitvectorUtil nil) (FALSE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (n_cout_rec def-decl "bit" bv_adder nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak)) (leftshift1_add 0 (leftshift1_add-1 nil 3342231629 ("" (lemma "N_size") (("" (skolem!) (("" (rewrite "adder_is_add[N]" :dir rl) (("" (rewrite "adder_is_add[N]" :dir rl) (("" (apply-extensionality :hide? t) (("" (expand "left_shift" 1 1) (("" (expand* "fill" "^" "o") (("" (lift-if) (("" (ground) (("1" (grind) nil nil) ("2" (expand "bv_adder") (("2" (lift-if) (("2" (ground) (("1" (grind) nil nil) ("2" (lemma "leftshift1_add_aux") (("2" (inst - "bv1!1" "bv2!1" "x!1 - 2") (("2" (replace -1) (("2" (hide -1) (("2" (expand* "left_shift" "^" "o") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (left_shift const-decl "bvec[N]" bv_shift nil) (int_minus_int_is_int application-judgement "int" integers nil) (/= const-decl "boolean" notequal nil) (oba_cout const-decl "bit" bv_adder nil) (n_cout_rec def-decl "bit" bv_adder nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (leftshift1_add_aux formula-decl nil BitvectorUtil nil) (^ const-decl "bit" bv nil) (XOR const-decl "bool" xor_def nil) (oba_sum const-decl "bit" bv_adder nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fill const-decl "bit" bv nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (FALSE const-decl "bool" booleans nil) (bv_adder const-decl "bvec[N]" bv_adder nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N formal-const-decl "nat" BitvectorUtil nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (adder_is_add formula-decl nil bv_adder nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)) (narrow_rightshift 0 (narrow_rightshift-1 nil 3342231790 ("" (lemma "N_size") (("" (skosimp) (("" (case "FORALL (n:nat): n >= N AND n < 2*N IMPLIES NOT BV!1(n)") (("1" (apply-extensionality :hide? t) (("1" (expand* "narrow" "right_shift" "^" "o" "fill") (("1" (inst - "n!1 + x!1") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "bv2int") (("2" (lift-if) (("2" (ground) (("2" (rewrite "bv2nat_as_sum") (("2" (assert) (("2" (skosimp) (("2" (lemma "sum_upper_n") (("2" (inst - "extend(LAMBDA (ii: below(2 * N)): exp2(ii) * b2n(BV!1(ii)))" "2 * N - 1" 0 "n!2") (("2" (assert) (("2" (expand "extend" -1 2) (("2" (expand "b2n" -1 2) (("2" (lemma "exp2_lt") (("2" (inst - "n!2" "N") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2nat_as_sum formula-decl nil bv_sum nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (extend const-decl "[nat -> nat]" bv_sum nil) (exp2_lt formula-decl nil exp2 nil) (sum_upper_n formula-decl nil BitvectorUtil nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (narrow const-decl "bvec[N]" BitvectorUtil nil) (right_shift const-decl "bvec[N]" bv_shift nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (fill const-decl "bit" bv nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (N formal-const-decl "nat" BitvectorUtil nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (N_size formula-decl nil BitvectorUtil nil)) shostak)))
