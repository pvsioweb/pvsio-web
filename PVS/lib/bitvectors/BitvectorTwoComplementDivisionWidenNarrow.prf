(BitvectorTwoComplementDivisionWidenNarrow (IMP_BitvectorTwoComplementDivision_TCC1 0 (IMP_BitvectorTwoComplementDivision_TCC1-1 nil 3342886436 ("" (lemma "N_size") (("" (propax) nil nil)) nil) ((N_size formula-decl nil BitvectorTwoComplementDivisionWidenNarrow nil)) nil)) (IMP_BitvectorTwoComplementDivision_TCC2 0 (IMP_BitvectorTwoComplementDivision_TCC2-1 nil 3342886436 ("" (assuming-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil)) (DIVREM_eq 0 (DIVREM_eq-1 nil 3342886473 ("" (skolem!) (("" (expand* "/" "//") (("" (reduce) (("1" (use "DIVREM1_eq[N]") nil nil) ("2" (use "DIVREM1_eq[N]") (("2" (rewrite "times_min_first") (("2" (rewrite "times_min_second" :dir rl) nil nil)) nil)) nil) ("3" (use "DIVREM1_eq[N]") (("3" (rewrite "times_min_first") (("3" (rewrite "bv_neg_distrib[2 * N]" :dir rl) (("3" (replace -1) (("3" (rewrite "bv_double_neg[2 * N]") nil nil)) nil)) nil)) nil)) nil) ("4" (use "DIVREM1_eq[N]") (("4" (rewrite "times_min_second") (("4" (rewrite "-" :dir rl) (("4" (lemma "bv_double_neg[2 * N]") (("4" (inst - "rem(-DVD!1, -DVS!1)") (("4" (replace -1 -2 rl) (("4" (hide -1) (("4" (rewrite "bv_neg_distrib" :dir rl) (("4" (lemma "bv_double_neg[2 * N]") (("4" (inst - "DVD!1") (("4" (replace -2 -1 rl) (("4" (rewrite "bv_double_neg[2 * N]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (- const-decl "bvec[N]" bv_arithmetic_defs nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (bv_neg_distrib formula-decl nil bv_arithmetic nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (times_min_second formula-decl nil BitvectorMultiplication nil) (times_min_first formula-decl nil BitvectorMultiplication nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (DIVREM1_eq formula-decl nil BitvectorTwoComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivisionWidenNarrow nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) shostak)) (divrem_widens_TCC1 0 (divrem_widens_TCC1-1 nil 3342886436 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (divrem_widens 0 (divrem_widens-1 nil 3342886744 ("" (lemma "N_size") (("" (skosimp) (("" (case "bv2int(dvs!1) = 0") (("1" (hide 1) (("1" (expand "bv2int") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (forward-chain "bv2nat_eq0[N]") (("1" (replace -1) (("1" (case-replace "widen(fill[N](FALSE)) = fill[2 * N](FALSE)") (("1" (expand* "/" "//") (("1" (assert) (("1" (rewrite "bv2int_fill_F") (("1" (rewrite "bv2int_fill_F[N]") (("1" (assert) (("1" (rewrite "bv2int_widen") (("1" (rewrite "div1_dvs0[2 * N]") (("1" (rewrite "div1_dvs0[N]") (("1" (rewrite "div1_dvs0[2 * N]") (("1" (rewrite "rem1_dvs0[N]") (("1" (rewrite "rem1_dvs0[2 * N]") (("1" (rewrite "rem1_dvs0[2 * N]") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but 1) (("1" (assert) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "div1_dvs0[N]") (("2" (rewrite "rem1_dvs0[N]") (("2" (split) (("1" (hide-all-but 1) (("1" (case "bv2int[2 * N](-fill[2 * N](TRUE)) = bv2int[2 * N](widen(-fill[N](TRUE)))") (("1" (rewrite "bv2int_inj") nil nil) ("2" (hide 2) (("2" (rewrite "bv2int_widen") (("2" (rewrite "bv2int_neg[N]") (("2" (rewrite "bv2int_neg[2 * N]") (("2" (rewrite "bv2int_fill_T[2 * N]") (("2" (rewrite "bv2int_fill_T[N]") (("2" (expand "minint") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv_double_neg[2 * N]") (("2" (rewrite "bv_double_neg[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "divrem_uniqueness[2 * N]") (("2" (inst - "widen(dvd!1)" "widen(dvs!1)" "bv2int(widen(dvd!1 / dvs!1))" "bv2int(widen(dvd!1 // dvs!1))") (("2" (split) (("1" (flatten) (("1" (rewrite "bv2int_inj") (("1" (rewrite "bv2int_inj") nil nil)) nil)) nil) ("2" (rewrite "bv2int_widen") (("2" (rewrite "bv2int_widen") (("2" (flatten) (("2" (assert) (("2" (typepred "bv2int[N](dvd!1)") (("2" (expand* "minint" "maxint") (("2" (lemma "exp2_lt") (("2" (inst - "2 * N - 1" "N - 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "bv2int_widen") (("3" (assert) nil nil)) nil) ("4" (rewrite "bv2int_widen") (("4" (rewrite "bv2int_widen") (("4" (rewrite "bv2int_widen") (("4" (use "div_sgn[N]") (("4" (ground) nil nil)) nil)) nil)) nil)) nil) ("5" (rewrite "bv2int_widen") (("5" (rewrite "bv2int_widen") (("5" (rewrite "bv2int_widen") (("5" (use "div_sgn[N]") (("5" (ground) nil nil)) nil)) nil)) nil)) nil) ("6" (rewrite "bv2int_widen") (("6" (rewrite "bv2int_widen") (("6" (rewrite "bv2int_widen") (("6" (use "div_sgn[N]") (("6" (ground) nil nil)) nil)) nil)) nil)) nil) ("7" (rewrite "bv2int_widen") (("7" (rewrite "bv2int_widen") (("7" (use "rem_sgn[N]") (("7" (flatten) (("7" (assert) nil nil)) nil)) nil)) nil)) nil) ("8" (rewrite "bv2int_widen") (("8" (rewrite "bv2int_widen") (("8" (use "rem_sgn[N]") (("8" (flatten) (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("9" (rewrite "bv2int_widen") (("9" (rewrite "bv2int_widen") (("9" (use "rem_below_dvs[N]") (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (rewrite "bv2int_widen") (("10" (rewrite "bv2int_widen") (("10" (rewrite "bv2int_widen") (("10" (rewrite "bv2int_widen") (("10" (use "divrem_eq[N]") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((divrem_uniqueness formula-decl nil BitvectorTwoComplementDivision nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (exp2_lt formula-decl nil exp2 nil) (NOT const-decl "[bool -> bool]" booleans nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rem_sgn formula-decl nil BitvectorTwoComplementDivision nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (rem_below_dvs formula-decl nil BitvectorTwoComplementDivision nil) (int_plus_int_is_int application-judgement "int" integers nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (widen const-decl "bvec[2 * N]" BitvectorUtil nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (bv2int_widen formula-decl nil BitvectorUtil nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (bv2int_inj formula-decl nil bv_int nil) (minus_int_is_int application-judgement "int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (bv2int_fill_T formula-decl nil bv_int nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (bv2int_fill_F formula-decl nil bv_int nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivisionWidenNarrow nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (N_size formula-decl nil BitvectorTwoComplementDivisionWidenNarrow nil)) shostak)) (div_cancel_TCC1 0 (div_cancel_TCC1-1 nil 3342886436 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil)) (div_cancel 0 (div_cancel-1 nil 3342887420 ("" (lemma "N_size") (("" (skosimp) (("" (case "bv2int[2*N]((BV!1 * DVD!1) / (BV!1 * DVS!1)) = bv2int[2*N](DVD!1 / DVS!1) AND bv2int[2*N]((BV!1 * DVD!1) // (BV!1 * DVS!1)) = bv2int[2*N](BV!1 * (DVD!1 // DVS!1))") (("1" (flatten) (("1" (rewrite "bv2int_inj") (("1" (rewrite "bv2int_inj") nil nil)) nil)) nil) ("2" (hide 5) (("2" (case "-exp2(2 * N - 1) < bv2int(BV!1) * bv2int(DVD!1 // DVS!1) AND bv2int(BV!1) * bv2int(DVD!1 // DVS!1) < exp2(2 * N - 1)") (("1" (lemma "divrem_uniqueness[2 * N]") (("1" (inst - "BV!1 * DVD!1" "BV!1 * DVS!1" "bv2int(DVD!1/DVS!1)" "bv2int(BV!1) * bv2int(DVD!1//DVS!1)") (("1" (assert) (("1" (rewrite "bv2int_times") (("1" (rewrite "bv2int_times") (("1" (rewrite "bv2int_times") (("1" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil) ("3" (flatten) (("3" (assert) nil nil)) nil) ("4" (flatten) (("4" (assert) (("4" (use "div_sgn[2 * N]") (("4" (assert) (("4" (replace*) (("4" (flatten) (("4" (assert) (("4" (rewrite "neg_times_lt") (("4" (rewrite "pos_times_gt") (("4" (replace*) (("4" (iff) (("4" (split +) (("1" (flatten) (("1" (split -) (("1" (flatten) (("1" (assert) (("1" (split +) (("1" (assert) (("1" (rewrite "both_sides_times_pos_ge2") nil nil)) nil) ("2" (assert) (("2" (rewrite "both_sides_times_neg_le2") nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (rewrite "both_sides_times_neg_ge2") nil nil)) nil) ("2" (assert) (("2" (rewrite "both_sides_times_pos_le2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (rewrite "both_sides_times_neg_ge2") nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "both_sides_times_pos_ge2") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (rewrite "both_sides_times_pos_le2") nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "both_sides_times_neg_le2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (assert) (("5" (use "div_sgn[2 * N]") (("5" (replace*) (("5" (assert) (("5" (flatten) (("5" (assert) (("5" (rewrite "abs_mult") (("5" (rewrite "abs_mult") (("5" (replace*) (("5" (hide -1 -2 -3 2) (("5" (iff) (("5" (lemma "both_sides_times_pos_lt2") (("5" (inst - "abs(bv2int(BV!1))" "abs(bv2int(DVD!1))" "abs(bv2int(DVS!1))") (("5" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (flatten) (("6" (assert) (("6" (use "div_sgn[2 * N]") (("6" (replace*) (("6" (assert) (("6" (flatten) (("6" (replace*) (("6" (rewrite "pos_times_gt") (("6" (rewrite "neg_times_lt") (("6" (assert) (("6" (iff) (("6" (split +) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (split +) (("1" (assert) (("1" (lemma "both_sides_times_pos_ge2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "both_sides_times_neg_ge2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split +) (("1" (assert) (("1" (lemma "both_sides_times_neg_ge2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "both_sides_times_pos_ge2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_pos_ge2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_neg_ge2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_neg_le2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_pos_le2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (use "rem_sgn[2 * N]") (("7" (flatten) (("7" (assert) (("7" (rewrite "pos_times_ge") (("7" (rewrite "pos_times_gt") (("7" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("8" (flatten) (("8" (use "rem_sgn[2 * N]") (("8" (rewrite "neg_times_lt") (("8" (rewrite "neg_times_le") (("8" (reduce) nil nil)) nil)) nil)) nil)) nil) ("9" (rewrite "abs_mult") (("9" (rewrite "abs_mult") (("9" (use "rem_below_dvs[2 * N]") (("9" (assert) (("9" (rewrite "both_sides_times_pos_lt2") nil nil)) nil)) nil)) nil)) nil) ("10" (use "divrem_eq[2 * N]") (("10" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "rem_below_dvs[2 * N]") (("2" (assert) (("2" (expand "abs") (("2" (case "bv2int(BV!1) > 0") (("1" (assert) (("1" (case "bv2int(DVS!1) > 0") (("1" (assert) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_pos_lt2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1 // DVS!1)" "bv2int(DVS!1)") (("1" (assert) (("1" (lemma "both_sides_times_pos_gt2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVS!1)" "-bv2int(DVD!1 // DVS!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_pos_gt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1 // DVS!1)" "bv2int(DVS!1)") (("2" (assert) (("2" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) >= 0") (("1" (assert) nil nil) ("2" (rewrite "pos_times_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_pos_lt2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1 // DVS!1)" "bv2int(DVS!1)") (("1" (assert) (("1" (case " bv2int(BV!1) * bv2int(DVD!1 // DVS!1) <= 0") (("1" (assert) nil nil) ("2" (rewrite "neg_times_le") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_pos_lt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1//DVS!1)" "bv2int(DVS!1)") (("2" (assert) (("2" (lemma "both_sides_times_pos_lt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1 // DVS!1)" "-bv2int(DVS!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(DVS!1) > 0") (("1" (assert) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "both_sides_times_neg_lt2") (("1" (inst - "bv2int(BV!1)" "-bv2int(DVD!1 // DVS!1)" "bv2int(DVS!1)") (("1" (assert) (("1" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) >= 0") (("1" (assert) nil nil) ("2" (rewrite "pos_times_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_neg_lt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1 // DVS!1)" "bv2int(DVS!1)") (("2" (assert) (("2" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) <= 0") (("1" (assert) nil nil) ("2" (rewrite "neg_times_le") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (lemma "both_sides_times_neg_lt2") (("1" (inst - "bv2int(BV!1)" "bv2int(DVD!1 // DVS!1)" "bv2int(DVS!1)") (("1" (assert) (("1" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) >= 0") (("1" (assert) nil nil) ("2" (rewrite "pos_times_ge") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "both_sides_times_neg_lt2") (("2" (inst - "bv2int(BV!1)" "bv2int(DVD!1 // DVS!1)" "-bv2int(DVS!1)") (("2" (assert) (("2" (case "bv2int(BV!1) * bv2int(DVD!1 // DVS!1) <= 0") (("1" (assert) nil nil) ("2" (rewrite "neg_times_le") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_times_pos_gt2 formula-decl nil real_props nil) (both_sides_times_neg_lt2 formula-decl nil real_props nil) (divrem_uniqueness formula-decl nil BitvectorTwoComplementDivision nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (neg_times_lt formula-decl nil real_props nil) (both_sides_times_neg_le2 formula-decl nil real_props nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge2 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (both_sides_times_neg_ge2 formula-decl nil real_props nil) (pos_times_gt formula-decl nil real_props nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (abs_mult formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (pos_times_ge formula-decl nil real_props nil) (rem_sgn formula-decl nil BitvectorTwoComplementDivision nil) (neg_times_le formula-decl nil real_props nil) (rem_below_dvs formula-decl nil BitvectorTwoComplementDivision nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (bv2int_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (bv2int_inj formula-decl nil bv_int nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivisionWidenNarrow nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivisionWidenNarrow nil)) shostak)))
