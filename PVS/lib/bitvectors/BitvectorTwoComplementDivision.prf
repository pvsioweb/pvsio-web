(BitvectorTwoComplementDivision (IMP_BitvectorOneComplementDivision_TCC1 0 (IMP_BitvectorOneComplementDivision_TCC1-1 nil 3342837279 ("" (lemma "N_size") (("" (propax) nil nil)) nil) ((N_size formula-decl nil BitvectorTwoComplementDivision nil)) nil)) (IMP_BitvectorOneComplementDivision_TCC2 0 (IMP_BitvectorOneComplementDivision_TCC2-1 nil 3342837279 ("" (assuming-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil)) (DIVREM1_eq 0 (DIVREM1_eq-1 nil 3342837334 ("" (skolem!) (("" (use "divrem1_eq[2 * N]") (("" (lemma "bv2nat_times[N]") (("" (inst - "div(DVD!1, DVS!1)" "DVS!1") (("" (assert) (("" (replace -1 -2 rl) (("" (hide -1) (("" (use "bv_add[2 * N]") (("" (assert) (("" (rewrite "bv2nat_inj") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv_add formula-decl nil bv_arith_nat nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (+ const-decl "{bv: bvec[N] |
         bv2nat(bv) =
          IF bv2nat(bv1) + bv2nat(bv2) < exp2(N)
            THEN bv2nat(bv1) + bv2nat(bv2)
          ELSE bv2nat(bv1) + bv2nat(bv2) - exp2(N)
          ENDIF}" bv_arith_nat_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat_inj formula-decl nil bv_nat nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) shostak)) (div1_cancel 0 (div1_cancel-1 nil 3342837404 ("" (lemma "N_size") (("" (skosimp) (("" (case "bv2nat(DVS!1) = 0") (("1" (forward-chain "bv2nat_eq0[2 * N]") (("1" (replace -1) (("1" (rewrite "times_zero_second") (("1" (rewrite "div1_dvs0") (("1" (rewrite "div1_dvs0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2nat(div(BV!1 * DVD!1, BV!1 * DVS!1)) = bv2nat(div(DVD!1, DVS!1)) AND (bv2nat(DVS!1) /= 0 IMPLIES bv2nat(rem(BV!1 * DVD!1, BV!1 * DVS!1)) = bv2nat(BV!1 * rem(DVD!1, DVS!1)))") (("1" (flatten) (("1" (forward-chain "bv2nat_inj[2 * N]") (("1" (assert) (("1" (hide -1 -2) (("1" (forward-chain "bv2nat_inj[2 * N]") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "divrem1_uniqueness[2 * N]") (("2" (inst - "BV!1 * DVD!1" "BV!1 * DVS!1" "bv2nat(div(DVD!1,DVS!1))" "bv2nat(BV!1) * bv2nat(rem(DVD!1,DVS!1))") (("2" (assert) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (rewrite "bv2nat_times[N]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_times[N]") (("2" (use "rem1_below_dvs[2 * N]") (("2" (assert) (("2" (use "both_sides_times_pos_lt2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (rewrite "bv2nat_times[N]") (("3" (rewrite "bv2nat_times[N]") (("3" (assert) (("3" (use "divrem1_eq[2 * N]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_inj formula-decl nil bv_nat nil) (divrem1_uniqueness formula-decl nil BitvectorOneComplementDivision nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_times formula-decl nil BitvectorMultiplicationWidenNarrow nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (times_zero_second formula-decl nil BitvectorMultiplication nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (* const-decl "bvec[N]" BitvectorMultiplication nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (rem_dvs0 0 (rem_dvs0-2 "" 3369455199 ("" (lemma "N_size") (("" (skolem!) (("" (expand "//") (("" (rewrite "bv2int_fill_F[N]") (("" (assert) (("" (rewrite "rem1_dvs0[N]") (("" (rewrite "rem1_dvs0[N]") (("" (rewrite "bv_double_neg[N]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int_fill_F formula-decl nil bv_int nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak) (rem_dvs0-1 nil 3342837660 ("" (lemma "N_size") (("" (skolem!) (("" (expand "//") (("" (rewrite "bv2int_fill_F[N]") (("" (assert) (("" (rewrite "rem1_dvs0[N]") (("" (rewrite "rem1_dvs0[N]") (("" (rewrite "bv_double_neg") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int_fill_F formula-decl nil bv_int nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (div_dvs0 0 (div_dvs0-1 nil 3342837713 ("" (lemma "N_size") (("" (skolem!) (("" (expand "/") (("" (rewrite "bv2int_fill_F[N]") (("" (assert) (("" (rewrite "div1_dvs0[N]") (("" (rewrite "div1_dvs0[N]") (("" (lift-if) (("" (ground) (("" (hide 1) (("" (case "bv2int[N](-fill[N](TRUE)) = bv2int(one[N])") (("1" (use "bv2int_inj[N]") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "bv2int_one") (("2" (rewrite "bv2int_neg[N]") (("2" (rewrite "bv2int_fill_T[N]") (("2" (expand "minint") (("2" (typepred "exp2(N - 1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int_fill_F formula-decl nil bv_int nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (nil application-judgement "above(n)" exp2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (bv2int_fill_T formula-decl nil bv_int nil) (bv2int_one formula-decl nil BitvectorMultiplication nil) (bv2int_inj formula-decl nil bv_int nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (TRUE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (divrem_dvs1 0 (divrem_dvs1-2 "" 3369455365 ("" (lemma "N_size") (("" (skolem!) (("" (expand* "/" "//") (("" (rewrite "bv2int_one") (("" (assert) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (use "divrem1_dvs1[N]") nil nil)) nil) ("2" (flatten) (("2" (use "divrem1_dvs1[N]") (("2" (flatten) (("2" (assert) (("2" (replace*) (("2" (rewrite "bv_double_neg[N]") (("2" (rewrite "min_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int_one formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (min_fill_F formula-decl nil BitvectorUtil nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (divrem1_dvs1 formula-decl nil BitvectorOneComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak) (divrem_dvs1-1 nil 3342837838 ("" (lemma "N_size") (("" (skolem!) (("" (expand* "/" "//") (("" (rewrite "bv2int_one") (("" (assert) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (use "divrem1_dvs1[N]") nil nil)) nil) ("2" (flatten) (("2" (use "divrem1_dvs1[N]") (("2" (flatten) (("2" (assert) (("2" (replace*) (("2" (rewrite "bv_double_neg") (("2" (rewrite "min_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int_one formula-decl nil BitvectorMultiplication nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (min_fill_F formula-decl nil BitvectorUtil nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (divrem1_dvs1 formula-decl nil BitvectorOneComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (rem_below_dvs 0 (rem_below_dvs-2 "" 3510512631 ("" (lemma "N_size") (("" (skosimp) (("" (expand* "//" "abs") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (lift-if) (("1" (assert) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (use "rem1_below_dvs[N]") (("1" (expand "bv2int") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "rem1_below_dvs[N]") (("2" (assert) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "/=") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (forward-chain "bv2nat_eq0[N]") (("1" (replace -1) (("1" (rewrite "min_fill_F[N]") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv2int_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "bv2int") (("2" (reduce) (("2" (expand "exp2" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (rewrite "bv2int_neg[N]") (("1" (use "rem1_below_dvs[N]") (("1" (expand "bv2int") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "rem1_below_dvs[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "/=") (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (forward-chain "bv2nat_eq0[N]") (("1" (replace -1) (("1" (rewrite "min_fill_F[N]") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv2int_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "bv2int_neg[N]") (("2" (expand "minint") (("2" (expand "bv2int" 2) (("2" (lift-if 2) (("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "exp2" -1) (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (rem_below_dvs-1 nil 3342837916 ("" (lemma "N_size") (("" (skosimp) (("" (expand* "//" "abs") (("" (lift-if) (("" (split) (("1" (flatten) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (use "rem1_below_dvs[N]") (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "/=") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (forward-chain "bv2nat_eq0[N]") (("1" (replace -1) (("1" (rewrite "min_fill_F[N]") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv2int_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "bv2int") (("2" (reduce) (("2" (expand "exp2" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "rem1_below_dvs[N]") (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (use "rem1_below_dvs[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "/=") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (forward-chain "bv2nat_eq0[N]") (("1" (replace -1) (("1" (rewrite "min_fill_F[N]") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv2int_fill_F[N]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "bv2int_neg[N]") (("2" (expand "minint") (("2" (expand "bv2int" -) (("2" (lift-if -) (("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "exp2" -2) (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (rewrite "bv2int_neg[N]") (("2" (use "rem1_below_dvs[N]") (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int_neg formula-decl nil bv_arithmetic nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (exp2 def-decl "posnat" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (minus_int_is_int application-judgement "int" integers nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (min_fill_F formula-decl nil BitvectorUtil nil) (bv2int_fill_F formula-decl nil bv_int nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (/= const-decl "boolean" notequal nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (int_minus_int_is_int application-judgement "int" integers nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (divrem_eq_TCC1 0 (divrem_eq_TCC1-1 nil 3342837279 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (divrem_eq 0 (divrem_eq-2 "" 3369455657 ("" (lemma "N_size") (("" (skosimp) (("" (expand* "/" "//") (("" (case "bv2int(dvd!1) = IF bv2nat(dvd!1) < exp2(N - 1) THEN bv2nat(dvd!1) ELSE bv2nat(dvd!1) - exp2(N) ENDIF") (("1" (case "bv2int(dvs!1) = IF bv2nat(dvs!1) < exp2(N - 1) THEN bv2nat(dvs!1) ELSE bv2nat(dvs!1) - exp2(N) ENDIF") (("1" (case "bv2int[N](dvs!1) = 0") (("1" (assert) (("1" (lift-if -) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "bv2nat_eq0[N]") (("1" (inst - "dvs!1") (("1" (assert) (("1" (replace -1) (("1" (rewrite "rem1_dvs0") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "div1_dvs0") (("1" (rewrite "div1_dvs0") (("1" (rewrite "bv2int_neg[N]") (("1" (rewrite "bv2int_fill_T[N]") (("1" (rewrite "bv2int_fill_F[N]") (("1" (rewrite "bv_double_neg[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if -) (("2" (split) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (replace*) (("1" (expand "bv2int" +) (("1" (use "rem1_below_dvs[N]") (("1" (use "div1_below_dvd[N]") (("1" (assert) (("1" (use "divrem1_eq[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "rem1_below_dvs[N]") (("2" (use "div1_below_dvd[N]") (("2" (assert) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "exp2" -1) (("2" (assert) (("2" (expand "bv2int") (("2" (assert) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (use "divrem1_eq[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (expand "exp2" -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (lift-if) (("2" (ground) (("2" (expand "exp2" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (use "rem1_below_dvs[N]") (("1" (use "div1_below_dvd[N]") (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "/=") (("1" (assert) (("1" (use "divrem1_eq[N]") (("1" (assert) (("1" (expand "bv2int") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (expand "exp2" -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "rem1_below_dvs[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (lemma "div1_below_dvd[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) (("2" (lemma "divrem1_eq[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (assert) (("2" (expand "bv2int") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (case-replace "bv2nat(rem[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) (("1" (expand "exp2" -3) (("1" (case-replace "bv2nat(dvd!1) = exp2(N - 1)") (("1" (assert) (("1" (case-replace "bv2nat(dvs!1) = exp2(N) -1") (("1" (assert) nil nil) ("2" (case-replace "bv2nat[N](div[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) nil nil) ("2" (lemma "gt_times_gt_pos1") (("2" (inst - 1 "exp2(N-1)" "bv2nat[N](div[N](-dvd!1, -dvs!1))" "exp2(N) - bv2nat[N](dvs!1)") (("2" (assert) (("2" (case-replace "exp2(N) = 2 * exp2(N-1)") (("1" (assert) nil nil) ("2" (expand "exp2" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "exp2" -2) (("2" (case-replace "bv2nat(dvd!1) = exp2(N - 1)") (("1" (assert) (("1" (case-replace "bv2nat(dvs!1) = exp2(N) - 1") (("1" (assert) nil nil) ("2" (case-replace "bv2nat[N](div[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) nil nil) ("2" (lemma "gt_times_gt_pos1") (("2" (inst - 1 "exp2(N-1)" "bv2nat[N](div[N](-dvd!1, -dvs!1))" "exp2(N) - bv2nat[N](dvs!1)") (("2" (assert) (("2" (case-replace "exp2(N) = 2 * exp2(N-1)") (("1" (assert) nil nil) ("2" (expand "exp2" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bv2int") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "bv2int") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_F formula-decl nil bv_int nil) (int_times_even_is_even application-judgement "even_int" integers nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_T formula-decl nil bv_int nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (gt_times_gt_pos1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (div1_below_dvd formula-decl nil BitvectorOneComplementDivision nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak) (divrem_eq-1 nil 3342838258 ("" (lemma "N_size") (("" (skosimp) (("" (expand* "/" "//") (("" (case "bv2int(dvd!1) = IF bv2nat(dvd!1) < exp2(N - 1) THEN bv2nat(dvd!1) ELSE bv2nat(dvd!1) - exp2(N) ENDIF") (("1" (case "bv2int(dvs!1) = IF bv2nat(dvs!1) < exp2(N - 1) THEN bv2nat(dvs!1) ELSE bv2nat(dvs!1) - exp2(N) ENDIF") (("1" (case "bv2int[N](dvs!1) = 0") (("1" (assert) (("1" (lift-if -) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "bv2nat_eq0[N]") (("1" (inst - "dvs!1") (("1" (assert) (("1" (replace -1) (("1" (rewrite "rem1_dvs0") (("1" (rewrite "rem1_dvs0") (("1" (rewrite "div1_dvs0") (("1" (rewrite "div1_dvs0") (("1" (rewrite "bv2int_neg[N]") (("1" (rewrite "bv2int_fill_T[N]") (("1" (rewrite "bv2int_fill_F[N]") (("1" (rewrite "bv_double_neg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if -) (("2" (split) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (replace*) (("1" (expand "bv2int" +) (("1" (use "rem1_below_dvs[N]") (("1" (use "div1_below_dvd[N]") (("1" (assert) (("1" (use "divrem1_eq[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (use "rem1_below_dvs[N]") (("2" (use "div1_below_dvd[N]") (("2" (assert) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "exp2" -1) (("2" (assert) (("2" (expand "bv2int") (("2" (assert) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (use "divrem1_eq[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (expand "exp2" -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (lift-if) (("2" (ground) (("2" (expand "exp2" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (use "rem1_below_dvs[N]") (("1" (use "div1_below_dvd[N]") (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "/=") (("1" (assert) (("1" (use "divrem1_eq[N]") (("1" (assert) (("1" (expand "bv2int") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (expand "exp2" -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "rem1_below_dvs[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (lemma "div1_below_dvd[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) (("2" (lemma "divrem1_eq[N]") (("2" (inst - "-dvd!1" "-dvs!1") (("2" (assert) (("2" (expand "bv2int") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (case-replace "bv2nat(rem[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) (("1" (expand "exp2" -3) (("1" (case-replace "bv2nat(dvd!1) = exp2(N - 1)") (("1" (assert) (("1" (case-replace "bv2nat(dvs!1) = exp2(N) -1") (("1" (assert) nil nil) ("2" (case-replace "bv2nat[N](div[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) nil nil) ("2" (lemma "gt_times_gt_pos1") (("2" (inst - 1 "exp2(N-1)" "bv2nat[N](div[N](-dvd!1, -dvs!1))" "exp2(N) - bv2nat[N](dvs!1)") (("2" (assert) (("2" (case-replace "exp2(N) = 2 * exp2(N-1)") (("1" (assert) nil nil) ("2" (expand "exp2" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "exp2" -2) (("2" (case-replace "bv2nat(dvd!1) = exp2(N - 1)") (("1" (assert) (("1" (case-replace "bv2nat(dvs!1) = exp2(N) - 1") (("1" (assert) nil nil) ("2" (case-replace "bv2nat[N](div[N](-dvd!1, -dvs!1)) = 0") (("1" (assert) nil nil) ("2" (lemma "gt_times_gt_pos1") (("2" (inst - 1 "exp2(N-1)" "bv2nat[N](div[N](-dvd!1, -dvs!1))" "exp2(N) - bv2nat[N](dvs!1)") (("2" (assert) (("2" (case-replace "exp2(N) = 2 * exp2(N-1)") (("1" (assert) nil nil) ("2" (expand "exp2" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bv2int") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "bv2int") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_F formula-decl nil bv_int nil) (int_times_even_is_even application-judgement "even_int" integers nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_T formula-decl nil bv_int nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (gt_times_gt_pos1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (div1_below_dvd formula-decl nil BitvectorOneComplementDivision nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (divrem_overflow 0 (divrem_overflow-1 nil 3342839841 ("" (skosimp) (("" (expand* "/" "//") (("" (assert) (("" (case-replace "-dvs!1 = one") (("1" (use "divrem1_dvs1[N]") (("1" (flatten) (("1" (replace*) (("1" (rewrite "bv2int_neg[N]") (("1" (rewrite "bv2int_neg[N]") (("1" (rewrite "bv2int_fill_F[N]") (("1" (expand "minint") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (use "bv2int_neg[N]") (("2" (expand "minint") (("2" (lemma "N_size") (("2" (assert) (("2" (replace -3) (("2" (assert) (("2" (expand "bv2int" -2) (("2" (lift-if) (("2" (ground) (("2" (lemma "bv2nat_one[N]") (("2" (use "bv2nat_inj[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (minint const-decl "int" bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (bv2int_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_F formula-decl nil bv_int nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (divrem1_dvs1 formula-decl nil BitvectorOneComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bv2nat_inj formula-decl nil bv_nat nil) (bv2nat_one formula-decl nil BitvectorMultiplication nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (div_sgn 0 (div_sgn-1 nil 3342873608 ("" (lemma "N_size") (("" (skosimp) (("" (expand* "/" "abs") (("" (case "bv2int[N](dvs!1) > 0") (("1" (case "bv2int[N](dvd!1) >= 0") (("1" (assert) (("1" (use "div1_eq0[N]") (("1" (use "div1_below_dvd[N]") (("1" (expand "bv2int") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (use "div1_eq0[N]") (("2" (use "div1_below_dvd[N]") (("2" (assert) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "bv2int") (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (reduce) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int[N](dvd!1) >= 0") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (use "div1_eq0[N]") (("1" (use "div1_below_dvd[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "bv2int") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "exp2" 3 1) (("1" (expand "exp2" 3 15) (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "div1_eq0[N]") (("2" (use "div1_below_dvd[N]") (("2" (assert) (("2" (case "bv2nat(-dvs!1) /= 0") (("1" (assert) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lift-if) (("1" (split) (("1" (expand "bv2int") (("1" (reduce) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "bv2int") (("2" (expand "exp2" -2) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (case "bv2nat(div[N](-dvd!1, -dvs!1)) < exp2(N - 1)") (("1" (reduce) nil nil) ("2" (assert) (("2" (case-replace "bv2nat[N](div(-dvd!1, -dvs!1)) = exp2(N-1)") (("1" (hide -2 1 3 5) (("1" (use "divrem1_eq[N]") (("1" (replace -2) (("1" (case "exp2(N - 1) * bv2nat(-dvs!1) >= exp2(N)") (("1" (assert) nil nil) ("2" (hide -1) (("2" (case "bv2nat(-dvs!1) >= 2") (("1" (expand "exp2" 1 2) (("1" (assert) (("1" (lemma "both_sides_times_pos_ge1") (("1" (inst - "exp2(N - 1)" "bv2nat(-dvs!1)" 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "bv2nat(-dvs!1) = 1") (("1" (assert) (("1" (use "divrem1_dvs1[N]") (("1" (flatten) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "exp2" -3) (("1" (expand "exp2" 8 1) (("1" (case-replace "dvs!1 = -one[N]") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lemma "bv2nat_one[N]") (("1" (assert) nil nil)) nil)) nil) ("2" (case "bv2nat(-one[N]) = exp2(N) - 1") (("1" (use "bv2nat_inj[N]") (("1" (assert) (("1" (expand "exp2" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_minus_bv[N]") (("2" (lemma "bv2nat_one[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "exp2" -) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2 3 4 6) (("2" (flatten) (("2" (forward-chain "bv2nat_eq0[N]") (("2" (use "bv2nat_minus_bv[N]") (("2" (replace -2) (("2" (rewrite "bv2nat_fill_F[N]") (("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (div1_below_dvd formula-decl nil BitvectorOneComplementDivision nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (div1_eq0 formula-decl nil BitvectorOneComplementDivision nil) (/= const-decl "boolean" notequal nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (bv2nat_one formula-decl nil BitvectorMultiplication nil) (bv2nat_inj formula-decl nil bv_nat nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (divrem1_dvs1 formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (even_times_int_is_even application-judgement "even_int" integers nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (rem_sgn 0 (rem_sgn-2 "" 3369455921 ("" (lemma "N_size") (("" (skolem!) (("" (assert) (("" (case "bv2int(dvs!1) = 0") (("1" (expand "bv2int") (("1" (lift-if -) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (forward-chain "bv2nat_eq0[N]") (("1" (replace -1) (("1" (expand "//") (("1" (rewrite "bv2int_fill_F[N]") (("1" (assert) (("1" (lift-if) (("1" (rewrite "rem1_dvs0") (("1" (assert) (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv_double_neg[N]") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int(dvd!1) = -exp2(N - 1) AND bv2int(dvs!1) = -1") (("1" (use "divrem_overflow") (("1" (ground) nil nil)) nil) ("2" (use "div_sgn") (("2" (use "divrem_eq") (("2" (replace 1) (("2" (assert) (("2" (flatten) (("2" (case "bv2int(dvd!1 / dvs!1) = 0") (("1" (assert) (("1" (hide 1 2) (("1" (expand* "abs" "bv2int") (("1" (reduce) nil nil)) nil)) nil)) nil) ("2" (case "bv2int(dvd!1 / dvs!1) > 0") (("1" (assert) (("1" (hide 2 3) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "rem1_below_dvs[N]") (("1" (inst - "dvd!1" "dvs!1") (("1" (expand* "bv2int" "//") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 4) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "bv2int") (("2" (lift-if -) (("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if -) (("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split) (("1" (propax) nil nil) ("2" (split) (("1" (flatten) (("1" (assert) (("1" (expand "//") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lemma "rem1_below_dvs[N]") (("1" (inst - "-dvd!1" "-dvs!1") (("1" (assert) (("1" (split) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (reduce) nil nil)) nil) ("2" (flatten) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 3 4) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (expand "//") (("1" (use "rem1_below_dvs[N]") (("1" (assert) (("1" (split) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "bv2int") (("1" (smash) nil nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "bv2int[N](dvs!1) = 0") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "bv2int" 1) (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide 3) (("2" (expand "//") (("2" (use "rem1_below_dvs[N]") (("2" (assert) (("2" (split) (("1" (expand "bv2int" 1) (("1" (lift-if) (("1" (expand "bv2int") (("1" (reduce) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_F formula-decl nil bv_int nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (int_plus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (divrem_overflow formula-decl nil BitvectorTwoComplementDivision nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak) (rem_sgn-1 nil 3342883207 ("" (lemma "N_size") (("" (skolem!) (("" (assert) (("" (case "bv2int(dvs!1) = 0") (("1" (expand "bv2int") (("1" (lift-if -) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (forward-chain "bv2nat_eq0[N]") (("1" (replace -1) (("1" (expand "//") (("1" (rewrite "bv2int_fill_F[N]") (("1" (assert) (("1" (lift-if) (("1" (rewrite "rem1_dvs0") (("1" (assert) (("1" (rewrite "rem1_dvs0") (("1" (rewrite "bv_double_neg") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int(dvd!1) = -exp2(N - 1) AND bv2int(dvs!1) = -1") (("1" (use "divrem_overflow") (("1" (ground) nil nil)) nil) ("2" (use "div_sgn") (("2" (use "divrem_eq") (("2" (replace 1) (("2" (assert) (("2" (flatten) (("2" (case "bv2int(dvd!1 / dvs!1) = 0") (("1" (assert) (("1" (hide 1 2) (("1" (expand* "abs" "bv2int") (("1" (reduce) nil nil)) nil)) nil)) nil) ("2" (case "bv2int(dvd!1 / dvs!1) > 0") (("1" (assert) (("1" (hide 2 3) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (lemma "rem1_below_dvs[N]") (("1" (inst - "dvd!1" "dvs!1") (("1" (expand* "bv2int" "//") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 4) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "bv2int") (("2" (lift-if -) (("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if -) (("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split) (("1" (propax) nil nil) ("2" (split) (("1" (flatten) (("1" (assert) (("1" (expand "//") (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lemma "rem1_below_dvs[N]") (("1" (inst - "-dvd!1" "-dvs!1") (("1" (assert) (("1" (split) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (reduce) nil nil)) nil) ("2" (flatten) (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 3 4) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (expand "//") (("1" (use "rem1_below_dvs[N]") (("1" (assert) (("1" (split) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (expand "bv2int") (("1" (smash) nil nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "bv2int[N](dvs!1) = 0") (("2" (rewrite "bv2nat_minus_bv[N]") (("2" (expand "bv2int" 1) (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide 3) (("2" (expand "//") (("2" (use "rem1_below_dvs[N]") (("2" (assert) (("2" (split) (("1" (expand "bv2int" 1) (("1" (lift-if) (("1" (expand "bv2int") (("1" (reduce) (("1" (rewrite "bv2nat_minus_bv[N]") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bv2int") (("2" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (rem1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint[N] THEN bv2int(bv)
          ELSE -(bv2int(bv))
          ENDIF}" bv_arithmetic_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv_double_neg formula-decl nil bv_arithmetic nil) (bv2int_fill_F formula-decl nil bv_int nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_minus_bv formula-decl nil bv_arithmetic nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (int_plus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (divrem_overflow formula-decl nil BitvectorTwoComplementDivision nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (divrem_uniqueness 0 (divrem_uniqueness-1 nil 3342884879 ("" (lemma "N_size") (("" (skosimp) (("" (use "divrem_eq") (("" (use "rem_sgn") (("" (use "rem_below_dvs") (("" (use "div_sgn") (("" (replace 1) (("" (assert) (("" (flatten) (("" (lemma "unique_division") (("" (case "bv2int(dvd!1) > 0") (("1" (assert) (("1" (expand "abs") (("1" (case "bv2int(dvs!1) < 0") (("1" (assert) (("1" (inst - "-bv2int(dvs!1)" "-q!1" "-bv2int[N](dvd!1 / dvs!1)" "r!1" "bv2int[N](dvd!1 // dvs!1)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst - "bv2int(dvs!1)" "q!1" "bv2int[N](dvd!1 / dvs!1)" "r!1" "bv2int[N](dvd!1 // dvs!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int(dvd!1) < 0") (("1" (assert) (("1" (expand "abs") (("1" (case "bv2int(dvs!1) < 0") (("1" (assert) (("1" (inst - "-bv2int(dvs!1)" "q!1" "bv2int[N](dvd!1 / dvs!1)" "-r!1" "-bv2int[N](dvd!1 // dvs!1)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "bv2int(dvs!1)" "-q!1" "-bv2int[N](dvd!1 / dvs!1)" "-r!1" "-bv2int[N](dvd!1 // dvs!1)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem_sgn formula-decl nil BitvectorTwoComplementDivision nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (unique_division formula-decl nil euclidean_division nil) (dvd!1 skolem-const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (dvs!1 skolem-const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (r!1 skolem-const-decl "int" BitvectorTwoComplementDivision nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rem_below_dvs formula-decl nil BitvectorTwoComplementDivision nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)) (div_largest 0 (div_largest-1 nil 3342885465 ("" (lemma "N_size") (("" (skosimp) (("" (assert) (("" (case "bv2int(dvd!1) = -exp2(N-1) AND bv2int(dvs!1) = -1") (("1" (flatten) (("1" (replace*) (("1" (expand "abs") (("1" (assert) (("1" (use "divrem_overflow") (("1" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "divrem_eq") (("2" (replace 1) (("2" (assert) (("2" (expand "abs") (("2" (use "div_sgn") (("2" (use "rem_sgn") (("2" (use "rem_below_dvs") (("2" (replace*) (("2" (assert) (("2" (expand "abs") (("2" (flatten) (("2" (case "bv2int(dvs!1) > 0") (("1" (assert) (("1" (case "bv2int(dvd!1) > 0") (("1" (assert) (("1" (lift-if -) (("1" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "q!1 >= 0") (("1" (assert) (("1" (rewrite "neg_times_lt") (("1" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_lt") (("2" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "bv2int(dvd!1) = 0") (("1" (assert) (("1" (rewrite "neg_times_lt") (("1" (replace*) (("1" (case "q!1 >= 0") (("1" (assert) (("1" (rewrite "neg_times_le") nil nil)) nil) ("2" (assert) (("2" (lemma "pos_times_ge") (("2" (inst - "bv2int(dvs!1)" "q!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvd!1) <= -bv2int(dvs!1)") (("1" (assert) (("1" (case-replace "bv2int(dvd!1 // dvs!1) = 0") (("1" (assert) (("1" (rewrite "neg_times_lt") (("1" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * q!1 <= bv2int(dvs!1) * -bv2int[N](dvd!1 / dvs!1)") (("1" (rewrite "both_sides_times_pos_le2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * -q!1 <= bv2int(dvs!1) * -bv2int[N](dvd!1 / dvs!1)") (("1" (rewrite "both_sides_times_pos_le2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_lt") (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_lt") (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) + 1)") (("1" (rewrite "both_sides_times_pos_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "bv2int(dvd!1) > 0") (("1" (assert) (("1" (case-replace "q!1 = 0") (("1" (assert) nil nil) ("2" (rewrite "neg_times_lt") (("2" (case "bv2int(dvd!1) >= -bv2int(dvs!1)") (("1" (assert) (("1" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_lt") (("2" (case-replace "q!1 = 0") (("1" (assert) nil nil) ("2" (case-replace "bv2int(dvd!1) = 0") (("1" (assert) (("1" (replace*) (("1" (case "q!1 >= 0") (("1" (assert) (("1" (lemma "pos_times_ge") (("1" (inst - "bv2int(dvs!1)" "q!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "neg_times_le") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvd!1) <= bv2int(dvs!1)") (("1" (assert) (("1" (lift-if -) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "q!1 >= 0") (("1" (assert) (("1" (case "bv2int(dvs!1) * -q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "bv2int(dvs!1) * q!1 < bv2int(dvs!1) * (-bv2int[N](dvd!1 / dvs!1) - 1)") (("1" (rewrite "both_sides_times_neg_lt2") nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int_defs nil) (rng_2s_comp type-eq-decl nil bv_int_defs nil) (maxint const-decl "int" bv_int_defs nil) (minint const-decl "int" bv_int_defs nil) (<= const-decl "bool" reals nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorTwoComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (divrem_overflow formula-decl nil BitvectorTwoComplementDivision nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (rem_sgn formula-decl nil BitvectorTwoComplementDivision nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (neg_times_lt formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (pos_times_ge formula-decl nil real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (// const-decl "bvec[N]" BitvectorTwoComplementDivision nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_neg_lt2 formula-decl nil real_props nil) (int_times_even_is_even application-judgement "even_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rem_below_dvs formula-decl nil BitvectorTwoComplementDivision nil) (div_sgn formula-decl nil BitvectorTwoComplementDivision nil) (int_plus_int_is_int application-judgement "int" integers nil) (divrem_eq formula-decl nil BitvectorTwoComplementDivision nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (N_size formula-decl nil BitvectorTwoComplementDivision nil)) shostak)))
