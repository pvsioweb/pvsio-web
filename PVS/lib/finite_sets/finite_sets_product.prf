(finite_sets_product (mult_one_right 0 (mult_one_right-1 nil 3338292427 ("" (skolem!) (("" (lemma "one_identity") (("" (expand "identity?") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((one_identity formula-decl nil finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil) (identity? const-decl "bool" operator_defs nil)) shostak)) (mult_one_left 0 (mult_one_left-1 nil 3338292454 ("" (skolem!) (("" (lemma "one_identity") (("" (expand "identity?") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((one_identity formula-decl nil finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil) (identity? const-decl "bool" operator_defs nil)) shostak)) (mult_assoc 0 (mult_assoc-1 nil 3338292465 ("" (lemma "mult_ac") (("" (flatten) (("" (expand "associative?") (("" (propax) nil nil)) nil)) nil)) nil) ((associative? const-decl "bool" operator_defs nil) (mult_ac formula-decl nil finite_sets_product nil)) shostak)) (mult_comm 0 (mult_comm-1 nil 3338292482 ("" (lemma "mult_ac") (("" (flatten) (("" (expand "commutative?") (("" (propax) nil nil)) nil)) nil)) nil) ((commutative? const-decl "bool" operator_defs nil) (mult_ac formula-decl nil finite_sets_product nil)) shostak)) (product_TCC1 0 (product_TCC1-1 nil 3338292402 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets_product nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil)) (product_TCC2 0 (product_TCC2-1 nil 3338292402 ("" (skosimp) (("" (rewrite "card_rest") (("" (assert) nil nil)) nil)) nil) ((card_rest formula-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets_product nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (product_emptyset 0 (product_emptyset-1 nil 3338292549 ("" (grind) nil nil) ((emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (product def-decl "R" finite_sets_product nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product nil) (finite_emptyset name-judgement "finite_set" finite_sets nil)) shostak)) (product_singleton 0 (product_singleton-1 nil 3338292554 ("" (skosimp*) (("" (expand "product") (("" (auto-rewrite "choose_singleton[T]" "rest_singleton[T]" "product_emptyset") (("" (smash) (("" (rewrite "mult_one_right") nil nil)) nil)) nil)) nil)) nil) ((nonempty_singleton_finite application-judgement "non_empty_finite_set[T]" finite_sets_product nil) (product def-decl "R" finite_sets_product nil) (T formal-type-decl nil finite_sets_product nil) (choose_singleton formula-decl nil sets_lemmas nil) (rest_singleton formula-decl nil sets_lemmas nil) (product_emptyset formula-decl nil finite_sets_product nil) (mult_one_right formula-decl nil finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil)) shostak)) (product_x 0 (product_x-1 nil 3338292600 ("" (induct "S" :name "finite_set_induction_gen") (("" (auto-rewrite "card_rest" "card_remove" "nonempty?[T]") (("" (skosimp*) (("" (expand "product" 1 1) (("" (smash) (("1" (delete -1) (("1" (grind :exclude "product") nil nil)) nil) ("2" (inst-cp - "rest(S!1)") (("2" (inst - "remove(x!1, S!1)") (("2" (assert) (("2" (inst - "f!1" "choose(S!1)") (("1" (inst - "f!1" "x!1") (("1" (case-replace "remove(choose(S!1), remove(x!1, S!1)) = remove(x!1, rest(S!1))") (("1" (replace*) (("1" (rewrite "mult_assoc" :dir rl) (("1" (rewrite "mult_assoc" :dir rl) (("1" (lemma "mult_comm" ("r1" "f!1(x!1)" "r2" "f!1(choose(S!1))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (delete -1 -2 2 3) (("2" (grind-with-ext :exclude "choose") nil nil)) nil)) nil) ("2" (delete -1 2) (("2" (grind :exclude "choose") nil nil)) nil)) nil) ("2" (delete -1 2) (("2" (grind :exclude "choose") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "set" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (card_remove formula-decl nil finite_sets nil) (card_rest formula-decl nil finite_sets nil) (/= const-decl "boolean" notequal nil) (mult_comm formula-decl nil finite_sets_product nil) (mult_assoc formula-decl nil finite_sets_product nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (x!1 skolem-const-decl "(S!1)" finite_sets_product nil) (S!1 skolem-const-decl "finite_set[T]" finite_sets_product nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product nil) (finite_set_induction_gen formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product nil) (remove const-decl "set" sets nil) (* formal-const-decl "[R, R -> R]" finite_sets_product nil) (product def-decl "R" finite_sets_product nil) (= const-decl "[T, T -> boolean]" equalities nil) (R formal-type-decl nil finite_sets_product nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_remove application-judgement "finite_set[T]" finite_sets_product nil)) shostak)) (product_x1_x2 0 (product_x1_x2-1 nil 3338292844 ("" (skolem!) (("" (rewrite "product_x" :dir rl) (("" (rewrite "product_x" :dir rl) nil nil)) nil)) nil) ((product_x formula-decl nil finite_sets_product nil) (T formal-type-decl nil finite_sets_product nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (R formal-type-decl nil finite_sets_product nil)) shostak)) (product_add 0 (product_add-1 nil 3338292857 ("" (skolem!) (("" (smash) (("1" (rewrite "member_add") (("1" (rewrite "mult_one_right") nil nil)) nil) ("2" (use "product_x" ("S" "add(x!1, S!1)")) (("1" (rewrite "remove_add_member") (("1" (rewrite "mult_comm") nil nil)) nil) ("2" (expand "add") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((nonempty_add_finite application-judgement "non_empty_finite_set[T]" finite_sets_product nil) (mult_one_right formula-decl nil finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil) (product def-decl "R" finite_sets_product nil) (T formal-type-decl nil finite_sets_product nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member_add formula-decl nil sets_lemmas nil) (remove_add_member formula-decl nil sets_lemmas nil) (mult_comm formula-decl nil finite_sets_product nil) (S!1 skolem-const-decl "finite_set[T]" finite_sets_product nil) (x!1 skolem-const-decl "T" finite_sets_product nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (product_x formula-decl nil finite_sets_product nil)) shostak)) (product_remove 0 (product_remove-1 nil 3338292912 ("" (skolem!) (("" (smash) (("1" (use "product_x") (("1" (rewrite "mult_comm") (("1" (assert) nil nil)) nil) ("2" (expand "member") (("2" (propax) nil nil)) nil)) nil) ("2" (rewrite "member_remove") (("2" (rewrite "mult_one_right") nil nil)) nil)) nil)) nil) ((finite_remove application-judgement "finite_set[T]" finite_sets_product nil) (member const-decl "bool" sets nil) (remove const-decl "set" sets nil) (product def-decl "R" finite_sets_product nil) (mult_comm formula-decl nil finite_sets_product nil) (x!1 skolem-const-decl "T" finite_sets_product nil) (S!1 skolem-const-decl "finite_set[T]" finite_sets_product nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil) (product_x formula-decl nil finite_sets_product nil) (mult_one_right formula-decl nil finite_sets_product nil) (member_remove formula-decl nil sets_lemmas nil)) shostak)) (product_rest 0 (product_rest-1 nil 3338292948 ("" (skosimp) (("" (assert) (("" (expand "product" 2 2) (("" (propax) nil nil)) nil)) nil)) nil) ((finite_rest application-judgement "finite_set[T]" finite_sets_product nil) (product def-decl "R" finite_sets_product nil)) shostak)) (product_disj_union 0 (product_disj_union-1 nil 3338292980 ("" (skolem + ("A!1" _ "f!1")) (("" (auto-rewrite "union_empty[T]" "product_emptyset" "product_add" "mult_one_left" "mult_one_right" "mult_assoc" "member") (("" (induct "B" :name "finite_set_ind_modified") (("1" (assert) nil nil) ("2" (skosimp) (("2" (ground) (("1" (case-replace "union(A!1, add(e!1, S!1)) = add(e!1, union(A!1, S!1))") (("1" (smash) (("1" (delete -1 -2 2) (("1" (grind) nil nil)) nil) ("2" (replace -2) (("2" (assert) nil nil)) nil)) nil) ("2" (delete -1 -2 2 3) (("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (delete 2 3) (("2" (grind :if-match nil) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (mult_assoc formula-decl nil finite_sets_product nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (finite_intersection2 application-judgement "finite_set[T]" finite_sets_product nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set[T]" finite_sets_product nil) (nonempty_add_finite application-judgement "non_empty_finite_set[T]" finite_sets_product nil) (member const-decl "bool" sets nil) (product_add formula-decl nil finite_sets_product nil) (union_empty formula-decl nil sets_lemmas nil) (product_emptyset formula-decl nil finite_sets_product nil) (mult_one_right formula-decl nil finite_sets_product nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_set_ind_modified formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product nil) (* formal-const-decl "[R, R -> R]" finite_sets_product nil) (union const-decl "set" sets nil) (product def-decl "R" finite_sets_product nil) (= const-decl "[T, T -> boolean]" equalities nil) (R formal-type-decl nil finite_sets_product nil) (disjoint? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_union application-judgement "finite_set[T]" finite_sets_product nil)) shostak)) (product_diff_subset 0 (product_diff_subset-1 nil 3338293250 ("" (skosimp) (("" (forward-chain "union_diff_subset") (("" (use "product_disj_union" ("A" "A!1")) (("" (rewrite "difference_disjoint") (("" (ground) (("" (replace*) (("" (rewrite "mult_comm") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((union_diff_subset formula-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets_product nil) (difference_disjoint formula-decl nil sets_lemmas nil) (mult_comm formula-decl nil finite_sets_product nil) (product def-decl "R" finite_sets_product nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" finite_sets_product nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_union application-judgement "finite_set[T]" finite_sets_product nil) (finite_difference application-judgement "finite_set[T]" finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil) (difference const-decl "set" sets nil) (product_disj_union formula-decl nil finite_sets_product nil)) shostak)) (product_union 0 (product_union-1 nil 3338293288 ("" (auto-rewrite "union_subset1[T]" "intersection_subset1[T]" "mult_assoc") (("" (skolem!) (("" (lemma "product_diff_subset" ("f" "f!1")) (("" (inst-cp - "A!1" "union(A!1, B!1)") (("" (inst - "intersection(A!1, B!1)" "B!1") (("" (ground) (("1" (use "diff_union_inter") (("1" (rewrite "mult_comm" -2) (("1" (replace -2 + rl) (("1" (replace -3 + rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "intersection_commutative") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_union application-judgement "finite_set[T]" finite_sets_product nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" finite_sets_product nil) (union_subset1 formula-decl nil sets_lemmas nil) (finite_difference application-judgement "finite_set[T]" finite_sets_product nil) (difference const-decl "set" sets nil) (product def-decl "R" finite_sets_product nil) (mult_comm formula-decl nil finite_sets_product nil) (mult_assoc formula-decl nil finite_sets_product nil) (diff_union_inter formula-decl nil sets_lemmas nil) (intersection_subset1 formula-decl nil sets_lemmas nil) (intersection_commutative formula-decl nil sets_lemmas nil) (intersection const-decl "set" sets nil) (finite_intersection2 application-judgement "finite_set[T]" finite_sets_product nil) (product_diff_subset formula-decl nil finite_sets_product nil) (T formal-type-decl nil finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil)) shostak)) (product_diff_intersection 0 (product_diff_intersection-1 nil 3338293447 ("" (skolem!) (("" (auto-rewrite "product_emptyset" "mult_one_right" "mult_one_left" "mult_assoc") (("" (rewrite "product_union" :dir rl) (("" (case-replace "union(difference(A!1, B!1), intersection(A!1, B!1)) = A!1") (("1" (case-replace "intersection(difference(A!1, B!1), intersection(A!1, B!1)) = emptyset") (("1" (assert) nil nil) ("2" (delete -1 2) (("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (delete 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil) ((union const-decl "set" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (member const-decl "bool" sets nil) (product_emptyset formula-decl nil finite_sets_product nil) (mult_one_right formula-decl nil finite_sets_product nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (finite_union application-judgement "finite_set[T]" finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil) (intersection const-decl "set" sets nil) (difference const-decl "set" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_product nil) (product_union formula-decl nil finite_sets_product nil) (finite_intersection2 application-judgement "finite_set[T]" finite_sets_product nil) (finite_difference application-judgement "finite_set[T]" finite_sets_product nil)) shostak)) (product_f_g 0 (product_f_g-2 "" 3343405863 ("" (auto-rewrite "product_emptyset" "product_add" "member") (("" (skolem + (_ "f!1" "g!1")) (("" (induct "S" :name "finite_set_ind_modified") (("1" (assert) nil nil) ("2" (skosimp) (("2" (ground) (("1" (inst?) (("1" (assert) nil nil) ("2" (expand "add") (("2" (propax) nil nil)) nil)) nil) ("2" (delete 2 3) (("2" (grind :if-match nil) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (e!1 skolem-const-decl "T" finite_sets_product nil) (S!1 skolem-const-decl "finite_set[T]" finite_sets_product nil) (nonempty_add_finite application-judgement "non_empty_finite_set[T]" finite_sets_product nil) (member const-decl "bool" sets nil) (product_add formula-decl nil finite_sets_product nil) (product_emptyset formula-decl nil finite_sets_product nil) (finite_set_ind_modified formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product nil) (product def-decl "R" finite_sets_product nil) (= const-decl "[T, T -> boolean]" equalities nil) (R formal-type-decl nil finite_sets_product nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak) (product_f_g-1 nil 3338293513 ("" (auto-rewrite "product_emptyset" "product_add" "member") (("" (skolem + (_ "f!1" "g!1")) (("" (induct "S" :name "finite_set_ind_modified") (("1" (assert) nil nil) ("2" (skosimp) (("2" (ground) (("1" (inst?) (("1" (assert) nil nil) ("2" (expand "add") (("2" (propax) nil nil)) nil)) nil) ("2" (delete 2 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[T]" finite_sets_product nil) (member const-decl "bool" sets nil) (product_add formula-decl nil finite_sets_product nil) (product_emptyset formula-decl nil finite_sets_product nil) nil (T formal-type-decl nil finite_sets_product nil) (product def-decl "R" finite_sets_product nil) (= const-decl "[T, T -> boolean]" equalities nil) (R formal-type-decl nil finite_sets_product nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (product_particular 0 (product_particular-1 nil 3338293593 ("" (auto-rewrite "mult_one_right" "mult_one_left") (("" (skolem!) (("" (smash) (("1" (use "product_x") (("1" (use "product_x" ("f" "f!1 WITH [x!1 := one]")) (("1" (assert) (("1" (rewrite "mult_comm" -2) (("1" (use "product_f_g" ("S" "remove(x!1, S!1)" "f" "f!1")) (("1" (assert) (("1" (delete -1 -2 -3 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_f_g") nil nil)) nil)) nil)) nil) ((product_x formula-decl nil finite_sets_product nil) (R formal-type-decl nil finite_sets_product nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_product nil) (finite_remove application-judgement "finite_set[T]" finite_sets_product nil) (mult_one_left formula-decl nil finite_sets_product nil) (product_f_g formula-decl nil finite_sets_product nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (member const-decl "bool" sets nil) (mult_comm formula-decl nil finite_sets_product nil) (product def-decl "R" finite_sets_product nil) (remove const-decl "set" sets nil) (one formal-const-decl "R" finite_sets_product nil) (mult_one_right formula-decl nil finite_sets_product nil)) shostak)) (product_distributive 0 (product_distributive-1 nil 3338293665 ("" (auto-rewrite "product_emptyset" "product_add" "mult_one_right" "mult_one_left" "mult_assoc" "member") (("" (skolem + (_ "f!1" "g!1")) (("" (induct "A" :name "finite_set_ind_modified") (("1" (assert) nil nil) ("2" (skosimp) (("2" (assert) (("2" (replace -1 + rl) (("2" (lemma "mult_comm" ("r1" "f!1(e!1)" "r2" "product(S!1, g!1) * g!1(e!1)")) (("2" (lemma "mult_comm" ("r1" "f!1(e!1)" "r2" "g!1(e!1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mult_comm formula-decl nil finite_sets_product nil) (mult_assoc formula-decl nil finite_sets_product nil) (product_add formula-decl nil finite_sets_product nil) (member const-decl "bool" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[T]" finite_sets_product nil) (product_emptyset formula-decl nil finite_sets_product nil) (mult_one_left formula-decl nil finite_sets_product nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_set_ind_modified formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product nil) (product def-decl "R" finite_sets_product nil) (* formal-const-decl "[R, R -> R]" finite_sets_product nil) (= const-decl "[T, T -> boolean]" equalities nil) (R formal-type-decl nil finite_sets_product nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)))
