(finite_sets_product_real (IMP_finite_sets_product_TCC1 0 (IMP_finite_sets_product_TCC1-1 nil 3338293772 ("" (grind) nil nil) ((restrict const-decl "R" restrict nil) (identity? const-decl "bool" operator_defs nil)) nil)) (IMP_finite_sets_product_TCC2 0 (IMP_finite_sets_product_TCC2-1 nil 3338293772 ("" (grind) nil nil) ((real_times_real_is_real application-judgement "real" reals nil) (associative? const-decl "bool" operator_defs nil) (commutative? const-decl "bool" operator_defs nil) (restrict const-decl "R" restrict nil)) nil)) (product_const_TCC1 0 (product_const_TCC1-1 nil 3411842016 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets_product_real nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (/= const-decl "boolean" notequal nil)) nil)) (product_const 0 (product_const-1 nil 3338293808 ("" (induct "S" :name "finite_set_induction_rest") (("1" (skosimp*) (("1" (auto-rewrite-theory "sets[T]") (("1" (assert) (("1" (rewrite "card_emptyset") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "product" +) (("2" (inst?) (("2" (replace -1) (("2" (use "card_rest") (("2" (assert) (("2" (assert) (("2" (replace -1) (("2" (hide -) (("2" (lemma "expt_plus") (("2" (inst?) (("1" (inst - "1") (("1" (assert) (("1" (replace -1 * lr) (("1" (hide -1) (("1" (expand "^" 1 3) (("1" (expand "expt") (("1" (assert) (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (expand "^") (("2" (expand "expt") (("2" (assert) (("2" (expand "expt") (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ((card_rest formula-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (c!1 skolem-const-decl "real" finite_sets_product_real nil) (nzreal nonempty-type-eq-decl nil reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (nat_expt application-judgement "nat" exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (expt def-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (card_emptyset formula-decl nil finite_sets nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (^ const-decl "real" exponentiation nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pred type-eq-decl nil defined_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (product_1_is_card 0 (product_1_is_card-1 nil 3338293922 ("" (skolem!) (("" (use "product_const") (("" (rewrite "expt_1i") nil nil)) nil)) nil) ((product_const formula-decl nil finite_sets_product_real nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_product_real nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (expt_1i formula-decl nil exponentiation nil)) shostak)) (product_mult 0 (product_mult-1 nil 3338293973 ("" (induct "S" :name "finite_set_induction_rest") (("1" (skosimp*) (("1" (rewrite "card_emptyset") (("1" (expand "product") (("1" (expand "empty?") (("1" (expand "member") (("1" (expand "emptyset") (("1" (expand "^") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "product" +) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (lemma "card_rest") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (lemma "expt_plus") (("2" (inst?) (("1" (inst - "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "expt_x1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (assert) (("2" (expand "^") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (card_rest formula-decl nil finite_sets nil) (expt_plus formula-decl nil exponentiation nil) (nat_exp application-judgement "nat" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (c!1 skolem-const-decl "real" finite_sets_product_real nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil) (member const-decl "bool" sets nil) (expt def-decl "real" exponentiation nil) (emptyset const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (card_emptyset formula-decl nil finite_sets nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (^ const-decl "real" exponentiation nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pred type-eq-decl nil defined_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (product_eq_0 0 (product_eq_0-1 nil 3412954570 ("" (induct "S" :name "finite_set_induction_rest") (("1" (skosimp) (("1" (rewrite "product_emptyset") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (expand "product" -2) (("2" (mult-cases -2) (("1" (inst + "choose(SS!1)") nil nil) ("2" (skosimp*) (("2" (typepred "t!1") (("2" (inst + "t!1") (("2" (lemma "rest_member") (("2" (expand "member") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SS!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_product_real nil) (t!1 skolem-const-decl "(rest(SS!1))" finite_sets_product_real nil) (member const-decl "bool" sets nil) (rest_member formula-decl nil sets_lemmas nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (zero_times3 formula-decl nil real_props nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rest const-decl "set" sets nil) (product_emptyset formula-decl nil finite_sets_product nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (product_empty? 0 (product_empty?-1 nil 3338294103 ("" (skosimp) (("" (rewrite "emptyset_is_empty?[T]") (("" (use "product_emptyset[T, real, 1, *]") (("" (assert) nil nil)) nil)) nil)) nil) ((emptyset_is_empty? formula-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets_product_real nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (product_emptyset formula-decl nil finite_sets_product nil)) shostak)) (product_emptyset_rew 0 (product_emptyset_rew-1 nil 3338294141 ("" (skosimp) (("" (use "product_emptyset[T, real, 1, *]") (("" (assert) nil nil)) nil)) nil) ((product_emptyset formula-decl nil finite_sets_product nil) (T formal-type-decl nil finite_sets_product_real nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil)) shostak)) (product_singleton_rew 0 (product_singleton_rew-1 nil 3338294160 ("" (skosimp) (("" (rewrite "card_one") (("" (skolem!) (("" (replace -1) (("" (rewrite "product_singleton[T, real, 1, *]") (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_one formula-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets_product_real nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[T]" finite_sets_product_real nil) (singleton const-decl "(singleton?)" sets nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (product_singleton formula-decl nil finite_sets_product nil)) shostak)) (product_remove_rew 0 (product_remove_rew-1 nil 3338294211 ("" (skosimp*) (("" (use "product_remove[T, real, 1, *]") (("" (replace -1 * rl) (("" (hide -1) (("" (assert) (("" (lift-if) (("" (assert) (("" (auto-rewrite-theory "sets[T]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((product_remove formula-decl nil finite_sets_product nil) (T formal-type-decl nil finite_sets_product_real nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (member const-decl "bool" sets nil) (finite_remove application-judgement "finite_set[T]" finite_sets_product_real nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (product_rest_rew_TCC1 0 (product_rest_rew_TCC1-1 nil 3411926400 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil finite_sets_product_real nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil)) (product_rest_rew 0 (product_rest_rew-1 nil 3338294278 ("" (skosimp) (("" (use "product_rest") (("" (assert) nil nil)) nil)) nil) ((product_rest formula-decl nil finite_sets_product nil) (T formal-type-decl nil finite_sets_product_real nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) shostak)) (product_union_rew 0 (product_union_rew-1 nil 3338294308 ("" (skolem!) (("" (use "product_union") (("" (assert) nil nil)) nil)) nil) ((bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (finite_intersection1 application-judgement "finite_set[T]" finite_sets_product_real nil) (finite_union application-judgement "finite_set[T]" finite_sets_product_real nil) (product_union formula-decl nil finite_sets_product nil) (T formal-type-decl nil finite_sets_product_real nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (product_eq_funs 0 (product_eq_funs-1 nil 3338294327 ("" (skosimp) (("" (rewrite "product_f_g") nil nil)) nil) ((product_f_g formula-decl nil finite_sets_product nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets_product_real nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (product_particular_gen 0 (product_particular_gen-1 nil 3338294347 ("" (auto-rewrite "member") (("" (induct "S" :name "finite_set_induction_rest[T]") (("1" (skolem!) (("1" (rewrite "product_emptyset") (("1" (rewrite "product_emptyset") (("1" (expand "emptyset") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "product" +) (("2" (lift-if) (("2" (inst?) (("2" (split +) (("1" (flatten) (("1" (lift-if) (("1" (assert) (("1" (lemma "choose_not_member") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lift-if) (("2" (assert) (("2" (case-replace "rest(SS!1)(t!1)") (("1" (assert) (("1" (lift-if) (("1" (lemma "rest_member") (("1" (assert) (("1" (inst - "SS!1" "t!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (lemma "choose_rest_or") (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (product def-decl "R" finite_sets_product nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (T formal-type-decl nil finite_sets_product_real nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (product_emptyset formula-decl nil finite_sets_product nil) (emptyset const-decl "set" sets nil) (rest const-decl "set" sets nil) (rest_member formula-decl nil sets_lemmas nil) (choose_rest_or formula-decl nil sets_lemmas nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (choose_not_member formula-decl nil sets_lemmas nil)) shostak)) (product_nonneg 0 (product_nonneg-1 nil 3338294965 ("" (induct "S" :name "finite_set_induction_rest") (("1" (skosimp) (("1" (rewrite "product_emptyset") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "product" +) (("2" (inst?) (("2" (split) (("1" (inst - "choose(SS!1)") (("1" (assert) (("1" (mult-ineq -1 -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "t!1") (("2" (use "rest_member[T]") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest_member formula-decl nil sets_lemmas nil) (t!1 skolem-const-decl "(rest(SS!1))" finite_sets_product_real nil) (SS!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_product_real nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (rest const-decl "set" sets nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (ge_times_ge_any1 formula-decl nil extra_real_props nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (product_emptyset formula-decl nil finite_sets_product nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (product_pos 0 (product_pos-1 nil 3338295061 ("" (induct "S" :name "finite_set_induction_rest") (("1" (skolem!) nil nil) ("2" (skosimp*) (("2" (expand "product" +) (("2" (inst?) (("2" (split) (("1" (inst - "choose(SS!1)") (("1" (assert) (("1" (mult-ineq -1 -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1) (("2" (rewrite "product_emptyset") (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skolem-typepred) (("3" (inst?) (("3" (use "rest_member[T]") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SS!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_product_real nil) (t!1 skolem-const-decl "(rest(SS!1))" finite_sets_product_real nil) (member const-decl "bool" sets nil) (rest_member formula-decl nil sets_lemmas nil) (product_emptyset formula-decl nil finite_sets_product nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (rest const-decl "set" sets nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (emptyset const-decl "set" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (product_nz 0 (product_nz-1 nil 3412700867 ("" (induct "SS" :name "finite_set_induction_rest") (("1" (skolem!) (("1" (flatten) (("1" (rewrite "product_empty?") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (induct "SS" :name "finite_set_induction_rest") (("1" (skosimp*) (("1" (inst?) (("1" (assert) (("1" (hide -1) (("1" (case "empty?[T](rest(SS!1))") (("1" (hide -2) (("1" (expand "product") (("1" (rewrite "product_empty?") (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "product" -3) (("2" (inst?) (("2" (assert) (("2" (split -1) (("1" (mult-cases -3) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("1" (assert) nil nil) ("2" (assert) (("2" (typepred "t!1") (("2" (lemma "rest_member") (("2" (inst?) (("2" (expand "member") (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (replace -2) (("3" (case "empty?[T](rest(SS!1))") (("1" (hide -2) (("1" (expand "product") (("1" (mult-cases -3) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (rewrite "product_empty?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst?) (("2" (split -1) (("1" (flatten) (("1" (expand "product" -2) (("1" (mult-cases -2) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("1" (assert) nil nil) ("2" (typepred "t!1") (("2" (lemma "rest_member") (("2" (inst?) (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (rest const-decl "set" sets nil) (zero_times3 formula-decl nil real_props nil) (SS!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_product_real nil) (t!1 skolem-const-decl "(rest(SS!1))" finite_sets_product_real nil) (rest_member formula-decl nil sets_lemmas nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (t!1 skolem-const-decl "(rest(SS!1))" finite_sets_product_real nil) (SS!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_product_real nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil) (product_empty? formula-decl nil finite_sets_product_real nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (product_posreal 0 (product_posreal-1 nil 3411927050 ("" (auto-rewrite-theory "rationals") (("" (auto-rewrite-theory "integers") (("" (induct "A" :name "finite_set_induction_rest") (("1" (typepred "A!1") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (hide 2) (("2" (rewrite "emptyset_is_empty?[T]") nil nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (split) (("1" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "product" +) (("1" (assert) (("1" (typepred "f!1(choose(SS!1))") (("1" (case "f!1(choose(SS!1)) * product(rest(SS!1), f!1) > 0") (("1" (assert) nil nil) ("2" (hide 3) (("2" (mult-ineq -2 -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "product" +) (("2" (typepred "f!1(choose(SS!1))") (("2" (case-replace "rest(SS!1) = emptyset") (("1" (hide -1) (("1" (rewrite "product_emptyset") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1 -2 2 3) (("2" (rewrite "emptyset_is_empty?[T]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (rest const-decl "set" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (product_emptyset formula-decl nil finite_sets_product nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil) (emptyset const-decl "set" sets nil) (emptyset_is_empty? formula-decl nil sets_lemmas nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (product_int 0 (product_int-2 nil 3411927334 ("" (auto-rewrite-theory "rationals") (("" (auto-rewrite-theory "integers") (("" (induct-and-simplify "x1" :name "finite_set_induction_rest") (("" (induct-and-simplify "A" :name "finite_set_induction_rest") nil nil)) nil)) nil)) nil) ((closed_times formula-decl nil integers nil) (closed_times formula-decl nil rationals nil) (remove const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (rest const-decl "set" sets nil) (finite_remove application-judgement "finite_set[T]" finite_sets_product_real nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil)) nil) (product_int-1 nil 3411927217 ("" (judgement-tcc) nil nil) nil nil)) (product_nat 0 (product_nat-2 nil 3411927754 ("" (auto-rewrite-theory "rationals") (("" (induct-and-simplify "A" :name "finite_set_induction_rest" :exclude "choose") (("" (typepred "f!1(choose(SS!1))") (("" (mult-ineq -1 -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set[T]" finite_sets_product_real nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (product_int application-judgement "int" finite_sets_product_real nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (remove const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (rest const-decl "set" sets nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (finite_remove application-judgement "finite_set[T]" finite_sets_product_real nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (ge_times_ge_any1 formula-decl nil extra_real_props nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil) (product_nat-1 nil 3411927478 ("" (judgement-tcc) nil nil) nil nil)) (product_eq_1 0 (product_eq_1-1 nil 3412954838 ("" (induct "S" :name "finite_set_induction_rest") (("1" (skosimp*) (("1" (typepred "t!1") (("1" (expand "emptyset") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (expand "product" -2) (("2" (lemma "product_1") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (typepred "t!1") (("2" (assert) (("2" (inst -4 "t!1") (("2" (assert) (("2" (lemma "choose_rest_or") (("2" (expand "member") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((product_nat application-judgement "nat" finite_sets_product_real nil) (finite_rest application-judgement "finite_set[T]" finite_sets_product_real nil) (rest const-decl "set" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (choose_rest_or formula-decl nil sets_lemmas nil) (t!1 skolem-const-decl "(SS!1)" finite_sets_product_real nil) (SS!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_product_real nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (product_1 formula-decl nil real_props nil) (emptyset const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (T formal-type-decl nil finite_sets_product_real nil) (product def-decl "R" finite_sets_product nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil)) nil)) (product_TCC1 0 (product_TCC1-1 nil 3338293772 ("" (skeep) (("" (rewrite "product_nonneg") (("" (skosimp*) (("" (typepred "f(t!1)") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((product_nonneg formula-decl nil finite_sets_product_real nil) (T formal-type-decl nil finite_sets_product_real nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil)) (product_TCC2 0 (product_TCC2-1 nil 3338293772 ("" (skosimp*) (("" (lemma "product_pos") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((product_pos formula-decl nil finite_sets_product_real nil) (product_posreal application-judgement "posreal" finite_sets_product_real nil) (product_nat application-judgement "nat" finite_sets_product_real nil) (nil application-judgement "nonneg_real" finite_sets_product_real nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_product_real nil)) nil)))
