<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on January 14, 2013 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>PVS Release Notes: PVS 6.0 Release Notes</title>

<meta name="description" content="PVS Release Notes: PVS 6.0 Release Notes">
<meta name="keywords" content="PVS Release Notes: PVS 6.0 Release Notes">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="pvs-release-notes.html#Top" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_2.html#PVS-5_002e0-Release-Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="pvs-release-notes.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<hr size="2">
<a name="PVS-6_002e0-Release-Notes"></a>
<a name="PVS-6_002e0-Release-Notes-1"></a>
<h1 class="unnumbered">PVS 6.0 Release Notes</h1>

<p>PVS 6.0 is a significant new release of PVS.  The highlights include
declaration parameters, better numeric simplification, Unicode character
support, and full integration of NASA packages.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#g_t6_002e0-Installation-Notes">Installation Notes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#g_t6_002e0-New-Features">New Features</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#g_t6_002e0-Incompatibilities">Incompatibilities</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="g_t6_002e0-Installation-Notes"></a>
<a name="Installation-Notes-1"></a>
<h2 class="section">Installation Notes</h2>

<p>The system is installed as usual; see the download pages at
</p><table><tr><td>&nbsp;</td><td><pre class="example"><a href="http://pvs.csl.sri.com/download.shtml">http://pvs.csl.sri.com/download.shtml</a>
</pre></td></tr></table>
<p>We strongly suggest getting a pre-built Allegro version, unless you have
concerns with the Allegro runtime click-though license, in which case get
one of the SBCL Lisp images.  It is possible to build from sources, but it
can be sensitive to the platform environment.  If you decide to try it and
run into problems, let us know at <a href="mailto:pvs-bugs@csl.sri.com">pvs-bugs@csl.sri.com</a>.
PVS 6.0 is built with Allegro CL 9.0 and SBCL 1.0.47.  It is available for
Linux 32- and 64-bit machines, and Mac 64-bit.
Note that because CMU Lisp lacks support for both 64-bit Linux and
Unicode, we no longer provide that image.
</p>
<hr size="6">
<a name="g_t6_002e0-New-Features"></a>
<a name="New-Features-5"></a>
<h2 class="section">New Features</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Declaration-Parameters">Declaration Parameters</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Better-Numeric-Simplification">Better Numeric Simplification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Controlling-Assert-Post_002dprocessing">Controlling Assert Post-processing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Unicode-Support">Unicode Support</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Loading-Patches">Loading Patches</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#PVSio_002dProofLite_002dField">PVSio, ProofLite, Field, and Manip</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Theory-Interpretation-Changes">Theory Interpretation Changes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#finite_005fsets-allowed-in-recursive-types">Recursive types and <code>finite_sets</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#recursive_002dtype_002dsubterm-strict_005fwell_005ffounded">Datatype subterms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Declaration-Parameters"></a>
<a name="Declaration-Parameters-1"></a>
<h3 class="subsection">Declaration Parameters</h3>
<p>PVS has theory level parameters, which allow generic theories to be
defined.  They are very useful, and are used extensively, but there are
situations where they are not so convenient.  In particular, because of
the way that Why3 (<a href="http://why3.lri.fr/">http://why3.lri.fr/</a>) generates
theories, it was becoming increasingly difficult to support PVS.
Declaration parameters solve these problems.
</p>
<hr size="6">
<a name="Declaration-Parameter-Examples"></a>
<h4 class="subsubsection">Declaration Parameter Examples</h4>
<p>For example, the theory of groups may be introduced as
</p><table><tr><td>&nbsp;</td><td><pre class="example">groups[T: TYPE, *: [T,T -&gt; T], one: T]: THEORY
</pre></td></tr></table>
<p>Basic facts may be given, after which it is natural to define
homomorphisms.  But to define these over two (possibly) distinct groups,
the theory requires two sets of parameters, hence another theory:
</p><table><tr><td>&nbsp;</td><td><pre class="example">homomorphism_lemmas[T1: TYPE, *: [T1,T1 -&gt; T1], one1: T1,
                    T2: TYPE, o: [T2,T2 -&gt; T2], one2: T2]: THEORY
</pre></td></tr></table>
<p>This seemingly minor inconvenience is made much worse when stating
that homomorphisms are associative, which now requires yet another theory
with four sets of parameters.  At this point getting the parameters and
importings right, while at the same time trying to follow a standard
mathematical presentation of group theory becomes extremely difficult.
</p>
<p>PVS 6.0 solves this by providing declaration parameters.  These are
similar to theory parameters in form, but their scope is just the
associated declaration.  The following exemplifies this with a somewhat
different formulation of groups.  Note that everything is within a single
theory.  This is mostly for illustrative purposes, there are many possible
representations of groups in PVS; choosing one depends on the use to be
made of it.
</p><table><tr><td>&nbsp;</td><td><pre class="example">groups: theory
begin
 G[t: type+]: type+ from t
 assocG[t: type+]: type = (associative?[G[t]])
 idG[t: type+](op: assocG[t]): type = (identity?[G[t]](op))
 inverseG?[t: type+](op: assocG[t], id: idG[t](op))
                    (inv: [G[t] -&gt; G[t]]): bool
    = inverses?[G[t]](op)(inv)(id)
 inverseG[t: type+](op: assocG[t], id: idG[t](op)): type
    = (inverseG?(op, id))
 +[t: type+]: assocG[t]
 0[t: type+]: idG[t](+[t])
 -[t: type+]: inverseG[t](+[t], 0[t])

 hom?[t1, t2: type+](h: [G[t1] -&gt; G[t2]]): bool =
   h(0) = 0 and
   forall (a, b: G[t1]): h(a + b) = h(a) + h(b) and
   forall (a: G[t1]): h(-a) = -h(a)

 hom_is_assoc[t1, t2, t3, t4: type+]: lemma
   forall (f: (hom?[t1, t2]), g: (hom?[t2, t3]), h: (hom?[t3, t4])):
     h o (g o f) = (h o g) o f
end groups
</pre></td></tr></table>

<p>Currently declaration parameters are restricted to types, this will likely
be extended in the future.  One of the Why3 examples is
</p><table><tr><td>&nbsp;</td><td><pre class="example">whyex: theory
begin

 ilist[t: type]: datatype
  begin
   inull: inull?
   icons(icar: t, icdr: ilist): icons?
  end ilist

 length[t: type](l: ilist[t]): RECURSIVE nat =
    CASES l OF
      inull: 0,
      icons(x, y): length(y) + 1
    ENDCASES
   MEASURE reduce_nat(0, (LAMBDA (x: t), (n: nat): n + 1))

  inth[t: type](l: ilist[t], (n:below[length(l)])): RECURSIVE t =
    IF n = 0 THEN icar(l) ELSE inth(icdr(l), n-1) ENDIF
   MEASURE length(l)

 mem[t: type](x: t, l: ilist[t]): recursive bool =
   cases l of
     inull: false,
     icons(y, ll): x = y OR mem(x, ll)
   endcases
  measure length(l)

 mem_inth[t: type]: lemma
   forall (x: t, l: ilist[t]):
     mem(x, l) iff (exists (n: below(length(l))): x = inth(l, n))
  
 sorted(l: ilist[int]): bool =
   forall (n, m: below(length(l))): n &lt; m =&gt; inth(l, n) &lt;= inth(l, m)
 sorted_mem: lemma
   forall (x: int, l: ilist[int]):
       (forall (y: int): mem[int](y, l) =&gt; x &lt;= y)
     &amp; sorted(l) &lt;=&gt; sorted(icons(x, l))

end whyex
</pre></td></tr></table>
<p>Note that this defines a list datatype.  In the past, inline datatypes
could not generate the <code>map</code> or <code>reduce</code> functions, as they
needed extra theory parameters and had to generate external theories.
With declaration parameters, this is not a problem, so these are generated
inline.
</p>
<hr size="6">
<a name="Declaration-Parameter-Details"></a>
<h4 class="subsubsection">Declaration Parameter Details</h4>
<p>The parser has been modified to allow declarations to have an optional
argument of exactly the form of theory parameters, except that (for now)
importings, theory declarations, and constant declarations are not allowed.
</p>
<p>As declaration parameters are types, the PVS type checker can usually
infer the types, as seen in the examples above.  Where it becomes
ambiguous, names can include the parameters.  For example,
</p><table><tr><td>&nbsp;</td><td><pre class="example">th[t: TYPE]: THEORY
BEGIN
 f[s: TYPE](x: t): S
END th
</pre></td></tr></table>
<p>A reference to <code>f</code> may be unambiguous, if not, <code>f[int]</code> may
work, but PVS will try the actuals as both theory and declaration
parameters; if that doesn&rsquo;t work, then <code>f[int][int]</code> is allowed.  In
this case, that would be equivalent to <code>th[int].f[int]</code>.  Empty
brackets are allowed syntactically, but this hasn&rsquo;t been thoroughly
tested.  The intention is that <code>f[][int]</code> means <code>f</code> must come
from a theory with no parameters, while <code>f[int][]</code> means that
<code>f</code> must have one parameter in its theory, and no declaration
parameters.
</p>
<p>Most declarations allow these parameters, except for library declarations.
However, most judgements will fail to match if they have declaration
parameters, as the judgement mechanism uses a fairly simple matching
algorithm to ensure it is fast.
</p>
<p>In mappings for theory interpretations, uninterpreted types and constants
with declaration parameters must also include theory parameters, as shown
in the following example
</p><table><tr><td>&nbsp;</td><td><pre class="example">monad: THEORY
 BEGIN

 m[a: TYPE+]: TYPE+

 return[a: TYPE+]: [a -&gt; m[a]]

 &gt;&gt;=[a, b: TYPE+](x: m[a], f: [a -&gt; m[b]]): m[b] % infix
 &gt;&gt;=[a, b: TYPE+](x: m[a])(f: [a -&gt; m[b]]): m[b] = x &gt;&gt;= f; % Curried

 &gt;&gt;[a, b: TYPE+](x: m[a])(y: m[b]): m[b] = x &gt;&gt;= (lambda (z: a): y);

 join[a: TYPE+](x: m[m[a]]): m[a] = x &gt;&gt;= id[m[a]]

 bind_return[a, b: TYPE+]: AXIOM
   FORALL (x: a, f: [a -&gt; m[b]]): (return[a](x) &gt;&gt;= f) = f(x)

 bind_ret2[a: TYPE+]: AXIOM
   FORALL (x: m[a]): (x &gt;&gt;= return[a]) = x

END monad

Maybe[a: type]: datatype
begin
  Nothing: Nothing?
  Just(Val: a): Just?
end Maybe

maybe: THEORY
BEGIN
 importing Maybe

 bind[a, b: type](x:Maybe[a])(f: [a -&gt; Maybe[b]]): Maybe[b]
   = cases x of Nothing: Nothing, Just(y): f(y) endcases

 mm: theory =
      monad{{m[a: type] := Maybe[a],
             return[a: type] := Just[a],
             &gt;&gt;=[a, b: type](x:Maybe[a], f: [a -&gt; Maybe[b]])
                    := cases x of Nothing: Nothing,
                                  Just(y): f(y) endcases
            }}

  f(x: int): Maybe[int] =
      if rem(2)(x) = 0 then Nothing else Just(2 * x) endif
  g(x: int): Maybe[int] =
      if rem(3)(x) = 0 then Nothing else Just(3 * x) endif
  h(x: int): Maybe[int] =
      if rem(5)(x) = 0 then Nothing else Just(5 * x) endif
  k(x: int): Maybe[int] = f(x) &gt;&gt;= g &gt;&gt;= h
  k7: formula k(7) = Just(210)
  k25: formula k(25) = Nothing
 
end maybe
</pre></td></tr></table>

<hr size="6">
<a name="Better-Numeric-Simplification"></a>
<a name="Better-Numeric-Simplification-1"></a>
<h3 class="subsection">Better Numeric Simplification</h3>
<p>PVS 6.0 now includes better simplification as part of the prover
assert command for all the four arithmetic operators (<code>+</code>, <code>-</code>,
<code>*</code>, and <code>*</code>).  A new numeric expression class was introduced to
handle results that are not natural numbers, in particular negatives and
rationals.  What this means is that subterms such as
<code>(5 / 13 - 7 * 3)</code> get simplified to <code>-268/13</code>.  This can have a
dramatic effect in speed and readability.
</p>
<p>Various adjustments were made to rewriting, matching, etc., in order to,
for example, match the variables in <code>x / y</code> to the single rational
number <code>-268/13</code>.  This is not perfect, and some proofs will likely
need adjustment, depending on how much arithmetic is involved.
</p>
<hr size="6">
<a name="Controlling-Assert-Post_002dprocessing"></a>
<a name="Controlling-Assert-Post_002dprocessing-1"></a>
<h3 class="subsection">Controlling Assert Post-processing</h3>

<p>The prover <code>assert</code> command by default checks all of the type
predicates of any formula being asserted, as occasionally a contradiction
is found - e.g., <code>even?(3)</code>.  In some cases (e.g., the Bernstein
package of the NASA library), this check can take a significant amount of
time, without finding a contradiction.  In such cases, <code>assert</code>
will forgo the post-processing if the <code>ignore-typepreds?</code> flag is set
to <code>t</code>.  This flag has been included in all prover commands that
invoke <code>assert</code>.
</p>
<hr size="6">
<a name="Unicode-Support"></a>
<a name="Unicode-Support-1"></a>
<h3 class="subsection">Unicode Support</h3>
<p>PVS 6.0 supports Unicode.  As the release notes are written in Texinfo,
which does not support Unicode, the main documentation is in the PVS
Unicode help file, <code>M-x help-pvs-unicode</code> (<code>C-c C-h u</code>).  Note
that the help describes the Emacs input methods, but the point is PVS
specifications may include Unicode, however they are edited.
</p>
<hr size="6">
<a name="Loading-Patches"></a>
<a name="Loading-Patches-1"></a>
<h3 class="subsection">Loading Patches</h3>

<p>Patches are now loaded from files in <code>pvs-patches</code> subdirectories
located in the <code>PVS_LIBRARY_PATH</code> and the PVS distribution <code>lib</code>
(<code>M-x whereis-pvs</code> .  The files should have the form
<code>patch-*.lisp</code>, where the <code>*</code> is usually a number (not
required).  The <code>pvs-patches</code> subdirectories are searched in reverse
order: thus the PVS distribution <code>pvs-patches</code> will be loaded first,
and the patches in the first library appearing in <code>PVS_LIBRARY_PATH</code>
will be loaded last.  This only matters in case of conflicting patches,
and generally means that the patches in a given library override all
following patches.
</p>
<p>From within a <code>pvs-patch</code> subdirectory the files are
loaded in order of the numbers, if given, or the names.
</p>
<p>Note that this replaces the older patch mechanism - the <code>patchlevel</code>
arguments are still allowed, but <code>none</code> or 0 mean load no patches and
everything else is treated the same as the default and loads all patches.
</p>
<hr size="6">
<a name="PVSio_002dProofLite_002dField"></a>
<a name="PVSio_002c-ProofLite_002c-Field_002c-and-Manip"></a>
<h3 class="subsection">PVSio, ProofLite, Field, and Manip</h3>
<p>NASA developed these packages, and PVSio was earlier integrated into PVS.
Thanks to NASA, ProofLite, Field, and Manip packages are now integrated
into PVS, and no longer need to be separately obtained and installed.  The
documentation is included in the <code>doc</code> subdirectory of the PVS
distribution: <code>PVSio-2.d.pdf</code>, <code>manip-guide.pdf</code>,
<code>extrategies.pdf</code> (for Field), and <code>ProofLite-4.2.pdf</code>.  Note
that these may not reflect the integration, so ignore anything that
mentions obtaining and installing the package.
</p>
<hr size="6">
<a name="Theory-Interpretation-Changes"></a>
<a name="Theory-Interpretation-Changes-1"></a>
<h3 class="subsection">Theory Interpretation Changes</h3>
<p>There are a significant number of changes to theory interpretations,
mostly bug fixes and changes to handle declaration parameters.
</p>
<hr size="6">
<a name="finite_005fsets-allowed-in-recursive-types"></a>
<a name="Recursive-types-and-finite_005fsets"></a>
<h3 class="subsection">Recursive types and <code>finite_sets</code></h3>

<p>The (co)datatype mechanism has been modified to allow <code>finite_sets</code>
in recursive types, i.e.,
</p><table><tr><td>&nbsp;</td><td><pre class="example">tree[t: TYPE]: DATATYPE
BEGIN
 leaf: leaf?
 node(children: finite_set[tree]): node?
END
</pre></td></tr></table>
<p>Note that allowing <code>set[tree]</code> would cause problems, as the
cardinality of the type of tree cannot be determined so there cannot be a
set-theoretic semantics.  Finite sets cause no such problems.
</p>
<hr size="6">
<a name="recursive_002dtype_002dsubterm-strict_005fwell_005ffounded"></a>
<a name="Datatype-subterms"></a>
<h3 class="subsection">Datatype subterms</h3>
<p>The <code>&lt;&lt;</code> subterm relation generated for datatypes was declared to be
well-founded, but it is actually also strict, i.e., irreflexive and
transitive.  This property is often useful, and proving it for each
instance of a datatype is inconvenient, so it was added to both the
declaration and the axiom.
</p>

<hr size="6">
<a name="g_t6_002e0-Incompatibilities"></a>
<a name="Incompatibilities-2"></a>
<h2 class="section">Incompatibilities</h2>

<p>The changes in 6.0 lead to a number of incompatibilities, the impact is
primarily in the proofs.  As usual, the best way to deal with possible
incompatibilities is to make a copy of your specification directory, run
PVS 6.0 on it, and for any proof that fails in ways that are not obvious,
run the earlier version of PVS on the original directory in parallel.
Start the proofs with <code>M-x step-proof</code> and use <code>TAB 1</code> to step
through the two proofs, and look for differences.
</p><ul>
<li>
The handling of rationals tends to lead to smaller forms for arithmetic
expressions (see the Bernstein library at
<a href="http://shemesh.larc.nasa.gov/fm/ftp/larc/PVS-library/">http://shemesh.larc.nasa.gov/fm/ftp/larc/PVS-library/</a> for
examples where this is an issue).  In general, this makes proofs easier,
but in some cases, a rewrite that worked in earlier versions no longer
matches.  As the simplification only happens with an assert (or a strategy
that invokes assert), it may be possible to modify the proof by delaying
the assert.  Otherwise, it is always possible to use the lemma command to
instantiate the formula directly, followed by replace - the
<code>use</code> command may be useful here.
</li><li>
The declaration parameters allows names to have up to two sets of
parameters, i.e., <code>f[int][real]</code>, which would resolve to an
<code>f</code> from a theory with a single type parameter, and it would itself
have a single type parameter.  PVS also allows <code>f[real]</code>, and treats
this ambiguously.  To be less ambiguous, PVS should allow, e.g.,
<code>f[][real]</code>, which requires that the theory has no parameters.
To support this, empty square brackets can no longer be an operator.
This is somewhat mitigated by having Unicode available, so <code>\Box</code> and
<code>\Diamond</code> can be used in place of <code>[]</code> and <code>&lt;&gt;</code>.
</li></ul>

<p>Most of the other incompatibilities are more obvious, and the proofs are
easily repaired.  If you have difficulties understanding why a proof has
failed, or want help fixing it, send it to PVS bugs
<a href="mailto:pvs-bugs@csl.sri.com">pvs-bugs@csl.sri.com</a>.
</p><hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#PVS-6_002e0-Release-Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_2.html#PVS-5_002e0-Release-Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="pvs-release-notes.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Sam Owre</em> on <em>January 14, 2013</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
