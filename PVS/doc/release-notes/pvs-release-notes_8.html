<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on January 14, 2013 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>PVS Release Notes: PVS 3.0 Release Notes</title>

<meta name="description" content="PVS Release Notes: PVS 3.0 Release Notes">
<meta name="keywords" content="PVS Release Notes: PVS 3.0 Release Notes">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="pvs-release-notes_7.html#PVS-3_002e1-Release-Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="pvs-release-notes.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<hr size="2">
<a name="PVS-3_002e0-Release-Notes"></a>
<a name="PVS-3_002e0-Release-Notes-1"></a>
<h1 class="unnumbered">PVS 3.0 Release Notes</h1>

<p>The PVS 3.0 release notes contain the features, bug fixes, and
incompatibilities of PVS version 3.0 over version 2.4.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Overview">Overview</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#New-Features">New Features</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Bug-Fixes">Bug Fixes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Incompatibilities">Incompatibilities</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>

<hr size="6">
<a name="Overview"></a>
<a name="Overview-1"></a>
<h2 class="section">Overview</h2>

<p>We are still working on updating the documentation, and completion of
the <a href="http://ics.csl.sri.com">ICS</a> decision procedures.  Please let
us know of any bugs or suggestions you have by sending them to
<a href="mailto:pvs-bugs@csl.sri.com">PVS bugs</a>.
</p>
<p>In addition to the usual bug fixes, there are quite a few changes to
this release.  Most of these changes are backward compatible, but the
new multiple proofs feature makes it difficult to run PVS 3.0 in a
given context and then revert back to an earlier version.  For this
reason we strongly suggest that you copy existing directories
(especially the proof files) before running PVS 3.0 on existing
specifications.
</p>
<hr size="6">
<a name="New-Features"></a>
<a name="New-Features-4"></a>
<h2 class="section">New Features</h2>

<p>There are a number of new features in PVS 3.0.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Allegro6_002e2">Allegro 6.2 port</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Allegro 6.2 Port
</td></tr>
<tr><td align="left" valign="top"><a href="#Interpretations">Theory Interpretations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Multiple-Proofs">Multiple Proofs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Library-Support">Better Library Support</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Improved Library Support
</td></tr>
<tr><td align="left" valign="top"><a href="#Cotuples">Cotuples</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Coinduction">Coinduction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Coinductive Definitions
</td></tr>
<tr><td align="left" valign="top"><a href="#Datatype-Updates">Datatype Updates</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Datatype-Additions">Datatype Additions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Conversion-Extensions">Conversion Extensions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Conversion-Messages">Conversion Messages</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Conversion messages
</td></tr>
<tr><td align="left" valign="top"><a href="#More-TCC-information">More TCC Information</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> More TCC information
</td></tr>
<tr><td align="left" valign="top"><a href="#Show-Declaration-TCCs">Show Declaration TCCs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Numbers-as-constants">Numbers as Constants</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Numbers as constants
</td></tr>
<tr><td align="left" valign="top"><a href="#Theory-Search">Theory Search</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Theory search
</td></tr>
<tr><td align="left" valign="top"><a href="#Improved-Decision-Procedures">Improved Decision Procedures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Improved Existing (Shostak) Decision Procedures
</td></tr>
<tr><td align="left" valign="top"><a href="#ICS-Integration">ICS Integration</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> New (ICS) Decision Procedures
</td></tr>
<tr><td align="left" valign="top"><a href="#LET-Reduce">LET Reduce</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> LET Reduction Control
</td></tr>
<tr><td align="left" valign="top"><a href="#Prelude-Changes-in-3_002e0">Prelude Changes in 3.0</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#Conversion-Expressions">Conversion Expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Judgement-TCC-proofs">Judgement TCC proofs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#PVS-Startup-Change">PVS Startup Change</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Dump-File-Change">Dump File Change</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Bitvector-Library">Bitvector Library</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>


<hr size="6">
<a name="Allegro6_002e2"></a>
<a name="Allegro-6_002e2-port"></a>
<h3 class="subsection">Allegro 6.2 port</h3>

<p>PVS 3.0 has been ported to the case-sensitive version of Allegro
version 6.2.  This was done in order to be able to use the XML support
provided by Allegro 6.2.  We plan to both write and read XML abstract
syntax for PVS, which should make it easier to interact with other
systems.
</p>
<p>Note: for the most part, you may continue to define pvs-strategies
(and the files they load) as case insensitive, but in general this
cannot always be done correctly, and it means that you cannot load
such files directly at the lisp prompt.  If you suspect that your
strategies are not being handled properly, try changing it to all
lower case (except in specific instances), and see if that helps.  If
not, send the strategies file to
<a href="mailto:pvs-bugs@csl-sri.com">PVS Bugs</a> and we&rsquo;ll fix it as
quickly as we can.  Because there is no way to handle it robustly, and
since case-sensitivity can actually be useful, in the future we may
not support mixed cases in strategy files.
</p>
<hr size="6">
<a name="Interpretations"></a>
<a name="Theory-Interpretations-1"></a>
<h3 class="subsection">Theory Interpretations</h3>

<p>Theory interpretations are described fully in
<a href="http://pvs.csl.sri.com/doc/interpretations.html">Theory Interpretations in PVS</a>
</p>
<p><strong>NOTES:</strong>
</p>
<ul>
<li>
This introduces one backward incompatible change; theory abbreviations
such as
<table><tr><td>&nbsp;</td><td><pre class="example">foo: THEORY = bar[int, 3]
</pre></td></tr></table>
<p>should be changed to the new form
</p><table><tr><td>&nbsp;</td><td><pre class="example">IMPORTING bar[int, 3] AS foo
</pre></td></tr></table>
<p>Note that &lsquo;<code>AS</code>&rsquo; is a new keyword, and may cause parse errors
where none existed before.
</p>
</li><li>
The stacks example doesn&rsquo;t work as given, and there is an improved
version that will be available shortly, built on the new equivalence
class definition in the prelude.

<p>Otherwise unprovable TCCs result (e.g., every stack is nonempty).
</p></li></ul>

<hr size="6">
<a name="Multiple-Proofs"></a>
<a name="Multiple-Proofs-1"></a>
<h3 class="subsection">Multiple Proofs</h3>

<p>PVS now supports multiple proofs for a given formula.  When a proof
attempt is ended, either by quitting or successfully completing the
proof, the proof is checked for changes.  If any changes have occured, the
user is queried about whether to save the proof, and whether to overwrite
the current proof or to create a new proof.  If a new proof is created,
the user is prompted for a proof identifier and description.
</p>
<p>In addition to a proof identifier, description, and proof script, the
new proof contains the status, the date of creation, the date last
run, and the run time.  Note that this information is kept in the
<code>.prf</code> files, which therefore look different from those of
earlier PVS versions.
</p>
<p>Every formula that has proofs has a default proof, which is used for
most of the existing commands, such as prove, prove-theory, and
status-proofchain.  Whenever a proof is saved, it automatically
becomes the default.
</p>
<p>Three new Emacs commands allow for browsing and manipulating multiple
proofs: <code>display-proofs-formula</code>, <code>display-proofs-theory</code>,
and <code>display-proofs-pvs-file</code>.  These commands all pop up buffers
with a table of proofs.  The default proof is marked with a
&lsquo;<code>+</code>&rsquo;.  Within such buffers, the following keys have the
following effects.
</p>
<dl compact="compact">
<dt> <kbd>Key</kbd></dt>
<dd><p>Effect
</p></dd>
<dt> <kbd>c</kbd></dt>
<dd><p>Change description: add or change the description for the proof
</p></dd>
<dt> <kbd>d</kbd></dt>
<dd><p>Default proof: set the default to the specified proof
</p></dd>
<dt> <kbd>e</kbd></dt>
<dd><p>Edit proof: bring up a Proof buffer for the specified proof; the proof
may then be applied to other formulas
</p></dd>
<dt> <kbd>p</kbd></dt>
<dd><p>Prove: rerun the specified proof (makes it the default)
</p></dd>
<dt> <kbd>q</kbd></dt>
<dd><p>Quit: exit the Proof buffer
</p></dd>
<dt> <kbd>r</kbd></dt>
<dd><p>Rename proof: rename the specified proof
</p></dd>
<dt> <kbd>s</kbd></dt>
<dd><p>Show proof: Show the specified proof in a Proof:<em>id</em> buffer
</p></dd>
<dt> <kbd>DEL</kbd></dt>
<dd><p>Delete proof: delete the specified proof from the formula
</p></dd>
</dl>

<p>At the end of a proof a number of questions may be asked:
</p>
<ul>
<li> Would you like the proof to be saved?
</li><li> Would you like to overwrite the current proof?
</li><li> Please enter an id
</li><li> Please enter a description:
</li></ul>

<p>This may be annoying to some users, so the command <code>M-x
pvs-set-proof-prompt-behavior</code> was added to control this.  The
possible values are:
</p>
<dl compact="compact">
<dt> <code>:ask</code></dt>
<dd><p>the default; all four questions are asked
</p></dd>
<dt> <code>:overwrite</code></dt>
<dd><p>similar to earlier PVS versions; asks if the proof should be
saved and then simply overwrites the earlier one.
</p></dd>
<dt> <code>:add</code></dt>
<dd><p>asks if the proof should be saved, then creates a new proof with a
generated id and empty description.
</p></dd>
</dl>

<p>Note that the id and description may be modified later using the
commands described earlier in this section.
</p>   
<hr size="6">
<a name="Library-Support"></a>
<a name="Better-Library-Support"></a>
<h3 class="subsection">Better Library Support</h3>

<p>PVS now uses the <code>PVS_LIBRARY_PATH</code> environment variable to look
for library pathnames, allowing libraries to be specified as simple
(subdirectory) names.  This is an extension of the way, for example,
the <code>finite_sets</code> library is found relative to the PVS
installation path&mdash;in fact it is implicitly appended to the end the
<code>PVS_LIBRARY_PATH</code>.
</p>
<p>The <code>.pvscontext</code> file stores, amongst other things, library
dependencies.  Any library found as a subdirectory of a path in the
<code>PVS_LIBRARY_PATH</code> is stored as simply the subdirectory name.
Thus if the <code>.pvscontext</code> file is included in a tar file, it may
be untarred on a different machine as long as the needed libraries
may be found in the <code>PVS_LIBRARY_PATH</code>.  This makes libraries
much more portable.
</p>
<p>In addition, the <code>load-prelude-library</code> command now automatically
loads the <code>pvs-lib.el</code> file, if it exists, into Emacs and the
<code>pvs-lib.lisp</code> file, if it exists, into lisp, allowing the
library to add new features, e.g., key-bindings.  Note that the
<code>pvs-lib.lisp</code> file is not needed for new strategies, which
should go into the <code>pvs-strategies</code> file as usual.  The
difference is that the <code>pvs-strategies</code> file is only loaded when
a proof is started, and it may be desirable to have some lisp code
that is loaded with the library, for example, to support some new
Emacs key-bindings.
</p>
<p>The <code>PVS_LIBRARY_PATH</code> is a colon-separated list of paths, and
the <code>lib</code> subdirectory of the PVS path is added implicitly at
the end.  Note that the paths given in the <code>PVS_LIBRARY_PATH</code>
are expected to have subdirectories, e.g., if you have put Ben Di Vito&rsquo;s
<a href="http://shemesh.larc.nasa.gov/people/bld/manip.html">Manip-package</a>
in <code>~/pvs-libs/Manip-1.0</code>, then your <code>PVS_LIBRARY_PATH</code>
should only include <code>~/pvs-libs</code>, not
<code>~/pvs-libs/Manip-1.0</code>.
</p>
<p>If the <code>pvs-libs.lisp</code> file needs to load other files in other
libraries, use <code>libload</code>.  For example, C&eacute;sar Mu&ntilde;oz&rsquo;s
<a href="http://www.icase.edu./~munoz/Field/field.html">Field Package</a>
loads the <code>Manip-package</code>
using <code>(libload &quot;Manip-1.0/manip-strategies&quot;)</code>
</p>
<p>A new command, <code>M-x list-prelude-libraries</code>, has been added that
shows the prelude library and supplemental files that have been
loaded in the current context.
</p>   
<hr size="6">
<a name="Cotuples"></a>
<a name="Cotuples-1"></a>
<h3 class="subsection">Cotuples</h3>

<p>PVS now supports cotuple types (also known as coproduct or sum types)
directly.  The syntax is similar to that for tuple types, but with the
&lsquo;<code>,</code>&rsquo; replaced by a &lsquo;<code>+</code>&rsquo;.  For example,
</p>   
<table><tr><td>&nbsp;</td><td><pre class="example">cT: TYPE = [int + bool + [int -&gt; int]]
</pre></td></tr></table>

<p>Associated with a cotuple type are injections <code>IN_</code><em>i</em>,
predicates <code>IN?_</code><em>i</em>, and extractions <code>OUT_</code><em>i</em>
(none of these is case-sensitive).  For example, in this case we have
</p>   
<table><tr><td>&nbsp;</td><td><pre class="example">IN_1:  [int -&gt; cT]
IN?_1: [cT -&gt; bool]
OUT_1: [(IN?_1) -&gt; int]
</pre></td></tr></table>

<p>Thus <code>IN_2(true)</code> creates a <code>cT</code> element, and an arbitrary
<code>cT</code> element <code>c</code> is processed using <code>CASES</code>, e.g.,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">CASES c OF
  IN_1(i): i + 1,
  IN_2(b): IF b THEN 1 ELSE 0 ENDIF,
  IN_3(f): f(0)
ENDCASES
</pre></td></tr></table>

<p>This is very similar to using the <code>union</code> datatype defined in the
prelude, but allows for any number of arguments, and doesn&rsquo;t generate
a datatype theory.
</p>
<p>Typechecking expressions such as <code>IN_1(3)</code> requires that the
context of its use be known.  This is similar to the problem of a
standalone <code>PROJ_1</code>, and both are now supported:
</p>	 
<table><tr><td>&nbsp;</td><td><pre class="example">F: [cT -&gt; bool]
FF: FORMULA F(IN_1(3))
G: [[int -&gt; [int, bool, [int -&gt; int]]] -&gt; bool]
GG: FORMULA G(PROJ_1)
</pre></td></tr></table>

<p>This means it is easy to write terms that are ambiguous:
</p>	 
<table><tr><td>&nbsp;</td><td><pre class="example">HH: FORMULA IN_1(3) = IN_1(4)
HH: FORMULA PROJ_1 = PROJ_1
</pre></td></tr></table>

<p>This can be disambiguated by providing the type explicitly:
</p>	 
<table><tr><td>&nbsp;</td><td><pre class="example">HH: FORMULA IN_1[cT](3) = IN_1(4)
HH: FORMULA PROJ_1 = PROJ_1[[int, int]]
</pre></td></tr></table>

<p>This uses the same syntax as for actual parameters, but doesn&rsquo;t mean
the same thing, as the projections, injections, etc., are builtin, and
not provided by any theories.  Note that coercions don&rsquo;t work in this
case, as <code>PROJ_1::[[int, int] -&gt; int]</code> is the same as
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(LAMBDA (x: [[int, int] -&gt; int]): x)(PROJ_1)
</pre></td></tr></table>

<p>and not
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">LAMBDA (x: [int, int]): PROJ_1(x)
</pre></td></tr></table>

<p>The prover has been updated to handle extensionality and reduction rules
as expected.
</p>   
<hr size="6">
<a name="Coinduction"></a>
<a name="Coinduction-1"></a>
<h3 class="subsection">Coinduction</h3>

<p>Coinductive definitions are now supported.  They are like inductive
definitions, but introduced with the keyword &lsquo;<code>COINDUCTIVE</code>&rsquo;, and
generate the greatest fixed point.
</p>
   
<hr size="6">
<a name="Datatype-Updates"></a>
<a name="Datatype-Updates-1"></a>
<h3 class="subsection">Datatype Updates</h3>

<p>Update expressions now work on datatypes, in much the same way they work
on records.  For example, if <code>lst: list[nat]</code>, then <code>lst WITH
[`car := 0]</code> returns the list with first element 0, and the rest the
same as the cdr of <code>lst</code>.  In this case there is also a TCC of the
form <code>cons?(lst)</code>, as it makes no sense to set the car of
<code>null</code>.
</p>
<p>Complex datatypes with overloaded accessors and dependencies are also
handled.  For example,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  dt: DATATYPE
  BEGIN
   c0: c0?
   c1(a: int, b: {z: (even?) | z &gt; a}, c: int): c1?
   c2(a: int, b: {n: nat | n &gt; a}, c: int): c2?
  END dt

  datatype_update: THEORY
  BEGIN
   IMPORTING dt
   x: dt
   y: int
   f: dt = x WITH [b := y]
  END datatype_update
</pre></td></tr></table>

<p>This generates the TCC
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">f_TCC1: OBLIGATION
    (c1?(x) AND even?(y) AND y &gt; a(x))
 OR (c2?(x) AND y &gt;= 0 AND y &gt; a(x));
</pre></td></tr></table>


   
<hr size="6">
<a name="Datatype-Additions"></a>
<a name="Datatype-Additions-1"></a>
<h3 class="subsection">Datatype Additions</h3>

<p>There are two additions to the theory generated from a datatype: a new
ord function, and an every relation.  Both of these can be seen by
examining the generated theories.
</p>
<p>The new ord function is given as a constant followed by an ordinal
axiom.  The reason for this is that the disjointness axiom is not
generated, and providing interpretations for datatype theories without
it is not sound.  However, for large numbers of constructors, the
disjointness axiom gets unwieldy, and can significantly slow down
typechecking.  The ord axiom simply maps each constructor to a natural
number, thus using the builtin disjointness of the natural numbers.
For lists, the new ord function and axiom are
</p><table><tr><td>&nbsp;</td><td><pre class="example">  list_ord: [list -&gt; upto(1)]

  list_ord_defaxiom: AXIOM
    list_ord(null) = 0 AND
     (FORALL (car: T, cdr: list): list_ord(cons(car, cdr)) = 1);
</pre></td></tr></table>
<p>This means that to fully interpret the list datatype, <code>list_ord</code>
must be given a mapping and shown to satisfy the axiom.
</p>
<p>If a top level datatype generates a map theory, the theory also contains
an <code>every</code> relation.  For lists, for example, it is defined as
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  every(R: [[T, T1] -&gt; boolean])(x: list[T], y: list[T1]):  boolean =
      null?(x) AND null?(y) OR
       cons?(x) AND
        cons?(y) AND R(car(x), car(y)) AND every(R)(cdr(x), cdr(y));
</pre></td></tr></table>

<p>Thus, <code>every(&lt;)(x, y: list[nat])</code> returns true if the
lists x and y are of the same length, and each element of <code>x</code> is
less than the corresponding element of <code>y</code>.
</p>
<hr size="6">
<a name="Conversion-Extensions"></a>
<a name="Conversion-Extensions-1"></a>
<h3 class="subsection">Conversion Extensions</h3>

<p>Conversions are now applied to the components of tuple, record, and
function types.  For example, if <code>c1</code> is a conversion from
<code>nat</code> to <code>bool</code>, and <code>c2</code> from <code>nat</code> to
<code>list[bool]</code>, the tuple <code>(1, 2, 3)</code> will be
converted to <code>(c1(1), 2, c2(3))</code> if the expected type is
<code>[bool, nat, list[bool]]</code>.  Records are treated the same way, but
functions are contravariant in the domain; if <code>f</code> is a function
of type <code>[bool -&gt; list[bool]]</code>, and the expected type is <code>[nat -&gt;
bool]</code>, then the conversion applied is <code>LAMBDA (x: nat):
c2(f(c1(x)))</code>.
</p>
<p>Conversions now apply pointwise where possible.  In the past, if
<code>x</code> and <code>y</code> were state variables, and <code>K_conversions</code>
enabled, then <code>x &lt; y</code> would be converted to <code>LAMBDA (s: state):
x(s) &lt; y(s)</code>, but <code>x = y</code> would be converted to <code>LAMBDA (s:
state): x = y</code>, since the equality typechecks without applying the
conversion pointwise.  Of course, this is rarely what is intended; it
says that the two state variables are the same, i.e., aliases.  The
conversion mechanism has been modified to deal with this properly.
</p>
<hr size="6">
<a name="Conversion-Messages"></a>
<a name="Conversion-Messages-1"></a>
<h3 class="subsection">Conversion Messages</h3>

<p>Messages related to conversions have been separated out from the
warnings, so that if any are generated a message is produced such as
</p><table><tr><td>&nbsp;</td><td><pre class="example">po_lems typechecked in 9.56s: 10 TCCs, 0 proved, 3 subsumed,
                    7 unproved; 4 conversions; 2 warnings; 3 msgs
</pre></td></tr></table>
<p>In addition, the commands <code>M-x show-theory-conversions</code> and <code>M-x
show-pvs-file-conversions</code> have been added to view the conversions.
</p>
<hr size="6">
<a name="More-TCC-information"></a>
<a name="More-TCC-Information"></a>
<h3 class="subsection">More TCC Information</h3>

<p>Trivial TCCs of the form <code>x /= 0 IMPLIES x /= 0</code> and <code>45 &lt;
256</code> used to quietly be suppressed.  Now they are added to the
messages associated with a theory, along with subsumed TCCs.  In addition,
both trivial and subsumed TCCs are now displayed in commented form in the
show-tccs buffer.
</p>
<hr size="6">
<a name="Show-Declaration-TCCs"></a>
<a name="Show-Declaration-TCCs-1"></a>
<h3 class="subsection">Show Declaration TCCs</h3>

<p>The command <code>M-x show-declaration-tccs</code> has been added.  It shows
the TCCs associated with the declaration at the cursor, including the
trivial and subsumed TCCs as described above.
</p>
<hr size="6">
<a name="Numbers-as-constants"></a>
<a name="Numbers-as-Constants"></a>
<h3 class="subsection">Numbers as Constants</h3>

<p>Numbers may now be declared as constants, e.g.,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">42: [int -&gt; int] = LAMBDA (x: int): 42
</pre></td></tr></table>

<p>This is most useful in defining algebraic structures (groups, rings,
etc.), where overloading 0 and 1 is common mathematical practice.
It&rsquo;s usually a bad idea to declare a constant to be of a number type,
e.g.,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">42: int = 57
</pre></td></tr></table>

<p>Even if the typechecker didn&rsquo;t get confused, most readers would.
</p>

<hr size="6">
<a name="Theory-Search"></a>
<a name="Theory-Search-1"></a>
<h3 class="subsection">Theory Search</h3>

<p>   When the parser encounters an importing for a theory <code>foo</code> that
has not yet been typechecked, it looks first in the <code>.pvscontext</code>
file, then looks for <code>foo.pvs</code>. In previous versions, if the theory
wasn&rsquo;t found at this point an error would result.  The problem is that
file names often don&rsquo;t match the theory names, either because a given file
may have multiple theories, or a naming convention (e.g., the file is
lower case, but theories are capitalized)
</p>
<p>   Now the system will parse every <code>.pvs</code> file in the current
context, and if there is only one file with that theory id in it, it will
be used.  If multiple files are found, a message is produced indicating
which files contain a theory of that name, so that one of those may be
selected and typechecked.
</p>
<p><strong>NOTES:</strong>
</p>   
<ul>
<li>
Once a file has been typechecked, the <code>.pvscontext</code> is
updated accordingly, and this check is no longer needed.
</li><li>
<code>.pvs</code> files that contain parse errors will be ignored.
</li></ul>


<hr size="6">
<a name="Improved-Decision-Procedures"></a>
<a name="Improved-Decision-Procedures-1"></a>
<h3 class="subsection">Improved Decision Procedures</h3>

<p>The existing (named Shostak, for the original author) decision
procedures have been made more complete.  Note that this sometimes
breaks existing proofs, though they are generally easy to repair,
especially if the proof is rerun in parallel with the older PVS
version.  If you have difficulties repairing your proofs, please let
us know.
</p>

<hr size="6">
<a name="ICS-Integration"></a>
<a name="ICS-Integration-1"></a>
<h3 class="subsection">ICS Integration</h3>

<p>PVS 3.0 now has an alpha test integration of the
<a href="http://ics.csl.sri.com">ICS decision procedure</a>.  Use <code>M-x
set-decision-procedure ics</code> to try it out.  Note that this is subject
to change, so don&rsquo;t count on proofs created using ICS to work in
future releases.  Please let us know of any bugs encountered.
</p>

<hr size="6">
<a name="LET-Reduce"></a>
<a name="LET-Reduce-1"></a>
<h3 class="subsection">LET Reduce</h3>

<p>   The <code>BETA</code> and <code>SIMPLIFY</code> rules, and the <code>ASSERT</code>,
<code>BASH</code>, <code>REDUCE</code>, <code>SMASH</code>, <code>GRIND</code>,
<code>GROUND</code>, <code>USE</code>, and <code>LAZY-GRIND</code> strategies now all
take an optional <code>LET-REDUCE?</code> flag.  It defaults to <code>t</code>,
and if set to <code>nil</code> keeps <code>LET</code> expressions from being
reduced.
</p>
<hr size="6">
<a name="Prelude-Changes-in-3_002e0"></a>
<a name="Prelude-Changes-in-3_002e0-1"></a>
<h3 class="subsection">Prelude Changes in 3.0</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#New-Theories">New Theories</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#New-Declarations">New Declarations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#Modified-Declarations">Modified Declarations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>

<hr size="6">
<a name="New-Theories"></a>
<a name="New-Theories-1"></a>
<h4 class="subsubsection">New Theories</h4>

<dl compact="compact">
<dt> <code>restrict_props, extend_props</code></dt>
<dd><p>Provides lemmas that <code>restrict</code> and <code>extend</code> are identities when the
subtype equals the supertype.
</p></dd>
<dt> <code>indexed_sets</code></dt>
<dd><p>Provides indexed union and intersection operations and lemmas.
</p></dd>
<dt> <code>number_fields</code></dt>
<dd><p>The <code>real</code> theory was split into two, with <code>number_fields</code>
providing the field axioms and the subtype <code>reals</code> providing the
ordering axioms.  This allows for theories such as complex numbers to
be inserted in between, thus allowing reals to be a subtype of complex
numbers without having to encode them.
</p></dd>
<dt> <code>nat_fun_props</code></dt>
<dd><p>Defines special properties of injective/surjective functions over
nats, provided by Bruno Dutertre.
</p></dd>
<dt> <code>finite_sets</code></dt>
<dd><p>combination of <code>finite_sets_def</code> (which was in the 2.4 prelude),
<code>card_def</code>, and <code>finite_sets</code> (from the finite_sets library)
</p></dd>
<dt> <code>bitvectors:</code></dt>
<dd><p>To provide support for the bitvector theory built in  to ICS, the
following theories were moved from the bitvectors library to the
prelude:
<code>bit</code>, <code>bv</code>, <code>exp2</code>, <code>bv_cnv</code>,
<code>bv_concat_def</code>, <code>bv_bitwise</code>, <code>bv_nat</code>,
<code>empty_bv</code>, and <code>bv_caret</code>.
</p></dd>
<dt> <code>finite_sets_of_sets</code></dt>
<dd><p>Proves that the powerset of a finite set is finite, and provides the
corresponding judgement.
</p></dd>
<dt> <code>equivalence classes</code></dt>
<dd><p>The following theories were derived from those provided by Bart Jacobs:
</p>
<p><code>EquivalenceClosure</code>,<br> <code>QuotientDefinition</code>,<br>
<code>KernelDefinition</code>,<br> <code>QuotientKernelProperties</code>,<br>
<code>QuotientSubDefinition</code>,<br> <code>QuotientExtensionProperties</code>,<br>
<code>QuotientDistributive</code>, and<br> <code>QuotientIteration</code>.
</p></dd>
<dt> <code>Partial Functions</code></dt>
<dd><p>Bart Jacobs also provided definitions for partial functions:<br>
<code>PartialFunctionDefinitions</code> and
<code>PartialFunctionComposition</code>.
</p></dd>
</dl>

<hr size="6">
<a name="New-Declarations"></a>
<a name="New-Declarations-1"></a>
<h4 class="subsubsection">New Declarations</h4>

<p>The following declarations have been added to the prelude:
</p><ul>
<li> <code>relations.equivalence type</code>,
</li><li> <code>sets.setofsets</code>,
</li><li> <code>sets.powerset</code>,
</li><li> <code>sets.Union</code>,
</li><li> <code>sets.Intersection</code>,
</li><li> <code>sets_lemmas.subset_powerset</code>,
</li><li> <code>sets_lemmas.empty_powerset</code>,
</li><li> <code>sets_lemmas.nonempty_powerset</code>,
</li><li> <code>real_props.div_cancel4</code>, and
</li><li> <code>rational_props.rational_pred_ax2</code>.
</li></ul>

<hr size="6">
<a name="Modified-Declarations"></a>
<a name="Modified-Declarations-1"></a>
<h4 class="subsubsection">Modified Declarations</h4>

<p>The following declarations have been modified.
<code>finite_sets.is_finite_surj</code> was turned into an IFF and extended
from posnat to nat.
</p>
<p>The fixpoint declarations of the <code>mucalculus</code> theory have been
restricted to monotonic predicates.  This affects the declarations
<code>fixpoint?</code>, <code>lfp</code>, <code>mu</code>, <code>lfp?</code>, <code>gfp</code>,
<code>nu</code>, and <code>gfp?</code>.
</p>
<hr size="6">
<a name="Conversion-Expressions"></a>
<a name="Conversion-Expressions-1"></a>
<h3 class="subsection">Conversion Expressions</h3>

<p>Conversions may now be any function valued expression, for example,
</p><table><tr><td>&nbsp;</td><td><pre class="example">CONVERSION+ EquivClass(ce), lift(ce), rep(ce)
</pre></td></tr></table>
<p>This introduces a possible incompatibility if the following
declaration is for an infix operator.  In that case the conversion
must be followed with a semi-colon &rsquo;<code>;</code>&rsquo;.
</p>
<hr size="6">
<a name="Judgement-TCC-proofs"></a>
<a name="Judgement-TCC-proofs-1"></a>
<h3 class="subsection">Judgement TCC proofs</h3>

<p>Judgement TCCs may now be proved directly, without having to show the
TCCs using <code>M-x show-tccs</code> or <code>M-x prettyprint-expanded</code>.
Simple place the cursor on the judgement, and run one of the proof
commands.  Note that there may be several TCCs associated with the
judgement, but only one of them is the judgement TCC.  To prove the
others you still need to show the TCCs first.
</p>
<hr size="6">
<a name="PVS-Startup-Change"></a>
<a name="PVS-Startup-Change-1"></a>
<h3 class="subsection">PVS Startup Change</h3>

<p>On startup, PVS no longer asks whether to create a context file if
none exists, and if you simply change to another directory no
<code>.pvscontext</code> file is created.  This fixes a subtle bug in which
typing input before the question is asked caused PVS to get into a bad
state.
</p>
<hr size="6">
<a name="Dump-File-Change"></a>
<a name="Dump-File-Change-1"></a>
<h3 class="subsection">Dump File Change</h3>

<p>The <code>M-x dump-pvs-files</code> command now includes PVS version
information, Allegro build information, and prelude library
dependencies.  Note that since the proof files have changed, the dumps
may look quite different.  See the Multiple Proofs section for details.
</p>
<hr size="6">
<a name="Bitvector-Library"></a>
<a name="Bitvector-Library-1"></a>
<h3 class="subsection">Bitvector Library</h3>

<p>Bart Jacobs kindly provided some additional theories for the bitvector
library.  These were used as an aid to Java code verification, but are
generally useful.  The new files are
</p><ul>
<li> <code>BitvectorUtil</code>,
</li><li> <code>BitvectorMultiplication</code>,
</li><li> <code>BitvectorMultiplicationWidenNarrow</code>,
</li><li> <code>DivisionUtil</code>,
</li><li> <code>BitvectorOneComplementDivision</code>,
</li><li> <code>BitvectorTwoComplementDivision</code>, and
</li><li> <code>BitvectorTwoComplementDivisionWidenNarrow</code>.
</li></ul>
<p>These are included in the libraries tar file.
</p>
<hr size="6">
<a name="Bug-Fixes"></a>
<a name="Bug-Fixes-1"></a>
<h2 class="section">Bug Fixes</h2>

<p>Although there are still a number of bugs still outstanding, a large
number of bugs have been fixed in this release.  All those in the
<a href="http://pvs.csl.sri.com/cgi-bin/pvs/pvs-bug-list/?bugs=open&amp;bugs=analyzed">pvs-bugs list</a> that are marked as analyzed have been fixed, at least
for the specific specs that caused the bugs.
</p>
<hr size="6">
<a name="Incompatibilities"></a>
<a name="Incompatibilities-5"></a>
<h2 class="section">Incompatibilities</h2>

<p>Most of these are covered elsewhere, they are collected here for easy
reference.
</p>
<hr size="6">
<a name="Improved-Decision-Procedures-2"></a>
<h3 class="subsection">Improved Decision Procedures</h3>
<p>The decision procedures are more complete.  Though this is usually a
good thing, some existing proofs may fail.  For example, a given
auto-rewrite may have worked in the past, but now the key term has
been simplified and the rewrite no longer matches.
</p>
<hr size="6">
<a name="Prelude-Incompatibilities"></a>
<h3 class="subsection">Prelude Incompatibilities</h3>
<p>These are given in Prelude Changes in 3.0.  Theory identifiers used in
the prelude may not be used for library or user theories, some
existing theories may need to be adjusted.
</p>
<p>The theories <code>finite_sets</code>, <code>finite_sets_def</code>, and
<code>card_def</code> were once a part of the <code>finite_sets</code> library,
but have been merged into a single <code>finite_sets</code> theory and moved
to the prelude.  This means that the library references such as
</p><table><tr><td>&nbsp;</td><td><pre class="example">IMPORTING finite_sets@finite_sets
IMPORTING fsets@card_def
</pre></td></tr></table>
<p>must be changed.  In the first case just drop the prefix, drop the
prefix and change <code>card_def</code> to <code>finite_sets</code> in the second.
</p>
<p>The <code>reals</code> theory was split in two, separating out the field
axioms into the <code>number_fields</code> theory.  There is the possibility
that proofs could fail because of adjustments related to this, though
this did not show up in our validations.
</p>
<hr size="6">
<a name="Theory-Abbreviations"></a>
<h3 class="subsection">Theory Abbreviations</h3>
<p>Theory abbreviations such as
</p><table><tr><td>&nbsp;</td><td><pre class="example">foo: THEORY = bar[int, 3]
</pre></td></tr></table>
<p>should be changed to the new form
</p><table><tr><td>&nbsp;</td><td><pre class="example">IMPORTING bar[int, 3] AS foo
</pre></td></tr></table>
<p>Note that &lsquo;<code>AS</code>&rsquo; is a new keyword, and may cause parse errors
where none existed before.
</p>
<hr size="6">
<a name="Conversion-Expressions-2"></a>
<h3 class="subsection">Conversion Expressions</h3>
<p>Since conversions may now be arbitrary function-valued expressions, if
the declaration following is an infix operator it leads to ambiguity.
In that case the conversion must be followed with a semi-colon
&rsquo;<code>;</code>&rsquo;.
</p>
<hr size="6">
<a name="Occurrence-numbers-in-expand-proof-command"></a>
<h3 class="subsection">Occurrence numbers in <code>expand</code> proof command</h3>

<p>Defined infix operators were difficult to expand in the past, as the
left to right count was not generally correct; the arguments were
looked at before the operator, which meant that the parser tree had to
be envisioned in order to get the occurrence number correct.  This bug
has been fixed, but it does mean that proofs may need to be adjusted.
This is another case where it helps to run an earlier PVS version in
parallel to find out which occurrence is actually intended.
</p>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#PVS-3_002e0-Release-Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="pvs-release-notes.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="pvs-release-notes_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Sam Owre</em> on <em>January 14, 2013</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
